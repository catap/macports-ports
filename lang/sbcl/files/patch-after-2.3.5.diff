diff --git .github/workflows/windows.yml .github/workflows/windows.yml
index d464b1796..da25c580f 100644
--- .github/workflows/windows.yml
+++ .github/workflows/windows.yml
@@ -20,7 +20,7 @@ jobs:
     - name: install host sbcl
       shell: pwsh
       run: |
-        cinst sbcl -source tools-for-build
+        choco install sbcl -source tools-for-build
     - name: build
       env:
         SBCL_HOME: "/c/Program Files/Steel Bank Common Lisp/1.4.14"
diff --git NEWS NEWS
index 17537ff92..e5126befc 100644
--- NEWS
+++ NEWS
@@ -1,5 +1,10 @@
 ;;;; -*- coding: utf-8; fill-column: 78 -*-
 
+changes relative to sbcl-2.3.5:
+  * bug fix: riscv can build contribs again.
+  * optimization: better (the word-sized-type (ASH word-sized word-sized))
+    when the result can overflow. For arm64 and x86-64.
+
 changes in sbcl-2.3.5 relative to sbcl-2.3.4:
   * enhancement: Unicode support has been updated to support version 15.0.0 of
     the Unicode standard, including addition of characters and their collation
diff --git crossbuild-runner/backends/sparc/stuff-groveled-from-headers.lisp crossbuild-runner/backends/sparc/stuff-groveled-from-headers.lisp
index 4d96c2e81..7dd8b41e0 100644
--- crossbuild-runner/backends/sparc/stuff-groveled-from-headers.lisp
+++ crossbuild-runner/backends/sparc/stuff-groveled-from-headers.lisp
@@ -7,6 +7,7 @@
 (defconstant rtld-lazy 1) ; #x1
 (defconstant rtld-now 2) ; #x2
 (defconstant rtld-global 256) ; #x100
+
 (in-package "SB-UNIX")
 
 ;;; select()
@@ -19,17 +20,16 @@
 (defconstant pollnval 32) ; #x20
 (defconstant pollerr 8) ; #x8
 (define-alien-type nfds-t (unsigned 32))
-;;; langinfo
-(defconstant codeset 14) ; #xe
 ;;; types, types, types
 (define-alien-type clock-t (signed 32))
-(define-alien-type dev-t (unsigned 64))
+(define-alien-type dev-t (unsigned 32))
 (define-alien-type gid-t (unsigned 32))
 (define-alien-type ino-t (unsigned 32))
 (define-alien-type mode-t (unsigned 32))
 (define-alien-type nlink-t (unsigned 32))
 (define-alien-type off-t (signed 32))
 (define-alien-type size-t (unsigned 32))
+(define-alien-type ssize-t (signed 32))
 (define-alien-type time-t (signed 32))
 (define-alien-type suseconds-t (signed 32))
 (define-alien-type uid-t (unsigned 32))
@@ -37,7 +37,7 @@
 ;; Don't use these types for anything other than the stat wrapper.
 (define-alien-type wst-ino-t (unsigned 32))
 (define-alien-type wst-dev-t (unsigned 32))
-(define-alien-type wst-off-t (unsigned 32))
+(define-alien-type wst-off-t (signed 32))
 (define-alien-type wst-blksize-t (signed 32))
 (define-alien-type wst-blkcnt-t (signed 32))
 (define-alien-type wst-nlink-t (unsigned 32))
@@ -54,11 +54,11 @@
 (defconstant o_rdonly 0) ; #x0
 (defconstant o_wronly 1) ; #x1
 (defconstant o_rdwr 2) ; #x2
-(defconstant o_accmode 3) ; #x3
-(defconstant o_creat 512) ; #x200
-(defconstant o_excl 2048) ; #x800
-(defconstant o_noctty 32768) ; #x8000
-(defconstant o_trunc 1024) ; #x400
+(defconstant o_accmode 6291459) ; #x600003
+(defconstant o_creat 256) ; #x100
+(defconstant o_excl 1024) ; #x400
+(defconstant o_noctty 2048) ; #x800
+(defconstant o_trunc 512) ; #x200
 (defconstant o_append 8) ; #x8
 ;;;
 (defconstant s-ifmt 61440) ; #xf000
@@ -78,51 +78,54 @@
 (defconstant eagain 11) ; #xb
 (defconstant eio 5) ; #x5
 (defconstant eexist 17) ; #x11
-(defconstant eloop 62) ; #x3e
-(defconstant espipe 29) ; #x1d
+(defconstant eloop 90) ; #x5a
 (defconstant epipe 32) ; #x20
+(defconstant espipe 29) ; #x1d
 (defconstant ewouldblock 11) ; #xb
 
+(defconstant sc-nprocessors-onln 15) ; #xf
 ;;; for waitpid() in run-program.lisp
-(defconstant wnohang 1) ; #x1
-(defconstant wuntraced 2) ; #x2
+(defconstant wcontinued 8) ; #x8
+(defconstant wnohang 64) ; #x40
+(defconstant wuntraced 4) ; #x4
 
 ;;; various ioctl(2) flags
-(defconstant tiocgpgrp 1074033795) ; #x40047483
+(defconstant tiocgpgrp 29716) ; #x7414
 
 ;;; signals
-(defconstant sizeof-sigset_t 128) ; #x80
-(defconstant sig_setmask 2) ; #x2
+(defconstant sizeof-sigset_t 16) ; #x10
+(defconstant sig_block 1) ; #x1
 (defconstant sig_unblock 2) ; #x2
+(defconstant sig_setmask 3) ; #x3
 (defconstant sigalrm 14) ; #xe
 (defconstant sigbus 10) ; #xa
-(defconstant sigchld 20) ; #x14
-(defconstant sigcont 19) ; #x13
+(defconstant sigchld 18) ; #x12
+(defconstant sigcont 25) ; #x19
 (defconstant sigemt 7) ; #x7
 (defconstant sigfpe 8) ; #x8
 (defconstant sighup 1) ; #x1
 (defconstant sigill 4) ; #x4
 (defconstant sigint 2) ; #x2
-(defconstant sigio 23) ; #x17
+(defconstant sigio 22) ; #x16
 (defconstant sigkill 9) ; #x9
 (defconstant sigpipe 13) ; #xd
-(defconstant sigprof 27) ; #x1b
+(defconstant sigprof 29) ; #x1d
 (defconstant sigquit 3) ; #x3
 (defconstant sigsegv 11) ; #xb
-(defconstant sigstop 17) ; #x11
+(defconstant sigstop 23) ; #x17
 (defconstant sigsys 12) ; #xc
 (defconstant sigterm 15) ; #xf
 (defconstant sigtrap 5) ; #x5
-(defconstant sigtstp 18) ; #x12
-(defconstant sigttin 21) ; #x15
-(defconstant sigttou 22) ; #x16
-(defconstant sigurg 16) ; #x10
-(defconstant sigusr1 30) ; #x1e
-(defconstant sigusr2 31) ; #x1f
-(defconstant sigvtalrm 26) ; #x1a
-(defconstant sigwinch 28) ; #x1c
-(defconstant sigxcpu 24) ; #x18
-(defconstant sigxfsz 25) ; #x19
+(defconstant sigtstp 24) ; #x18
+(defconstant sigttin 26) ; #x1a
+(defconstant sigttou 27) ; #x1b
+(defconstant sigurg 21) ; #x15
+(defconstant sigusr1 16) ; #x10
+(defconstant sigusr2 17) ; #x11
+(defconstant sigvtalrm 28) ; #x1c
+(defconstant sigwinch 20) ; #x14
+(defconstant sigxcpu 30) ; #x1e
+(defconstant sigxfsz 31) ; #x1f
 (defconstant fpe-intovf 2) ; #x2
 (defconstant fpe-intdiv 1) ; #x1
 (defconstant fpe-fltdiv 3) ; #x3
@@ -132,10 +135,9 @@
 (defconstant fpe-fltinv 7) ; #x7
 (defconstant fpe-fltsub 8) ; #x8
 
-(defconstant clock-process-cputime-id 2) ; #x2
-(defconstant clock-monotonic-coarse 6) ; #x6
-(defconstant clock-thread-cputime-id 3) ; #x3
-
+(defconstant clock-realtime 3) ; #x3
+(defconstant clock-monotonic 4) ; #x4
+(defconstant clock-process-cputime-id 5) ; #x5
 ;;; structures
 (define-alien-type nil
   (struct timeval
@@ -154,4 +156,3 @@
 
 ;;; Our runtime types
 (define-alien-type os-vm-size-t (unsigned 32))
-
diff --git crossbuild-runner/build-all.sh crossbuild-runner/build-all.sh
index b1d6dfa9c..2d38153c4 100755
--- crossbuild-runner/build-all.sh
+++ crossbuild-runner/build-all.sh
@@ -25,11 +25,14 @@ do
   echo '(lambda (features) (union features (list :os-provides-dlopen ' > $ltf
   echo ":$arch" >> $ltf
   # x86 and x86-64 are tested as if #+win32. Unix is otherwise plenty tested.
-  if [ $arch = x86 -o $arch = x86-64 ]; then
-    echo ':win32 :sb-thread :sb-safepoint' >> $ltf
-  else
-    echo ':unix :linux :elf' >> $ltf
-  fi
+  case $arch in
+  x86 | x86-64)
+    echo ':win32 :sb-thread :sb-safepoint' >> $ltf ;;
+  sparc)
+    echo ':unix :sunos :elf' >> $ltf ;;
+  *)
+    echo ':unix :linux :elf' >> $ltf ;;
+  esac
   cat crossbuild-runner/backends/$arch/features >> $ltf
   cat crossbuild-runner/backends/$arch/local-target-features >> $ltf
   echo ')))' >> $ltf
diff --git float-math.lisp-expr float-math.lisp-expr
index a26f8e270..d67239678 100644
--- float-math.lisp-expr
+++ float-math.lisp-expr
@@ -1924,6 +1924,7 @@
 (= (#x4A #.(MAKE-DOUBLE-FLOAT #x40528000 #x0)) T)
 (= (#x4E #.(MAKE-DOUBLE-FLOAT #x40538000 #x0)) T)
 (= (#x51 #.(MAKE-DOUBLE-FLOAT #x40544000 #x0)) T)
+(= (#x5A #.(MAKE-DOUBLE-FLOAT #x40568000 #x0)) T)
 (= (#x60 #.(MAKE-DOUBLE-FLOAT #x40580000 #x0)) T)
 (= (#x70 #.(MAKE-DOUBLE-FLOAT #x405C0000 #x0)) T)
 (= (#x80 #.(MAKE-DOUBLE-FLOAT #x40600000 #x0)) T)
@@ -3974,6 +3975,7 @@
 (COERCE (#x4A DOUBLE-FLOAT) #.(MAKE-DOUBLE-FLOAT #x40528000 #x0))
 (COERCE (#x4E DOUBLE-FLOAT) #.(MAKE-DOUBLE-FLOAT #x40538000 #x0))
 (COERCE (#x51 DOUBLE-FLOAT) #.(MAKE-DOUBLE-FLOAT #x40544000 #x0))
+(COERCE (#x5A DOUBLE-FLOAT) #.(MAKE-DOUBLE-FLOAT #x40568000 #x0))
 (COERCE (#x60 DOUBLE-FLOAT) #.(MAKE-DOUBLE-FLOAT #x40580000 #x0))
 (COERCE (#x70 DOUBLE-FLOAT) #.(MAKE-DOUBLE-FLOAT #x405C0000 #x0))
 (COERCE (#x80 DOUBLE-FLOAT) #.(MAKE-DOUBLE-FLOAT #x40600000 #x0))
diff --git make-host-1.lisp make-host-1.lisp
index 6bcc04708..abcc5a435 100644
--- make-host-1.lisp
+++ make-host-1.lisp
@@ -71,60 +71,9 @@
 
 ;;; Build the unicode database now. It depends on nothing in the cross-compiler
 ;;; (and let's keep it that way). This code is slow to run, so compile it.
-(let ((inputs '("tools-for-build/ucd.lisp"
-                "tools-for-build/UnicodeData.txt"
-                "tools-for-build/NormalizationCorrections.txt"
-                "tools-for-build/CompositionExclusions.txt"
-                "tools-for-build/SpecialCasing.txt"
-                "tools-for-build/EastAsianWidth.txt"
-                "tools-for-build/Scripts.txt"
-                "tools-for-build/LineBreak.txt"
-                "tools-for-build/DerivedAge.txt"
-                "tools-for-build/allkeys.txt"
-                "tools-for-build/emoji-data.txt"
-                "tools-for-build/confusables.txt"
-                "tools-for-build/BidiMirroring.txt"
-                "tools-for-build/Blocks.txt"
-                "tools-for-build/Jamo.txt"
-                "tools-for-build/CaseFolding.txt"
-                "tools-for-build/PropList.txt"
-                "tools-for-build/DerivedNormalizationProps.txt"
-                "tools-for-build/more-ucd-consts.lisp-expr"))
-      (outputs '("output/bidi-mirrors.lisp-expr"
-                 "output/BidiMirroring.txt"
-                 "output/block-names.lisp-expr"
-                 "output/block-ranges.lisp-expr"
-                 "output/Blocks.txt"
-                 "output/case.dat"
-                 "output/CaseFolding.txt"
-                 "output/casepages.dat"
-                 "output/casepages.lisp-expr"
-                 "output/collation.lisp-expr"
-                 "output/comp.lisp-expr"
-                 "output/CompositionExclusions.txt"
-                 "output/confusables.lisp-expr"
-                 "output/decomp.dat"
-                 "output/DerivedAge.txt"
-                 "output/DerivedNormalizationProps.txt"
-                 "output/EastAsianWidth.txt"
-                 "output/emoji-data.txt"
-                 "output/confusables.txt"
-                 "output/foldcases.lisp-expr"
-                 "output/Jamo.txt"
-                 "output/LineBreak.txt"
-                 "output/misc-properties.lisp-expr"
-                 "output/NormalizationCorrections.txt"
-                 "output/numerics.lisp-expr"
-                 "output/other-collation-info.lisp-expr"
-                 "output/PropList.txt"
-                 "output/Scripts.txt"
-                 "output/SpecialCasing.txt"
-                 "output/titlecases.lisp-expr"
-                 "output/ucd1-names.lisp-expr"
-                 "output/ucdhigh.dat"
-                 "output/ucdlow.dat"
-                 "output/ucdmisc.dat"
-                 "output/ucd-names.lisp-expr")))
+(multiple-value-bind (inputs outputs)
+    (with-open-file (stream "src/cold/ucd-filespecs.lisp-expr")
+      (values (read stream) (read stream)))
   (unless (outputs-up-to-date inputs outputs)
     (format t "~&; Building Unicode data~%")
     (let ((*ucd-inputs* (make-hash-table :test 'equal))
diff --git make-target-2-load.lisp make-target-2-load.lisp
index 885ebda74..0a10c6f67 100644
--- make-target-2-load.lisp
+++ make-target-2-load.lisp
@@ -6,10 +6,6 @@
 (defvar *compile-files-p* nil)
 (load (merge-pathnames "src/cold/warm.lisp" *load-pathname*))
 
-(with-open-file (stream "output/asm-routines.txt" :direction :output
-                        :if-does-not-exist :create :if-exists :supersede)
-  (sb-c:dis sb-fasl:*assembler-routines* stream))
-
 ;; sb-xref-for-internals is actively harmful to tree-shaking.
 ;; Remove some symbols to make the hide-packages test pass.
 #+sb-xref-for-internals
@@ -76,7 +72,7 @@
            ;; I would argue that this should not be exposed,
            ;; but I would also anticipate blowback from removing it.
            :CHENEYGC :GENCGC ; GC: pick one and only one
-           :ARENA-ALLOCATOR
+           :ARENA-ALLOCATOR :ALLOCATION-SIZE-HISTOGRAM
            ;; Can't use s-l-a-d :compression safely without it
            :SB-CORE-COMPRESSION
            ;; Features that are also in *FEATURES-POTENTIALLY-AFFECTING-FASL-FORMAT*
diff --git src/assembly/arm64/support.lisp src/assembly/arm64/support.lisp
index bea983e5a..ca08ef1d2 100644
--- src/assembly/arm64/support.lisp
+++ src/assembly/arm64/support.lisp
@@ -11,6 +11,48 @@
 
 (in-package "SB-VM")
 
+(defun invoke-asm-routine (name reg &key tail)
+  (cond ((or (not (boundp '*component-being-compiled*))
+             (sb-c::code-immobile-p *component-being-compiled*))
+         (if tail
+             (inst b (make-fixup name :assembly-routine))
+             (inst bl (make-fixup name :assembly-routine))))
+        (t
+         (load-inline-constant reg `(:fixup ,name :assembly-routine))
+         (if tail
+             (inst br reg)
+             (inst blr reg)))))
+
+(defun load-asm-routine (reg name)
+  (if (or (not (boundp '*component-being-compiled*))
+          (sb-c::code-immobile-p *component-being-compiled*))
+      (inst adr reg (make-fixup name :assembly-routine))
+      (load-inline-constant reg `(:fixup ,name :assembly-routine))))
+
+(defun invoke-foreign-routine (name reg &key tail)
+  (cond ((or (not (boundp '*component-being-compiled*))
+             (sb-c::code-immobile-p *component-being-compiled*))
+         (if tail
+             (inst b (make-fixup name :foreign))
+             (inst bl (make-fixup name :foreign))))
+        (t
+         (load-inline-constant reg `(:fixup ,name :foreign))
+         (if tail
+             (inst br reg)
+             (inst blr reg)))))
+
+(defun load-foreign-symbol (reg name &key dataref)
+  (let ((kind (if dataref :foreign-dataref :foreign)))
+    (if (or (not (boundp '*component-being-compiled*))
+            (sb-c::code-immobile-p *component-being-compiled*))
+        (if dataref
+            (inst ldr reg (make-fixup name kind))
+            (inst adr reg (make-fixup name kind)))
+        (progn
+          (load-inline-constant reg `(:fixup ,name ,kind))
+          (when dataref
+            (loadw reg reg))))))
+
 (defun generate-call-sequence (name style vop options)
   (declare (ignore options vop))
   (ecase style
@@ -20,10 +62,8 @@
         `((progn
             ,lr
             ,@(if (eq style :none)
-                  `((load-inline-constant tmp-tn '(:fixup ,name :assembly-routine))
-                    (inst br tmp-tn))
-                  `((load-inline-constant ,lr '(:fixup ,name :assembly-routine))
-                    (inst blr ,lr)))))
+                  `((invoke-asm-routine ',name tmp-tn :tail t))
+                  `((invoke-asm-routine ',name ,lr)))))
         `((:temporary (:sc non-descriptor-reg :from (:eval 0) :to (:eval 1) :offset lr-offset)
                       ,lr)))))))
 
diff --git src/assembly/arm64/tramps.lisp src/assembly/arm64/tramps.lisp
index ec7b442a7..d5322d298 100644
--- src/assembly/arm64/tramps.lisp
+++ src/assembly/arm64/tramps.lisp
@@ -84,8 +84,7 @@
         (map-pairs stp csp-tn -80 lisp-registers)
         (map-pairs stp nsp-tn 0 float-registers :pre-index -512 :delta 32)
 
-        (load-inline-constant nl2 '(:fixup ,c-name :foreign))
-        (inst blr nl2)
+        (invoke-foreign-routine ,c-name nl2)
 
         (map-pairs ldp nsp-tn 480 float-registers :post-index 512 :delta -32)
         (map-pairs ldp csp-tn -16 lisp-registers :delta -16)
diff --git src/assembly/x86/alloc.lisp src/assembly/x86/alloc.lisp
index 8427f7158..24a54a0ff 100644
--- src/assembly/x86/alloc.lisp
+++ src/assembly/x86/alloc.lisp
@@ -57,7 +57,8 @@
                                            (make-ea :dword :disp (ash thread-mixed-tlab-slot 2))
                                            :fs)
                          #-sb-thread (inst sub ,reg
-                                           (make-ea :dword :disp mixed-region))))))
+                                           (make-ea :dword :disp
+                                                    (+ static-space-start mixed-region-offset)))))))
              (case reg
                ;; Now that we're using lisp asm code instead of a .S file
                ;; this could be done more intelligently - the macro can decide
diff --git src/code/aprof.lisp src/code/aprof.lisp
index f70071c85..964c25918 100644
--- src/code/aprof.lisp
+++ src/code/aprof.lisp
@@ -235,7 +235,7 @@
       `((fixed+header
          (add ?end ?nbytes)
          (cmp :qword ?end :tlab-limit)
-         (jmp :nbe ?_)
+         (jmp :a ?_)
          (mov :qword :tlab-freeptr ?end)
          (:or (add ?end ?bias) (dec ?end))
          (mov ?_ (ea ?_ ?end) ?header))
@@ -243,7 +243,7 @@
         (var-array
          (add ?end ?nbytes)
          (cmp :qword ?end :tlab-limit)
-         (jmp :nbe ?_)
+         (jmp :a ?_)
          (mov :qword :tlab-freeptr ?end)
          (sub ?end ?nbytes)
          (mov ?_ (ea ?_ ?end) ?header)
@@ -254,7 +254,7 @@
                ;; and free-ptr points to the end of the putative data block.
                (xadd ?free ?size)
                (cmp :qword ?free :tlab-limit)
-               (jmp :nbe ?_)
+               (jmp :a ?_)
                (mov :qword :tlab-freeptr ?free)
                ;; Could have one or two stores prior to ORing in a lowtag.
                (:optional (mov ?_ (ea 0 ?size) ?header))
@@ -267,7 +267,7 @@
                   (lea :qword ?end (ea 0 ?nbytes-var ?free))
                   (add ?end ?free)) ; ?end originally holds the size in bytes
              (cmp :qword ?end :tlab-limit)
-             (jmp :nbe ?_)
+             (jmp :a ?_)
              (mov :qword :tlab-freeptr ?end)
              (mov ?_ (ea 0 ?free) ?header)
              (:optional (mov ?_ (ea ?_ ?free) ?vector-len))
@@ -278,7 +278,7 @@
         ;; not the first cons.
         (list (lea :qword ?end (ea 0 ?nbytes ?free))
               (cmp :qword ?end :tlab-limit)
-              (jmp :nbe ?_)
+              (jmp :a ?_)
               (mov :qword :tlab-freeptr ?end)
               (lea :qword ?free (ea ,(- sb-vm:list-pointer-lowtag
                                         (* sb-vm:cons-size sb-vm:n-word-bytes))
@@ -287,7 +287,7 @@
 
         (acons (lea :qword ?end (ea 32 ?free))
                (cmp :qword ?end :tlab-limit)
-               (jmp :nbe ?_)
+               (jmp :a ?_)
                (mov :qword :tlab-freeptr ?end)
                (:repeat (mov . ignore))
                (lea :qword ?result (ea #.(+ 16 sb-vm:list-pointer-lowtag) ?free)))
@@ -297,7 +297,7 @@
                              (lea :qword ?end (ea 0 ?nbytes-var ?free))
                              (add ?end ?free))
                         (cmp :qword ?end :tlab-limit)
-                        (jmp :nbe ?_)
+                        (jmp :a ?_)
                         (mov :qword :tlab-freeptr ?end)
                         (:repeat (:or (mov . ignore) (lea . ignore)))
                         (:or (or ?free ?lowtag)
diff --git src/code/array.lisp src/code/array.lisp
index 709486bc3..61a7e524d 100644
--- src/code/array.lisp
+++ src/code/array.lisp
@@ -396,6 +396,15 @@
           (recurse (%array-data x))
           (truly-the (integer 128 255) result))))))
 
+(declaim (ftype (sfunction (array) (values (integer 128 255) (unsigned-byte 8)))
+                array-underlying-widetag-and-shift))
+(defun array-underlying-widetag-and-shift (array)
+  (declare (explicit-check))
+  (let ((widetag (array-underlying-widetag array)))
+    (values widetag
+            (truly-the (unsigned-byte 8)
+                       (aref %%simple-array-n-bits-shifts%% widetag)))))
+
 ;; Complain in various ways about wrong MAKE-ARRAY and ADJUST-ARRAY arguments,
 ;; returning the two initialization arguments needed for DATA-VECTOR-FROM-INITS.
 ;; This is an unhygienic macro which would be a MACROLET other than for
@@ -452,10 +461,9 @@
 (defun %save-displaced-new-array-backpointer (array data)
   (flet ((purge (pointers)
            (remove-if-not #'weak-pointer-value pointers)))
-    (when (array-header-p data)
-      (setf (%array-displaced-from data)
-            (cons (make-weak-pointer array)
-                  (purge (%array-displaced-from data)))))))
+    (setf (%array-displaced-from data)
+          (cons (make-weak-pointer array)
+                (purge (%array-displaced-from data))))))
 
 (defmacro populate-dimensions (header list-or-index rank)
   `(if (listp ,list-or-index)
@@ -565,7 +573,8 @@
              (cond (displaced-to
                     (setf (%array-displacement array) (or displaced-index-offset 0))
                     (setf (%array-displaced-p array) t)
-                    (%save-displaced-new-array-backpointer array data))
+                    (when (adjustable-array-p data)
+                      (%save-displaced-new-array-backpointer array data)))
                    (t
                     (setf (%array-displaced-p array) nil)))
              (populate-dimensions array dimensions array-rank)
@@ -693,25 +702,30 @@ of specialized arrays is supported."
                     (make-array ,(1+ widetag-mask)))
                 (declaim (type (simple-array function (,(1+ widetag-mask)))
                                ,table-name))
-                (defmacro ,name (array-var)
-                  `(the function
-                     ;; Assigning TAG to 0 initially produces slightly better
-                     ;; code than would be generated by the more natural expression
-                     ;;   (let ((tag (if (%other-ptr ...) (widetag ...) 0)))
-                     ;; but either way is suboptimal. As expressed, if the array-var
-                     ;; is known to satisfy %other-pointer-p, then it performs a
-                     ;; move-immediate-to-register which is clobbered right away
-                     ;; by a zero-extending load. A peephole pass could eliminate
-                     ;; the first move as effectless.  If expressed the other way,
-                     ;; it would produce a jump around a jump because the compiler
-                     ;; is unwilling to *unconditionally* assign 0 into a register
-                     ;; to begin with. It actually wants to guard an immediate load
-                     ;; when it doesn't need to, as if both consequents of the IF
-                     ;; have side-effects that should not happen.
-                     (let ((tag 0))
-                       (when (%other-pointer-p ,array-var)
-                         (setf tag (%other-pointer-widetag ,array-var)))
-                       (svref ,',table-name tag)))))))
+                (defmacro ,name (array-var &optional vector-check)
+                  (if vector-check
+                      `(the function
+                            (svref ,',table-name (%other-pointer-widetag
+                                                  (locally (declare (optimize (safety 1)))
+                                                    (the vector ,array-var)))))
+                      `(the function
+                            ;; Assigning TAG to 0 initially produces slightly better
+                            ;; code than would be generated by the more natural expression
+                            ;;   (let ((tag (if (%other-ptr ...) (widetag ...) 0)))
+                            ;; but either way is suboptimal. As expressed, if the array-var
+                            ;; is known to satisfy %other-pointer-p, then it performs a
+                            ;; move-immediate-to-register which is clobbered right away
+                            ;; by a zero-extending load. A peephole pass could eliminate
+                            ;; the first move as effectless.  If expressed the other way,
+                            ;; it would produce a jump around a jump because the compiler
+                            ;; is unwilling to *unconditionally* assign 0 into a register
+                            ;; to begin with. It actually wants to guard an immediate load
+                            ;; when it doesn't need to, as if both consequents of the IF
+                            ;; have side-effects that should not happen.
+                            (let ((tag 0))
+                              (when (%other-pointer-p ,array-var)
+                                (setf tag (%other-pointer-widetag ,array-var)))
+                              (svref ,',table-name tag))))))))
   (def !find-data-vector-setter %%data-vector-setters%%)
   (def !find-data-vector-setter/check-bounds %%data-vector-setters/check-bounds%%)
   ;; Used by DO-VECTOR-DATA -- which in turn appears in DOSEQUENCE expansion,
@@ -739,8 +753,8 @@ of specialized arrays is supported."
                ,@decls
                (tagbody ,@forms))))))))
 
-(macrolet ((%ref (accessor-getter extra-params)
-             `(sb-c::%funcall-no-nargs (,accessor-getter array) array index ,@extra-params))
+(macrolet ((%ref (accessor-getter extra-params &optional vector-check)
+             `(sb-c::%funcall-no-nargs (,accessor-getter array ,vector-check) array index ,@extra-params))
            (define (accessor-name slow-accessor-name accessor-getter
                                   extra-params check-bounds)
              `(progn
@@ -755,6 +769,10 @@ of specialized arrays is supported."
                                      ;; dispatch.
                                      (safety 0)))
                   (%ref ,accessor-getter ,extra-params))
+                (defun ,(symbolicate 'vector- accessor-name) (array index ,@extra-params)
+                  (declare (explicit-check)
+                           (optimize speed (safety 0)))
+                  (%ref ,accessor-getter ,extra-params t))
                 (defun ,slow-accessor-name (array index ,@extra-params)
                   (declare (optimize speed (safety 0))
                            (array array))
@@ -1043,6 +1061,7 @@ of specialized arrays is supported."
 
 (defun array-element-type (array)
   "Return the type of the elements of the array"
+  (declare (explicit-check array))
   (truly-the (or list symbol)
              (widetag->element-type (array-underlying-widetag array))))
 
diff --git src/code/bignum-random.lisp src/code/bignum-random.lisp
index a505adb08..1bb2f8734 100644
--- src/code/bignum-random.lisp
+++ src/code/bignum-random.lisp
@@ -56,9 +56,9 @@
           (setf (%bignum-ref bignum n-random-digits) random-chunk)
           (progn
             (setf (%bignum-ref bignum n-random-digits)
-                  (%logior (random-bignum-partial-digit n-random-bits
-                                                        state)
-                           (%ashl random-chunk n-random-bits)))
+                  (logior (random-bignum-partial-digit n-random-bits
+                                                       state)
+                          (%ashl random-chunk n-random-bits)))
             (let ((shift (- digit-size n-random-bits)))
               (when (< shift n-random-chunk-bits)
                 (setf (%bignum-ref bignum (1+ n-random-digits))
diff --git src/code/bignum.lisp src/code/bignum.lisp
index 8c97813b6..c21462482 100644
--- src/code/bignum.lisp
+++ src/code/bignum.lisp
@@ -27,8 +27,8 @@
 ;;;       bignum-element-type bignum-index %allocate-bignum
 ;;;       %bignum-length %bignum-set-length %bignum-ref %bignum-set
 ;;;       %digit-0-or-plusp %add-with-carry %subtract-with-borrow
-;;;       %multiply-and-add %multiply %lognot %logand %logior %logxor
-;;;       %fixnum-to-digit %bigfloor %fixnum-digit-with-correct-sign %ashl
+;;;       %multiply-and-add %multiply
+;;;       %bigfloor %fixnum-digit-with-correct-sign %ashl
 ;;;       %ashr %digit-logical-shift-right))
 
 ;;; The following interfaces will either be assembler routines or code
@@ -57,12 +57,6 @@
 ;;;       %LOGNOT
 ;;;    Shifting (in place)
 ;;;       %NORMALIZE-BIGNUM-BUFFER
-;;;    Relational operators:
-;;;       %LOGAND
-;;;       %LOGIOR
-;;;       %LOGXOR
-;;;    LDB
-;;;       %FIXNUM-TO-DIGIT
 ;;;    TRUNCATE
 ;;;       %BIGFLOOR
 ;;;
@@ -227,26 +221,6 @@
   (declare (type bignum bignum))
   (%bignum-0-or-plusp bignum (%bignum-length bignum)))
 
-;;; Each of these does the digit-size unsigned op.
-(declaim (inline %logand %logior %logxor))
-(defun %logand (a b)
-  (declare (type bignum-element-type a b))
-  (logand a b))
-(defun %logior (a b)
-  (declare (type bignum-element-type a b))
-  (logior a b))
-(defun %logxor (a b)
-  (declare (type bignum-element-type a b))
-  (logxor a b))
-
-;;; This takes a fixnum and sets it up as an unsigned digit-size
-;;; quantity.
-;;; The stub function is needed for constant-folding, or where vops don't exist
-(defun %fixnum-to-digit (x)
-  (declare (fixnum x))
-  #+(or arm arm64) (logand x (1- (ash 1 digit-size))) ; missing the vops
-  #-(or arm arm64) (%fixnum-to-digit x))
-
 ;;; This returns 0 or "-1" depending on whether the bignum is positive. This
 ;;; is suitable for infinite sign extension to complete additions,
 ;;; subtractions, negations, etc. This cannot return a -1 represented as
@@ -261,6 +235,9 @@
 (defun (setf %bignum-ref) (val bignum index)
   (%bignum-set bignum index val) ; valueless
   val)
+
+(defmacro %lognot (x)
+  `(ldb (byte digit-size 0) (lognot ,x)))
 
 (declaim (optimize (speed 3) (safety 0)))
 
@@ -531,7 +508,7 @@
       (negate-bignum-in-place result))
     (%normalize-bignum result (1+ bignum-len))))
 
-(sb-c::unless-vop-existsp (:translate sb-c::fixnum*)
+(sb-c::unless-vop-existsp (:named sb-vm::*/signed=>integer)
   (defun multiply-fixnums (a b)
     (declare (fixnum a b))
     (declare (muffle-conditions compiler-note)) ; returns lispobj, so what.
@@ -622,17 +599,15 @@
 ;;; target compiler, it can deduce the return type fine, but without
 ;;; it, we pay a heavy price in BIGNUM-GCD when compiled by the
 ;;; cross-compiler. -- CSR, 2004-07-19
-(declaim (ftype (sfunction (bignum bignum-length bignum bignum-length)
+(declaim (ftype (sfunction (bignum bignum)
                            (and unsigned-byte fixnum))
                 bignum-factors-of-two))
-(defun bignum-factors-of-two (a len-a b len-b)
-  (declare (type bignum-length len-a len-b) (type bignum a b))
-  (do ((i 0 (1+ i))
-       (end (min len-a len-b)))
-      ((= i end) (error "Unexpected zero bignums?"))
-    (declare (type bignum-index i)
-             (type bignum-length end))
-    (let ((or-digits (%logior (%bignum-ref a i) (%bignum-ref b i))))
+(defun bignum-factors-of-two (a b)
+  (declare (type bignum a b))
+  (do ((i 0 (1+ i)))
+      (())
+    (declare (type bignum-index i))
+    (let ((or-digits (logior (%bignum-ref a i) (%bignum-ref b i))))
       (unless (zerop or-digits)
         (return (do ((j 0 (1+ j))
                      (or-digits or-digits (%ashr or-digits 1)))
@@ -765,12 +740,13 @@
 (declaim (inline make-small-bignum))
 (defun make-small-bignum (fixnum)
   (let ((res (%allocate-bignum 1)))
-    (setf (%bignum-ref res 0) (%fixnum-to-digit fixnum))
+    (setf (%bignum-ref res 0)
+          (ldb (byte digit-size 0) (truly-the fixnum fixnum)))
     res))
 
 ;; When the larger number is less than this many bignum digits long, revert
 ;; to old algorithm.
-(define-load-time-global *accelerated-gcd-cutoff* 3)
+(defconstant accelerated-gcd-cutoff 3)
 
 ;;; Alternate between k-ary reduction with the help of
 ;;; REDUCED-RATIO-MOD and digit modulus reduction via DMOD. Once the
@@ -787,18 +763,15 @@
          (v1 (if (bignum-plus-p v0)
                  v0
                  (negate-bignum v0 nil))))
-    (if (zerop v1)
-        (return-from bignum-gcd u1))
-    (when (> u1 v1)
+    (when (plusp (bignum-compare u1 v1))
       (rotatef u1 v1))
-    (let ((n (mod v1 u1)))
+    (let ((n (rem v1 u1)))
+      (when (eql n 0)
+        (return-from bignum-gcd (%normalize-bignum u1
+                                                   (%bignum-length u1))))
       (setf v1 (if (fixnump n)
                    (make-small-bignum n)
                    n)))
-    (if (and (= 1 (%bignum-length v1))
-             (zerop (%bignum-ref v1 0)))
-        (return-from bignum-gcd (%normalize-bignum u1
-                                                   (%bignum-length u1))))
     (let* ((buffer-len (+ 2 (%bignum-length u1)))
            (u (%allocate-bignum buffer-len))
            (u-len (%bignum-length u1))
@@ -809,8 +782,7 @@
            (tmp2 (%allocate-bignum buffer-len))
            (tmp2-len 0)
            (factors-of-two
-            (bignum-factors-of-two u1 (%bignum-length u1)
-                                   v1 (%bignum-length v1))))
+            (bignum-factors-of-two u1 v1)))
       (declare (type (or null bignum-length)
                      buffer-len u-len v-len tmp1-len tmp2-len))
       (bignum-replace u u1)
@@ -823,7 +795,7 @@
             (make-gcd-bignum-odd v
                                  (bignum-buffer-ashift-right v v-len
                                                              factors-of-two)))
-      (loop until (or (< u-len *accelerated-gcd-cutoff*)
+      (loop until (or (< u-len accelerated-gcd-cutoff)
                       (not v-len)
                       (zerop v-len)
                       (and (= 1 v-len)
@@ -907,8 +879,7 @@
                           (b-buffer len-b b)
                           (res-buffer (max len-a len-b)))
       (let* ((factors-of-two
-              (bignum-factors-of-two a-buffer len-a
-                                     b-buffer len-b))
+              (bignum-factors-of-two a-buffer b-buffer))
              (len-a (make-gcd-bignum-odd
                      a-buffer
                      (bignum-buffer-ashift-right a-buffer len-a
@@ -1079,7 +1050,7 @@
          ,termination
        (declare (type bignum-index i j))
        (setf (%bignum-ref ,(if result result source) j)
-             (%logior (%digit-logical-shift-right (%bignum-ref ,source i)
+             (logior (%digit-logical-shift-right (%bignum-ref ,source i)
                                                   ,start-pos)
                       (%ashl (%bignum-ref ,source (1+ i))
                              high-bits-in-first-digit))))))
@@ -1215,7 +1186,7 @@
              (%normalize-bignum res res-len)))
       (declare (type bignum-index i j))
       (setf (%bignum-ref res j)
-            (%logior (%digit-logical-shift-right (%bignum-ref bignum i)
+            (logior (%digit-logical-shift-right (%bignum-ref bignum i)
                                                  remaining-bits)
                      (%ashl (%bignum-ref bignum (1+ i)) n-bits))))))
 
@@ -1472,7 +1443,7 @@
   (dotimes (i len-a)
     (declare (type bignum-index i))
     (setf (%bignum-ref res i)
-          (%logand (%bignum-ref a i) (%bignum-ref b i))))
+          (logand (%bignum-ref a i) (%bignum-ref b i))))
   (%normalize-bignum res len-a))
 
 ;;; This takes a shorter bignum, a and len-a, that is negative. Because this
@@ -1484,7 +1455,7 @@
   (dotimes (i len-a)
     (declare (type bignum-index i))
     (setf (%bignum-ref res i)
-          (%logand (%bignum-ref a i) (%bignum-ref b i))))
+          (logand (%bignum-ref a i) (%bignum-ref b i))))
   (do ((i len-a (1+ i)))
       ((= i len-b))
     (declare (type bignum-index i))
@@ -1521,7 +1492,7 @@
   (dotimes (i len-a)
     (declare (type bignum-index i))
     (setf (%bignum-ref res i)
-          (%logior (%bignum-ref a i) (%bignum-ref b i))))
+          (logior (%bignum-ref a i) (%bignum-ref b i))))
   (do ((i len-a (1+ i)))
       ((= i len-b))
     (declare (type bignum-index i))
@@ -1537,7 +1508,7 @@
   (dotimes (i len-a)
     (declare (type bignum-index i))
     (setf (%bignum-ref res i)
-          (%logior (%bignum-ref a i) (%bignum-ref b i))))
+          (logior (%bignum-ref a i) (%bignum-ref b i))))
   (do ((i len-a (1+ i))
        (sign (%sign-digit a len-a)))
       ((= i len-b))
@@ -1564,12 +1535,12 @@
   (dotimes (i len-a)
     (declare (type bignum-index i))
     (setf (%bignum-ref res i)
-          (%logxor (%bignum-ref a i) (%bignum-ref b i))))
+          (logxor (%bignum-ref a i) (%bignum-ref b i))))
   (do ((i len-a (1+ i))
        (sign (%sign-digit a len-a)))
       ((= i len-b))
     (declare (type bignum-index i))
-    (setf (%bignum-ref res i) (%logxor sign (%bignum-ref b i))))
+    (setf (%bignum-ref res i) (logxor sign (%bignum-ref b i))))
   (%normalize-bignum res len-b))
 
 ;;;; There used to be a bunch of code to implement "efficient" versions of LDB
diff --git src/code/debug.lisp src/code/debug.lisp
index 567a7ddb3..4066b0d47 100644
--- src/code/debug.lisp
+++ src/code/debug.lisp
@@ -569,7 +569,7 @@ information."
                      escaped)))))
 
 (defun frame-args-as-list (frame limit)
-  (declare (unsigned-byte limit))
+  (declare (type frame frame) (type (and unsigned-byte fixnum) limit))
   ;;; All args are available if the function has not proceeded beyond its external
   ;;; entry point, so every imcoming value is in its argument-passing location.
   (when (sb-di::all-args-available-p frame)
diff --git src/code/deftype.lisp src/code/deftype.lisp
new file mode 100644
index 000000000..b3fe09d88
--- /dev/null
+++ src/code/deftype.lisp
@@ -0,0 +1,100 @@
+;;;; This software is part of the SBCL system. See the README file for
+;;;; more information.
+;;;;
+;;;; This software is derived from the CMU CL system, which was
+;;;; written at Carnegie Mellon University and released into the
+;;;; public domain. The software is in the public domain and is
+;;;; provided with absolutely no warranty. See the COPYING and CREDITS
+;;;; files for more information.
+
+(in-package "SB-IMPL")
+
+(defun constant-type-expander (name expansion)
+  (declare (optimize safety))
+  ;; Dummy implementation of SET-CLOSURE-NAME for the host.
+  (flet (#+sb-xc-host (set-closure-name (f junk name) (declare (ignore junk name)) f))
+    (set-closure-name
+     (lambda (whole)
+       ;; NB: It does not in general work to set the lambda-list of a closure,
+       ;; but all constant-type-expanders have NIL as the lambda-list
+       ;; because if they didn't, they wouldn't be constant.
+       (declare (sb-c::lambda-list ()))
+       (if (cdr whole)
+           (error 'sb-kernel::arg-count-error
+                  :kind 'deftype :name (car whole) :args (cdr whole)
+                  :lambda-list '() :minimum 0 :maximum 0)
+           expansion))
+     t
+     `(type-expander ,name))))
+
+(defmacro sb-xc:deftype (name lambda-list &body body &environment env)
+  "Define a new type, with syntax like DEFMACRO."
+  (declare (ignore env))
+  (check-designator name 'deftype)
+  (multiple-value-bind (expander-form doc source-location-form)
+      (multiple-value-bind (forms decls doc) (parse-body body t)
+        (acond ((and (not lambda-list) (not decls)
+                    (let ((expr `(progn ,@forms)))
+                      ;; While CONSTANTP works early, %MACROEXPAND does not,
+                      ;; so we can't pass ENV because it'd try to macroexpand.
+                      (if (constantp expr) expr)))
+                #-sb-xc-host
+                (check-deprecated-type (constant-form-value it))
+                (values `(constant-type-expander ',name ,it) doc
+                        '(sb-c:source-location)))
+               (t
+                ;; FIXME: it seems non-ANSI-compliant to pretend every lexenv
+                ;; is nil. See also lp#309140.
+                ;; Source-location and docstring are associated with the lambda
+                ;; so we don't store them separately.
+                (make-macro-lambda `(type-expander ,name)
+                                   lambda-list body 'deftype name
+                                   :doc-string-allowed :external
+                                   :environment :ignore))))
+    ;; Maybe kill docstring, but only under the cross-compiler.
+    #+(and (not sb-doc) sb-xc-host) (setq doc nil)
+    `(progn
+       (eval-when (:compile-toplevel :load-toplevel :execute)
+         (%deftype ',name ,expander-form ,source-location-form
+                   ,@(when doc `(,doc)))))))
+
+(defun %deftype (name expander source-location &optional doc)
+  (declare (ignorable doc))
+  (with-single-package-locked-error
+      (:symbol name "defining ~A as a type specifier"))
+  (ecase (info :type :kind name)
+    (:primitive
+     ;; Detecting illegal redefinition in the cross-compiler
+     ;; adds unnecessary complexity, so don't bother.
+     #-sb-xc-host
+     (when *type-system-initialized*
+       (error "illegal to redefine standard type: ~S" name)))
+    (:instance
+     (warn "The class ~S is being redefined to be a DEFTYPE." name)
+     (undeclare-structure (find-classoid name) t)
+     ;; FIXME: shouldn't this happen only at eval-time?
+     (setf (classoid-cell-classoid (find-classoid-cell name :create t)) nil)
+     (clear-info :type :compiler-layout name)
+     (setf (info :type :kind name) :defined))
+    (:defined
+     ;; Note: It would be nice to warn here when a type is being
+     ;; incompatibly redefined, but it's hard to tell, since type
+     ;; expanders are often function objects which can't easily be
+     ;; compared for equivalence. And just warning on redefinition
+     ;; isn't good, since DEFTYPE necessarily does its thing once at
+     ;; compile time and again at load time, so that it's very common
+     ;; and normal for types to be defined twice. So since there
+     ;; doesn't seem to be anything simple and obvious to do, and
+     ;; since mistakenly redefining a type isn't a common error
+     ;; anyway, we just don't worry about trying to warn about it.
+     )
+    ((nil :forthcoming-defclass-type)
+     (setf (info :type :kind name) :defined)))
+  (setf (info :type :expander name) expander)
+  (when source-location
+    (setf (info :type :source-location name) source-location))
+  #-sb-xc-host
+  (when doc
+    (setf (documentation name 'type) doc))
+  (sb-c::%note-type-defined name)
+  name)
diff --git src/code/final.lisp src/code/final.lisp
index 525cfd409..aeac4674b 100644
--- src/code/final.lisp
+++ src/code/final.lisp
@@ -22,9 +22,7 @@
 ;;; A mutex is used during rehash due to key movement, but NOT if rehashing
 ;;; due to table growth. (If growing organically, hashes are valid, so you'll
 ;;; find what you're looking for if it's there. Invalid hashes are trickier)
-(define-load-time-global *finalizer-lock*
-    ;; disambiguate this lock name from the finalizer _thread's_ lock name
-    (sb-thread:make-mutex :name "**FINALIZER-STORE**"))
+(define-load-time-global *finalizer-lock* (sb-thread:make-mutex :name "finalizer"))
 (declaim (type sb-thread:mutex *finalizer-lock*))
 
 ;;; List of nodes removed from the split-ordered list due to key movement.
diff --git src/code/interr.lisp src/code/interr.lisp
index e9d423b43..71ad75143 100644
--- src/code/interr.lisp
+++ src/code/interr.lisp
@@ -478,7 +478,7 @@
       (multiple-value-bind (of cf) (sb-vm::context-overflow-carry-flags *current-internal-error-context*)
         (err x of cf)))
 
-   #+x86-64
+    #+x86-64
     (deferr sub-overflow-error (x)
       (multiple-value-bind (of cf) (sb-vm::context-overflow-carry-flags *current-internal-error-context*)
         (err x of (not cf)))))
@@ -519,6 +519,20 @@
                     'fixnum)))
       (if (numberp x)
           (object-not-type-error (* x y) type nil)
+          (object-not-type-error x 'number nil))))
+
+  (deferr ash-overflow2-error (x y)
+    (let ((type (or (sb-di:error-context)
+                    'fixnum)))
+      (if (numberp x)
+          (object-not-type-error (ash x y) type nil)
+          (object-not-type-error x 'number nil))))
+
+  (deferr negate-overflow-error (x)
+    (let ((type (or (sb-di:error-context)
+                    'fixnum)))
+      (if (numberp x)
+          (object-not-type-error (- x) type nil)
           (object-not-type-error x 'number nil)))))
 
 ;;;; INTERNAL-ERROR signal handler
diff --git src/code/misc-aliens.lisp src/code/misc-aliens.lisp
index ede390faf..0ad87a2fb 100644
--- src/code/misc-aliens.lisp
+++ src/code/misc-aliens.lisp
@@ -20,6 +20,8 @@
                         sb-vm:*read-only-space-free-pointer*)
     system-area-pointer)
 
+#+relocatable-static-space
+(define-alien-variable ("STATIC_SPACE_START" sb-vm:static-space-start) sb-kernel::os-vm-size-t)
 ;;; STATIC-SPACE-START is a constant from genesis
 (define-alien-variable ("static_space_free_pointer" sb-vm:*static-space-free-pointer*)
   system-area-pointer)
diff --git src/code/numbers.lisp src/code/numbers.lisp
index 05feaf72e..3278e60b8 100644
--- src/code/numbers.lisp
+++ src/code/numbers.lisp
@@ -1159,15 +1159,17 @@ and the number of 0 bits if INTEGER is negative."
   (deposit-field newbyte bytespec integer))
 
 (defun %ldb (size posn integer)
-  (declare (type bit-index size posn) (explicit-check))
   ;; The naive algorithm is horrible in the general case.
   ;; Consider (LDB (BYTE 1 2) (SOME-GIANT-BIGNUM)) which has to shift the
   ;; input rightward 2 bits, consing a new bignum just to read 1 bit.
-  (if (and (<= 0 size sb-vm:n-positive-fixnum-bits)
-           (typep integer 'bignum))
-      (sb-bignum::ldb-bignum=>fixnum size posn integer)
-      (logand (ash integer (- posn))
-              (1- (ash 1 size)))))
+  (cond ((<= 0 size sb-vm:n-positive-fixnum-bits)
+         (if (fixnump integer)
+             (logand (ash integer (- posn))
+                     (1- (ash 1 size)))
+             (sb-bignum::ldb-bignum=>fixnum size posn integer)))
+        (t
+         (logand (ash integer (- posn))
+                 (1- (ash 1 size))))))
 
 (defun %mask-field (size posn integer)
   (declare (type bit-index size posn) (explicit-check))
diff --git src/code/room.lisp src/code/room.lisp
index ec81506c6..57b0f0b2a 100644
--- src/code/room.lisp
+++ src/code/room.lisp
@@ -294,7 +294,7 @@ We could try a few things to mitigate this:
              ;; Static space starts with NIL, which requires special
              ;; handling, as the header and alignment are slightly off.
              (funcall fun nil symbol-widetag (* sizeof-nil-in-words n-word-bytes))
-             (let ((start (%make-lisp-obj static-space-objects-start))
+             (let ((start (%make-lisp-obj (+ static-space-start static-space-objects-offset)))
                    (end (%make-lisp-obj (sap-int *static-space-free-pointer*))))
                (map-objects-in-range fun start end)))
             ((:read-only #-gencgc :dynamic)
@@ -685,7 +685,7 @@ We could try a few things to mitigate this:
            (type (or index null) type larger smaller count))
   (multiple-value-bind (start end) (%space-bounds space)
     (when (eq space :static)
-      (setq start (%make-lisp-obj static-space-objects-start)))
+      (setq start (%make-lisp-obj (+ static-space-start static-space-objects-offset))))
     (let* ((space-start (ash start n-fixnum-tag-bits))
            (space-end (ash end n-fixnum-tag-bits))
            (space-size (- space-end space-start))
@@ -1245,6 +1245,7 @@ We could try a few things to mitigate this:
      :dynamic)))
 ;;; Because pseudo-static objects can not move nor be freed,
 ;;; this is a valid test that genesis separated code and data.
+#+x86-64 ; FIXME: flaky on other platforms.
 (!ensure-genesis-code/data-separation)
 
 ;;; Make sure that every KEY-INFO is in the hashset.
diff --git src/code/target-thread.lisp src/code/target-thread.lisp
index 5bb490fdd..d650c6c5b 100644
--- src/code/target-thread.lisp
+++ src/code/target-thread.lisp
@@ -278,21 +278,23 @@ an error in that case."
          ;; indicating that you observed a value of %OWNER which no longer exists.
          (t :thread-dead)))
 
-(defun list-all-threads ()
-  "Return a list of the live threads. Note that the return value is
-potentially stale even before the function returns, as new threads may be
-created and old ones may exit at any time."
+(defun %list-all-threads ()
   ;; No lock needed, just an atomic read, since tree mutations can't happen.
   ;; Of course by the time we're done collecting nodes, the tree can have
   ;; been replaced by a different tree.
   (barrier (:read))
   (avltree-filter (lambda (node)
                     (let ((thread (avlnode-data node)))
-                      (when (and (= (thread-%visible thread) 1)
-                                 (neq thread sb-impl::*finalizer-thread*))
+                      (when (= (thread-%visible thread) 1)
                         thread)))
                   *all-threads*))
 
+(defun list-all-threads ()
+  "Return a list of the live threads. Note that the return value is
+potentially stale even before the function returns, as new threads may be
+created and old ones may exit at any time."
+  (delete sb-impl::*finalizer-thread* (%list-all-threads)))
+
 ;;; used by debug-int.lisp to access interrupt contexts
 
 (sb-ext:define-load-time-global *initial-thread* nil)
@@ -435,7 +437,6 @@ See also: RETURN-FROM-THREAD and SB-EXT:EXIT."
   (progn
     (locally (declare (sb-ext:muffle-conditions sb-ext:compiler-note))
       (define-structure-slot-addressor mutex-state-address
-        ;; The following quote is taken from Linux docs. It may not hold elsewhere.
         ;; """ (Futexes are 32 bits in size on all platforms, including 64-bit systems.) """
         ;; which means we need to add 4 bytes to get to the low 32 bits of the slot contents
         ;; where we store state. This would be prettier if we had 32-bit raw slots.
@@ -493,6 +494,7 @@ See also: RETURN-FROM-THREAD and SB-EXT:EXIT."
 
 ;;; Signals an error if owner of LOCK is waiting on a lock whose release
 ;;; depends on the current thread. Does not detect deadlocks from sempahores.
+#+sb-thread
 (defun check-deadlock ()
   (let* ((self *current-thread*)
          (origin (progn
@@ -721,11 +723,8 @@ returns NIL each time."
                (loop                    ; untimed
                      ;; Mark it as contested, and sleep, unless it is now in state 0.
                      (when (or (eql c 2) (/= 0 (sb-ext:cas val 1 2)))
-                       (let ((name (mutex-%name mutex)))
-                         (with-pinned-objects (mutex name)
-                           #+futex-wait-metric
-                           (unless (consp name) (setf (mutex-%name mutex) (cons name 0)))
-                           (futex-wait (mutex-state-address mutex) 2 -1 0))))
+                       (with-pinned-objects (mutex)
+                         (futex-wait (mutex-state-address mutex) 2 -1 0)))
                      ;; Try to get it, still marking it as contested.
                      (when (= 0 (setq c (sb-ext:cas val 0 2))) (return))) ; win
                (loop             ; same as above but check for timeout
@@ -1443,14 +1442,11 @@ on this semaphore, then N of them is woken up."
     ;; SESSION-NEW-ENROLLEES but not the push into THREADS, because anyone manipulating
     ;; the THREADS list must be holding the session lock.
     (let ((was-foreground (eq thread (foreground-thread session))))
-      (setf (session-threads session)
-            ;; FIXME: I assume these could use DELQ1.
-            ;; DELQ never conses, but DELETE does. (FIXME)
-            (delq thread (session-threads session))
+      (setf (session-threads session) (delq1 thread (session-threads session))
             (session-interactive-threads session)
-            (delq thread (session-interactive-threads session)))
+            (delq1 thread (session-interactive-threads session)))
       (when was-foreground
-        (condition-broadcast (session-interactive-threads-queue session))))))
+        (condition-notify (session-interactive-threads-queue session))))))
 
 (defun call-with-new-session (fn)
   (%delete-thread-from-session *current-thread*)
@@ -1459,9 +1455,7 @@ on this semaphore, then N of them is woken up."
 
 (defmacro with-new-session (args &body forms)
   (declare (ignore args))               ;for extensibility
-  (with-unique-names (fb-name) ; FIXME: what's the significance of "fb-" ?
-    `(labels ((,fb-name () ,@forms))
-      (call-with-new-session (function ,fb-name)))))
+  `(call-with-new-session (lambda () ,@forms)))
 
 ;;; WITH-DEATHLOK ensures that the 'struct thread' and/or OS thread won't go away
 ;;; by synchronizing with HANDLE-THREAD-EXIT.
@@ -1475,113 +1469,6 @@ on this semaphore, then N of them is woken up."
 #+allocator-metrics
 (sb-ext:define-load-time-global *allocator-metrics* nil)
 
-#+sb-thread
-(progn
-;;; Remove thread from its session, if it has one, and from *all-threads*.
-;;; Also clobber the pointer to the primitive thread
-;;; which makes THREAD-ALIVE-P return false hereafter.
-(defmacro handle-thread-exit ()
-  '(let* ((thread *current-thread*)
-           ;; use the "funny fixnum" representation
-           (c-thread (%make-lisp-obj (thread-primitive-thread thread)))
-           (sem (thread-semaphore thread)))
-      ;; System threads exit peacefully when asked, and they don't bother anyone.
-      ;; They must not participate in shutting other threads down.
-      (when (and *exit-in-progress* (not (thread-ephemeral-p thread)))
-        (%exit))
-      ;; This AVER failed when I messed up deletion from *STARTING-THREADS*.
-      ;; That in turn caused a failure in GC because a fixnum is not a legal value
-      ;; for the startup info when observed by GC.
-      (aver (not (memq thread *starting-threads*)))
-      ;; If collecting allocator metrics, transfer them to the global list
-      ;; so that we can summarize over exited threads.
-      #+allocator-metrics
-      (let ((metrics (cons (thread-name thread) (allocator-histogram))))
-        (sb-ext:atomic-push metrics *allocator-metrics*))
-      ;; Stash the primitive thread SAP for reuse, but clobber the PRIMITIVE-THREAD
-      ;; slot which makes ALIVE-P return NIL.
-      ;; A minor TODO: can this lock acquire/release be moved to where we actually
-      ;; unmap the memory an do a pthread_join()? I would think so, because until then,
-      ;; there is no real harm in reading the memory.  In this state the pthread library
-      ;; will usually return ESRCH if you try to use the pthread id - it's a valid
-      ;; pointer, but it knows that it has no underlying OS thread.
-      (with-deathlok (thread)
-        (when sem ; ordinary lisp thread, not FOREIGN-THREAD
-          (setf (thread-startup-info thread) c-thread))
-        ;; Accept no further interruptions. Other threads can't add new ones to the queue
-        ;; as doing so requires grabbing the per-thread mutex which we currently own.
-        ;; Deferrable signals are masked at this point, but it is best to tidy up
-        ;; any stray data such as captured closure values.
-        (setf (thread-interruptions thread) nil
-              (thread-primitive-thread thread) 0)
-        (setf (sap-ref-8 (current-thread-sap) ; state_word.sprof_enable
-                         (1+ (ash sb-vm:thread-state-word-slot sb-vm:word-shift)))
-              0)
-        ;; Take ownership of our statistical profiling data and transfer the results to
-        ;; the global pool. This doesn't need to synchronize with the signal handler,
-        ;; which is effectively disabled now, but does synchronize via the interruptions
-        ;; mutex with any other thread trying to read this thread's data.
-        (let ((sprof-data (sb-vm::current-thread-offset-sap sb-vm:thread-sprof-data-slot)))
-          (unless (= (sap-int sprof-data) 0)
-            (setf (sap-ref-word (descriptor-sap c-thread)
-                                (ash sb-vm:thread-sprof-data-slot sb-vm:word-shift))
-                  0)
-            ;; Operation on the global list must be atomic.
-            (sb-ext:atomic-push (cons sprof-data thread) *sprof-data*)))
-        (barrier (:write)))
-      ;; After making the thread dead, remove from session. If this were done first,
-      ;; we'd just waste time moving the thread into SESSION-THREADS (if it wasn't there)
-      ;; only to remove it right away.
-      (when *session*
-        (%delete-thread-from-session thread))
-      (cond
-        ;; If possible, logically remove from *ALL-THREADS* by flipping a bit.
-        ;; Foreign threads remove themselves. They don't have an exit semaphore,
-        ;; so that's how we know which is which.
-        (sem
-         ;; Tree pruning is the responsibility of thread creators, not dying threads.
-         ;; Creators have to manipulate the tree anyway, and they need access to the old
-         ;; structure to grab the memory.
-         (let ((old (sb-ext:cas (thread-%visible thread) 1 -1)))
-           ;; now (LIST-ALL-THREADS) won't see it
-           (aver (eql old 1)))
-         (locally (declare (sb-c::tlab :system))
-           (sb-ext:atomic-push thread *joinable-threads*)))
-        (t ; otherwise, physically remove from *ALL-THREADS*
-         ;; The memory allocation/deallocation is handled in C.
-         ;; I would like to combine the recycle bin for foreign and lisp threads though.
-         (delete-from-all-threads (get-lisp-obj-address c-thread))))
-      (when sem
-        (setf (thread-semaphore thread) nil) ; nobody needs to wait on it now
-        ;;
-        ;; We go out of our way to support something pthreads don't:
-        ;;  "The results of multiple simultaneous calls to pthread_join()
-        ;;   specifying the same target thread are undefined."
-        ;;   - https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html
-        ;; and for std::thread
-        ;;   "No synchronization is performed on *this itself. Concurrently calling join()
-        ;;    on the same thread object from multiple threads constitutes a data race
-        ;;    that results in undefined behavior."
-        ;;   - https://en.cppreference.com/w/cpp/thread/thread/join
-        ;; That's because (among other reasons), pthread_join deallocates memory.
-        ;; But in so far as our join does not equate to resource freeing, and our exit flag is
-        ;; our own kind of semaphore, we simply signal it using an arbitrarily huge count.
-        ;; See the comment in 'thread-structs.lisp' about why this isn't CONDITION-BROADCAST
-        ;; on a condition var. (Good luck trying to make this many threads)
-        (signal-semaphore sem 1000000))))
-
-;;; The "funny fixnum" address format would do no good - AVL-FIND and AVL-DELETE
-;;; expect normal happy lisp integers, even if a bignum.
-(defun delete-from-all-threads (addr)
-  (declare (type sb-vm:word addr))
-  (barrier (:read))
-  (let ((old *all-threads*))
-    (loop
-      (aver (avl-find addr old))
-      (let ((new (avl-delete addr old)))
-        (when (eq old (setq old (sb-ext:cas *all-threads* old new)))
-          (return)))))))
-
 (defvar sb-ext:*invoke-debugger-hook* nil
   "This is either NIL or a designator for a function of two arguments,
    to be run when the debugger is about to be entered.  The function is
@@ -1721,7 +1608,7 @@ have the foreground next."
         (when (and next (thread-alive-p next))
           (setf interactive-threads
                 (list* next (delete next interactive-threads))))
-        (condition-broadcast (session-interactive-threads-queue session))))))
+        (condition-notify (session-interactive-threads-queue session))))))
 
 (defun interactive-threads (&optional (session *session*))
   "Return the interactive threads of SESSION defaulting to the current
@@ -1819,6 +1706,18 @@ session."
   `(alien-funcall (extern-alien "free_thread_struct" (function void system-area-pointer))
                  ,memory))
 
+;;; The "funny fixnum" address format would do no good - AVL-FIND and AVL-DELETE
+;;; expect normal happy lisp integers, even if a bignum.
+(defun delete-from-all-threads (addr)
+  (declare (type sb-vm:word addr))
+  (barrier (:read))
+  (let ((old *all-threads*))
+    (loop
+      (aver (avl-find addr old))
+      (let ((new (avl-delete addr old)))
+        (when (eq old (setq old (sb-ext:cas *all-threads* old new)))
+          (return))))))
+
 (defun primitive-join (thread dispose)
   ;; It's safe to read from the other thread's memory, because the current thread
   ;; has ownership of that memory now. And we can't call this on a FOREIGN-THREAD.
@@ -1895,6 +1794,99 @@ session."
           (prot "protect_alien_stack_guard_page")))
       (unless (= (sap-int thread-sap) 0) thread-sap))))
 
+;;; Remove thread from its session, if it has one, and from *all-threads*.
+;;; Also clobber the pointer to the primitive thread
+;;; which makes THREAD-ALIVE-P return false hereafter.
+(defmacro handle-thread-exit ()
+  '(let* ((thread *current-thread*)
+           ;; use the "funny fixnum" representation
+           (c-thread (%make-lisp-obj (thread-primitive-thread thread)))
+           (sem (thread-semaphore thread)))
+      ;; This AVER failed when I messed up deletion from *STARTING-THREADS*.
+      ;; That in turn caused a failure in GC because a fixnum is not a legal value
+      ;; for the startup info when observed by GC.
+      (aver (not (memq thread *starting-threads*)))
+      ;; System threads exit peacefully when asked, and they don't bother anyone.
+      ;; They must not participate in shutting other threads down.
+      (when (and *exit-in-progress* (not (thread-ephemeral-p thread)))
+        (%exit))
+      ;; If collecting allocator metrics, transfer them to the global list
+      ;; so that we can summarize over exited threads.
+      #+allocator-metrics
+      (let ((metrics (cons (thread-name thread) (allocator-histogram))))
+        (sb-ext:atomic-push metrics *allocator-metrics*))
+      ;; Stash the primitive thread SAP for reuse, but clobber the PRIMITIVE-THREAD
+      ;; slot which makes ALIVE-P return NIL.
+      ;; A minor TODO: can this lock acquire/release be moved to where we actually
+      ;; unmap the memory an do a pthread_join()? I would think so, because until then,
+      ;; there is no real harm in reading the memory.  In this state the pthread library
+      ;; will usually return ESRCH if you try to use the pthread id - it's a valid
+      ;; pointer, but it knows that it has no underlying OS thread.
+      (with-deathlok (thread)
+        (when sem ; ordinary lisp thread, not FOREIGN-THREAD
+          (setf (thread-startup-info thread) c-thread))
+        ;; Accept no further interruptions. Other threads can't add new ones to the queue
+        ;; as doing so requires grabbing the per-thread mutex which we currently own.
+        ;; Deferrable signals are masked at this point, but it is best to tidy up
+        ;; any stray data such as captured closure values.
+        (setf (thread-interruptions thread) nil
+              (thread-primitive-thread thread) 0)
+        (setf (sap-ref-8 (current-thread-sap) ; state_word.sprof_enable
+                         (1+ (ash sb-vm:thread-state-word-slot sb-vm:word-shift)))
+              0)
+        ;; Take ownership of our statistical profiling data and transfer the results to
+        ;; the global pool. This doesn't need to synchronize with the signal handler,
+        ;; which is effectively disabled now, but does synchronize via the interruptions
+        ;; mutex with any other thread trying to read this thread's data.
+        (let ((sprof-data (sb-vm::current-thread-offset-sap sb-vm:thread-sprof-data-slot)))
+          (unless (= (sap-int sprof-data) 0)
+            (setf (sap-ref-word (descriptor-sap c-thread)
+                                (ash sb-vm:thread-sprof-data-slot sb-vm:word-shift))
+                  0)
+            ;; Operation on the global list must be atomic.
+            (sb-ext:atomic-push (cons sprof-data thread) *sprof-data*)))
+        (barrier (:write)))
+      ;; After making the thread dead, remove from session. If this were done first,
+      ;; we'd just waste time moving the thread into SESSION-THREADS (if it wasn't there)
+      ;; only to remove it right away.
+      (when *session*
+        (%delete-thread-from-session thread))
+      (cond
+        ;; If possible, logically remove from *ALL-THREADS* by flipping a bit.
+        ;; Foreign threads remove themselves. They don't have an exit semaphore,
+        ;; so that's how we know which is which.
+        (sem
+         ;; Tree pruning is the responsibility of thread creators, not dying threads.
+         ;; Creators have to manipulate the tree anyway, and they need access to the old
+         ;; structure to grab the memory.
+         (let ((old (sb-ext:cas (thread-%visible thread) 1 -1)))
+           ;; now (LIST-ALL-THREADS) won't see it
+           (aver (eql old 1)))
+         (locally (declare (sb-c::tlab :system))
+           (sb-ext:atomic-push thread *joinable-threads*)))
+        (t ; otherwise, physically remove from *ALL-THREADS*
+         ;; The memory allocation/deallocation is handled in C.
+         ;; I would like to combine the recycle bin for foreign and lisp threads though.
+         (delete-from-all-threads (get-lisp-obj-address c-thread))))
+      (when sem
+        (setf (thread-semaphore thread) nil) ; nobody needs to wait on it now
+        ;;
+        ;; We go out of our way to support something pthreads don't:
+        ;;  "The results of multiple simultaneous calls to pthread_join()
+        ;;   specifying the same target thread are undefined."
+        ;;   - https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html
+        ;; and for std::thread
+        ;;   "No synchronization is performed on *this itself. Concurrently calling join()
+        ;;    on the same thread object from multiple threads constitutes a data race
+        ;;    that results in undefined behavior."
+        ;;   - https://en.cppreference.com/w/cpp/thread/thread/join
+        ;; That's because (among other reasons), pthread_join deallocates memory.
+        ;; But in so far as our join does not equate to resource freeing, and our exit flag is
+        ;; our own kind of semaphore, we simply signal it using an arbitrarily huge count.
+        ;; See the comment in 'thread-structs.lisp' about why this isn't CONDITION-BROADCAST
+        ;; on a condition var. (Good luck trying to make this many threads)
+        (signal-semaphore sem 1000000))))
+
 (defun run (); All threads other than the initial thread start via this function.
   (set-thread-control-stack-slots *current-thread*)
   (flet ((unmask-signals ()
@@ -2506,34 +2498,43 @@ mechanism for inter-thread communication."
 ;;; globaldb should indicate that the variable is both :always-thread-local
 ;;; (which says that the TLS index is nonzero), and :always-bound (which says that
 ;;; the value in TLS is not UNBOUND-MARKER).
-;;; Here's the problem: Some of the backends implement those semantics as dictated
-;;; by globaldb - assigning into TLS even if the current TLS value is NO_TLS_VALUE;
-;;; while others do not make use of that information, and will therefore assign into
-;;; the symbol-global-value if the TLS value is NO_TLS_VALUE.
-;;; This can not be "corrected" by genesis - there is no TLS when genesis executes.
-;;; The only way to do this uniformly for all the platforms is to compute the address
-;;; of the thread-local storage slot, and use (SETF SAP-REF-LISPOBJ) on that.
-;;; (Existence of a vop for ENSURE-SYMBOL-TLS-INDEX is not an indicator that the
-;;; SET vop will assign into a thread-local symbol that currently has no TLS value.)
 (defun init-thread-local-storage (thread)
   ;; In addition to wanting the expressly unsafe variant of SYMBOL-VALUE, any error
   ;; signaled such as invalid-arg-count would just go totally wrong at this point.
   (declare (optimize (safety 0)))
   #-sb-thread
   (macrolet ((expand () `(setf ,@(apply #'append (cdr *thread-local-specials*)))))
+    (setf *current-thread* thread)
     (expand))
-  ;; See %SET-SYMBOL-VALUE-IN-THREAD for comparison's sake
+  ;; Bear in mind that relative to the #-sb-thread code these assignments require
+  ;; a trick because none of the symbols have been thread-locally bound.
+  ;; The C runtime shouldn't have to know to prefill most but not all the TLS with
+  ;; NO-TLS-VALUE. Hence these symbols' TLS slots contain NO-TLS-VALUE which under
+  ;; ordinary circumstances could cause the store to affect SYMBOL-GLOBAL-VALUE.
+  ;; So we have to store directly into offsets relative to the primitive thread.
+  ;; See %SET-SYMBOL-VALUE-IN-THREAD for comparison.
+  ;; Also note that on x86-64, (SETF SAP-REF-LISPOBJ) won't move immediate-to-memory
+  ;; using one instruction, but sap-ref-word will.
+  ;; So some of these are compile-time converted into their bit representation.
+  ;; (Additionally there is a redundant move from THREAD-TN to a sap register
+  ;; which could probably be eliminated but only via peephole optimization)
   #+sb-thread
   (let ((sap (current-thread-sap)))
     (macrolet ((expand ()
-                 `(setf ,@(loop for (var form) in (cdr *thread-local-specials*)
+                 `(setf (sap-ref-lispobj sap ,(info :variable :wired-tls '*current-thread*))
+                        thread
+                        ,@(loop for (var form) in (cdr *thread-local-specials*)
                                 for index = (info :variable :wired-tls var)
-                                append `((sap-ref-lispobj sap ,index) ,form)))))
+                                append
+                                (cond #+x86-64
+                                      ((equal form '(sb-kernel:make-unbound-marker))
+                                       `((sap-ref-word sap ,index) ,(sb-vm::unbound-marker-bits)))
+                                      #+x86-64
+                                      ((eq form nil)
+                                       `((sap-ref-word sap ,index) ,sb-vm:nil-value))
+                                      (t
+                                       `((sap-ref-lispobj sap ,index) ,form)))))))
       (expand)))
-  ;; Straightforwardly assign *current-thread* because it's never the NO-TLS-VALUE marker.
-  ;; I wonder how to to prevent user code from doing this, but it isn't a new problem per se.
-  ;; Perhaps this should be symbol-macro with a vop behind it and no setf expander.
-  (setf *current-thread* thread)
   thread)
 
 (eval-when (:compile-toplevel)
@@ -2592,9 +2593,9 @@ mechanism for inter-thread communication."
             #-sb-thread (ash thread-obj-len sb-vm:word-shift)
             by sb-vm:n-word-bytes
             do
-         (unless (<= sb-vm::thread-obj-size-histo-slot
+         (unless (<= sb-vm::thread-allocator-histogram-slot
                      (ash tlsindex (- sb-vm:word-shift))
-                     (+ sb-vm::thread-obj-size-histo-slot (1- sb-vm:n-word-bits)))
+                     (1- sb-vm::thread-lisp-thread-slot))
            (let ((thread-slot-name
                   (if (< tlsindex (ash thread-obj-len sb-vm:word-shift))
                            (aref names (ash tlsindex (- sb-vm:word-shift))))))
@@ -2616,78 +2617,94 @@ mechanism for inter-thread communication."
             (show sym val))
           (setq from (sap+ from (* sb-vm:binding-size sb-vm:n-word-bytes))))))))
 
-#+allocator-metrics
 (macrolet ((histogram-value (c-thread index)
              `(sap-ref-word (int-sap ,c-thread)
-                            (ash (+ sb-vm::thread-obj-size-histo-slot ,index)
+                            (ash (+ sb-vm::thread-allocator-histogram-slot ,index)
                                  sb-vm:word-shift)))
            (metric (c-thread slot)
              `(sap-ref-word (int-sap ,c-thread)
-                            (ash ,slot sb-vm:word-shift))))
-(export '(print-allocator-histogram reset-allocator-histogram))
+                            (ash ,slot sb-vm:word-shift)))
+           (histogram-array-length ()
+             (+ sb-vm::n-histogram-bins-small
+                (* 2 sb-vm::n-histogram-bins-large))))
+
+(export '(allocator-histogram print-allocator-histogram reset-allocator-histogram))
 (defun allocator-histogram (&optional (thread *current-thread*))
   (if (eq thread :all)
       (labels ((vector-sum (a b)
-                 (let ((result (make-array (max (length a) (length b))
-                                           :element-type 'fixnum)))
+                 (let ((result (make-array (length a) :element-type 'fixnum)))
                    (dotimes (i (length result) result)
-                     (setf (aref result i)
-                           (+ (if (< i (length a)) (aref a i) 0)
-                              (if (< i (length b)) (aref b i) 0))))))
+                     (setf (aref result i) (+ (aref a i) (aref b i))))))
                (sum (a b)
-                 (cond ((null a) b)
-                       ((null b) a)
-                       (t (cons (vector-sum (car a) (car b))
-                                (mapcar #'+ (cdr a) (cdr b)))))))
-        (reduce #'sum
-                ;; what about the finalizer thread?
-                (mapcar 'allocator-histogram (list-all-threads))))
+                 (list (vector-sum (first a) (first b)) ; bin counts
+                       (vector-sum (second a) (second b)) ; nbytes in large bins
+                       (+ (third a) (third b)) ; unboxed total
+                       (+ (fourth a) (fourth b))))) ; boxed total
+        ;; can get a NIL if a thread exited by the time we got to asking for its data
+        (reduce #'sum (delete nil
+                              (mapcar 'allocator-histogram (%list-all-threads)))))
       (with-deathlok (thread c-thread)
         (unless (= c-thread 0)
-          (dx-let ((a (make-array (+ sb-vm::histogram-small-bins sb-vm:n-word-bits)
-                                  :element-type 'fixnum)))
+          (let ((a (make-array (histogram-array-length) :element-type 'fixnum))
+                (boxed (metric c-thread sb-vm::thread-tot-bytes-alloc-boxed-slot))
+                (unboxed (metric c-thread sb-vm::thread-tot-bytes-alloc-unboxed-slot)))
+            (declare (truly-dynamic-extent a))
             (dotimes (i (length a))
               (setf (aref a i) (histogram-value c-thread i)))
-            (list (subseq a 0 (1+ (or (position 0 a :from-end t :test #'/=) -1)))
-                  (metric c-thread sb-vm::thread-tot-bytes-alloc-boxed-slot)
-                  (metric c-thread sb-vm::thread-tot-bytes-alloc-unboxed-slot)
-                  (metric c-thread sb-vm::thread-slow-path-allocs-slot)
-                  (metric c-thread sb-vm::thread-et-allocator-mutex-acq-slot)
-                  (metric c-thread sb-vm::thread-et-find-freeish-page-slot)
-                  (metric c-thread sb-vm::thread-et-bzeroing-slot)))))))
+            (list (subseq a 0 (+ sb-vm::n-histogram-bins-small
+                                 sb-vm::n-histogram-bins-large))
+                  (subseq a (+ sb-vm::n-histogram-bins-small
+                               sb-vm::n-histogram-bins-large))
+                  unboxed
+                  boxed))))))
 
 (defun reset-allocator-histogram (&optional (thread *current-thread*))
-  (with-deathlok (thread c-thread)
-    (unless (= c-thread 0)
-      (setf (metric c-thread sb-vm::thread-tot-bytes-alloc-boxed-slot) 0
-            (metric c-thread sb-vm::thread-tot-bytes-alloc-unboxed-slot) 0
-            (metric c-thread sb-vm::thread-slow-path-allocs-slot) 0)
-      (dotimes (i (+ sb-vm::histogram-small-bins sb-vm:n-word-bits))
-        (setf (histogram-value c-thread i) 0)))))
-
-(defun print-allocator-histogram (&optional (thread *current-thread*))
-  (destructuring-bind (bins tot-bytes-boxed tot-bytes-unboxed n-slow-path lock find clear)
-      (allocator-histogram thread)
-    (let ((total-objects (reduce #'+ bins))
-          (cumulative 0))
-      (format t "~&       Size      Count    Cum%~%")
-      (loop for index from 0
-            for count across bins
-            for size-exact-p = (< index sb-vm::histogram-small-bins)
-            for size = (if size-exact-p
-                           (* (1+ index) 2 sb-vm:n-word-bytes)
-                           (ash 1 (+ (- index sb-vm::histogram-small-bins) 10)))
-        do
-        (incf cumulative count)
-        (format t "~& ~10@a : ~8d  ~6,2,2f~%"
-                (cond (size-exact-p size)
-                      ((< size 1048576) (format nil "< ~d" size))
-                      (t (format nil "< 2^~d" (1- (integer-length size)))))
-                count (/ cumulative total-objects))
-        (setq size (* size 2)))
-      (when (plusp total-objects)
-        (format t "Total: ~D+~D bytes, ~D objects, ~,2,2f% fast path~%"
-                tot-bytes-boxed tot-bytes-unboxed total-objects
-                (/ (- total-objects n-slow-path) total-objects)))
-      (format t "Times (sec): lock=~,,-9f find=~,,-9f clear=~,,-9f~%"
-              lock find clear)))))
+  (if (eq thread :all)
+      (mapc #'reset-allocator-histogram (%list-all-threads))
+      (with-deathlok (thread c-thread)
+        (unless (= c-thread 0)
+          (setf (metric c-thread sb-vm::thread-tot-bytes-alloc-boxed-slot) 0
+                (metric c-thread sb-vm::thread-tot-bytes-alloc-unboxed-slot) 0
+                (metric c-thread sb-vm::thread-slow-path-allocs-slot) 0)
+          (dotimes (i (histogram-array-length))
+            (setf (histogram-value c-thread i) 0)))))))
+
+(defun print-allocator-histogram (&optional (thread-or-values *current-thread*))
+  (destructuring-bind (counts large-allocated tot-bytes-unboxed tot-bytes-boxed)
+      (if (listp thread-or-values)
+          thread-or-values ; histogram was already gathered, just print it
+          (allocator-histogram thread-or-values))
+    (let* ((tot-bins (length counts))
+           (tot-objects (reduce #'+ counts))
+           (bin-label (make-array tot-bins))
+           (bin-nbytes (make-array tot-bins))
+           (cumulative 0))
+      (dotimes (i sb-vm::n-histogram-bins-small)
+        (setf (aref bin-label i) (* (1+ i) sb-vm:cons-size sb-vm:n-word-bytes)
+              (aref bin-nbytes i) (* (aref counts i) (aref bin-label i))))
+      (dotimes (i sb-vm::n-histogram-bins-small)
+        (let ((bin-index (+ sb-vm::n-histogram-bins-small i))
+              (size-max (ash 1 (+ i sb-vm::first-large-histogram-bin-log2size)))
+              (allocated (aref large-allocated i)))
+          (setf (aref bin-label bin-index)
+                (if (< size-max 1048576)
+                    (format nil "< ~d" size-max)
+                    (format nil "< 2^~d" (1- (integer-length size-max))))
+                (aref bin-nbytes bin-index) allocated)))
+      (format t "~& Bin      Size     Allocated     Count    Cum%~%")
+      (dotimes (i tot-bins)
+        (let ((count (aref counts i)))
+          (incf cumulative count)
+          (format t "~& ~2d ~10@a ~13d ~9d ~7,2,2f~%"
+                  i
+                  (aref bin-label i)
+                  (aref bin-nbytes i)
+                  count
+                  (when (plusp tot-objects) (/ cumulative tot-objects)))))
+      (let ((tot-bytes (+ tot-bytes-unboxed tot-bytes-boxed)))
+        (format t "~& Tot ~23d ~9d~%" tot-bytes tot-objects)
+        (when (plusp tot-bytes)
+          (format t "; ~D unboxed + ~D boxed bytes (~,1,2F% + ~,1,2F%)~%"
+                  tot-bytes-unboxed tot-bytes-boxed
+                  (/ tot-bytes-unboxed tot-bytes)
+                  (/ tot-bytes-boxed tot-bytes)))))))
diff --git src/code/thread-structs.lisp src/code/thread-structs.lisp
index bc9be2314..8aad32236 100644
--- src/code/thread-structs.lisp
+++ src/code/thread-structs.lisp
@@ -27,38 +27,19 @@
 ;;; compete for a mutex, the pthread code seems to do a better job at reducing
 ;;; cycles spent in the OS.
 
-(sb-xc:defstruct (mutex (:constructor !make-mutex (%name))
+(sb-xc:defstruct (mutex (:constructor make-mutex (&key name))
                         (:copier nil))
   "Mutex type."
   #+sb-futex (state 0 :type sb-vm:word)
   ;; If adding slots between STATE and NAME, please see futex_name() in linux_os.c
   ;; which attempts to divine a string from a futex word address.
-  (%name  nil :type (or list simple-string))
+  (name   nil :type (or null simple-string))
   ;; The owner is a non-pointer so that GC pages containing mutexes do not get dirtied
   ;; with mutex ownership change. The natural representation of this is SB-VM:WORD
   ;; but the "funny fixnum" representation - i.e. N_WORD_BITS bits of significance, but
   ;; cast as fixnum when read - avoids consing on 32-bit builds, and also not all of them
   ;; implement RAW-INSTANCE-CAS which would be otherwise needed.
   (%owner 0 :type fixnum))
-#-sb-xc-host
-(progn
-(declaim (sb-ext:maybe-inline make-mutex))
-(defun make-mutex (&key name)
-  (declare (type (or null simple-string) name))
-  (declare (inline !make-mutex))
-  (!make-mutex name))
-(defun mutex-name (mutex)
-  ;; The %NAME slot can be replaced with a cons of a string and a fixnum,
-  ;; where the fixnum records the time elapsed in futex_wait.
-  ;; Mutexes that are never used or never have contention incur no space overhead,
-  ;; and mutexes that have contention cost 2 words more of space.
-  (let ((name (mutex-%name mutex)))
-    (if (listp name) (car name) name)))
-(defun (setf mutex-name) (newval mutex)
-  (let ((name (mutex-%name mutex)))
-    (if (listp name)
-        (setf (car name) newval)
-        (setf (mutex-%name mutex) newval)))))
 
 (sb-xc:defstruct (waitqueue (:copier nil) (:constructor make-waitqueue (&key name)))
   "Waitqueue type."
diff --git src/code/type-class.lisp src/code/type-class.lisp
index 5af46a888..838aa88ec 100644
--- src/code/type-class.lisp
+++ src/code/type-class.lisp
@@ -223,7 +223,9 @@
          ;; dynamic-space-free-pointer increments only when a page is full.
          ;; Using mixed_region directly is finer-grained.
          #+(and (not sb-thread) gencgc)
-         (sb-sys:sap-ref-word (sb-sys:int-sap sb-vm::mixed-region) 0)))
+         (sb-sys:sap-ref-word (sb-sys:int-sap (+ sb-vm::static-space-start
+                                                 sb-vm::mixed-region-offset))
+                              0)))
     ;; counter should increase by 1 for each cons cell allocated
     (ash word (- (1+ sb-vm:word-shift)))))
 ;;; Return some bits that are dependent on the next address that will be
diff --git src/cold/base-target-features.lisp-expr src/cold/base-target-features.lisp-expr
index 2fab7ac39..892ca26a9 100644
--- src/cold/base-target-features.lisp-expr
+++ src/cold/base-target-features.lisp-expr
@@ -277,6 +277,14 @@
  ;; foreign code that uses a 32-bit off_t.
  ; :largefile
 
+ ;; This feature allows static space to be relocatable on start-up.
+ ; :relocatable-static-space
+
+ ;; This feature allows Lisp spaces to be randomly allocated anywhere
+ ;; in virtual address space, i.e. the behavior of passing mmap an
+ ;; address of zero. Requires all spaces to be relocatable on start-up.
+ ; :aslr
+
  ;; SBCL has optional support for zstd-based compressed core files.  Enable
  ;; this feature to compile it in.  Obviously, doing so adds a dependency
  ;; on zstd.
diff --git src/cold/build-order.lisp-expr src/cold/build-order.lisp-expr
index edef2dcf3..17767318b 100644
--- src/cold/build-order.lisp-expr
+++ src/cold/build-order.lisp-expr
@@ -264,7 +264,7 @@
  ("src/compiler/proclaim" :c-headers)
 
  ("src/compiler/constantp" :c-headers)
- ("src/compiler/deftype" :c-headers)     ; on host for SB-XC:DEFTYPE
+ ("src/code/deftype" :c-headers)     ; on host for SB-XC:DEFTYPE
  ("src/code/type" :c-headers)
  ("src/compiler/generic/vm-type" :c-headers)
  ("src/code/pred" :not-host)
diff --git src/cold/exports.lisp src/cold/exports.lisp
index e010b8d26..209846412 100644
--- src/cold/exports.lisp
+++ src/cold/exports.lisp
@@ -191,8 +191,8 @@ SBCL itself")
            #+bignum-assertions "%%BIGNUM-SET"
            "%BIGNUM-SET-LENGTH" "%DIGIT-0-OR-PLUSP"
            "%DIGIT-LOGICAL-SHIFT-RIGHT"
-           "%FIXNUM-DIGIT-WITH-CORRECT-SIGN" "%FIXNUM-TO-DIGIT"
-           "%BIGFLOOR" "%LOGAND" "%LOGIOR" "%LOGNOT" "%LOGXOR"
+           "%FIXNUM-DIGIT-WITH-CORRECT-SIGN"
+           "%BIGFLOOR"
            "%MULTIPLY" "%MULTIPLY-AND-ADD"
            "%SUBTRACT-WITH-BORROW" "ADD-BIGNUMS" "ADD-BIGNUM-FIXNUM"
            "BIGNUM-ASHIFT-LEFT" "BIGNUM-ASHIFT-LEFT-FIXNUM"
@@ -2102,6 +2102,9 @@ is a good idea, but see SB-SYS re. blurring of boundaries.")
            "HAIRY-DATA-VECTOR-REF"
            "HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS"  "HAIRY-DATA-VECTOR-SET"
            "HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS"
+           "VECTOR-HAIRY-DATA-VECTOR-REF"
+           "VECTOR-HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS" "VECTOR-HAIRY-DATA-VECTOR-SET"
+           "VECTOR-HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS"
            "HAIRY-TYPE" "HAIRY-TYPE-P" "HAIRY-TYPE-SPECIFIER"
            "HANDLE-CIRCULARITY" "HOST" "ILL-BIN"
            "ILL-BOUT" "ILL-IN" "ILL-OUT" "INDEX-OR-MINUS-1"
@@ -2261,6 +2264,7 @@ is a good idea, but see SB-SYS re. blurring of boundaries.")
            "OBJECT-NOT-WEAK-POINTER-ERROR"
            "ODD-KEY-ARGS-ERROR" "OUTPUT-OBJECT" "OUTPUT-UGLY-OBJECT"
            "OVERFLOW*" "OVERFLOW+" "OVERFLOW-"
+           "OVERFLOW-ASH" "OVERFLOW-NEGATE"
            "PACKAGE-DESIGNATOR" "PACKAGE-DOC-STRING"
            "PACKAGE-INTERNAL-SYMBOLS" "PACKAGE-EXTERNAL-SYMBOLS"
            "PARSE-UNKNOWN-TYPE"
diff --git src/cold/shared.lisp src/cold/shared.lisp
index 695c168d6..eccecc299 100644
--- src/cold/shared.lisp
+++ src/cold/shared.lisp
@@ -293,13 +293,6 @@
         ;; Futexes aren't available in all macos versions, but they are available in all versions that support arm, so always enable them there
         (when (target-featurep '(:and :sb-thread (:or :linux :freebsd :openbsd (:and :darwin :arm64))))
           (pushnew :sb-futex sb-xc:*features*))
-        ;; If may not be the best idea to put clock_gettime calls around every
-        ;; futex_wait if the OS/libc you're building for does not have a vdso entry point.
-        ;; So leave this out unless enabled explicitly and/or I gather more data on
-        ;; its performance impact.
-        #+nil
-        (when (target-featurep '(:and :sb-futex :x86-64 :linux))
-          (pushnew :futex-wait-metric sb-xc:*features*))
         (when (target-featurep :immobile-space)
           (when (target-featurep :x86-64)
             (when (member :sb-thread sb-xc:*features*)
diff --git src/cold/ucd-filespecs.lisp-expr src/cold/ucd-filespecs.lisp-expr
new file mode 100644
index 000000000..b6bd952d4
--- /dev/null
+++ src/cold/ucd-filespecs.lisp-expr
@@ -0,0 +1,58 @@
+
+;; Inputs
+("tools-for-build/ucd.lisp"
+ "tools-for-build/UnicodeData.txt"
+ "tools-for-build/NormalizationCorrections.txt"
+ "tools-for-build/CompositionExclusions.txt"
+ "tools-for-build/SpecialCasing.txt"
+ "tools-for-build/EastAsianWidth.txt"
+ "tools-for-build/Scripts.txt"
+ "tools-for-build/LineBreak.txt"
+ "tools-for-build/DerivedAge.txt"
+ "tools-for-build/allkeys.txt"
+ "tools-for-build/emoji-data.txt"
+ "tools-for-build/confusables.txt"
+ "tools-for-build/BidiMirroring.txt"
+ "tools-for-build/Blocks.txt"
+ "tools-for-build/Jamo.txt"
+ "tools-for-build/CaseFolding.txt"
+ "tools-for-build/PropList.txt"
+ "tools-for-build/DerivedNormalizationProps.txt"
+ "tools-for-build/more-ucd-consts.lisp-expr")
+
+;; Outputs
+("output/bidi-mirrors.lisp-expr"
+ "output/BidiMirroring.txt"
+ "output/block-names.lisp-expr"
+ "output/block-ranges.lisp-expr"
+ "output/Blocks.txt"
+ "output/case.dat"
+ "output/CaseFolding.txt"
+ "output/casepages.dat"
+ "output/casepages.lisp-expr"
+ "output/collation.lisp-expr"
+ "output/comp.lisp-expr"
+ "output/CompositionExclusions.txt"
+ "output/confusables.lisp-expr"
+ "output/decomp.dat"
+ "output/DerivedAge.txt"
+ "output/DerivedNormalizationProps.txt"
+ "output/EastAsianWidth.txt"
+ "output/emoji-data.txt"
+ "output/confusables.txt"
+ "output/foldcases.lisp-expr"
+ "output/Jamo.txt"
+ "output/LineBreak.txt"
+ "output/misc-properties.lisp-expr"
+ "output/NormalizationCorrections.txt"
+ "output/numerics.lisp-expr"
+ "output/other-collation-info.lisp-expr"
+ "output/PropList.txt"
+ "output/Scripts.txt"
+ "output/SpecialCasing.txt"
+ "output/titlecases.lisp-expr"
+ "output/ucd1-names.lisp-expr"
+ "output/ucdhigh.dat"
+ "output/ucdlow.dat"
+ "output/ucdmisc.dat"
+ "output/ucd-names.lisp-expr")
diff --git src/compiler/aliencomp.lisp src/compiler/aliencomp.lisp
index 2c4de4512..e8a0eadfd 100644
--- src/compiler/aliencomp.lisp
+++ src/compiler/aliencomp.lisp
@@ -533,17 +533,17 @@
                  ;; then snarf out the string and use it as the funarg
                  ;; unless the backend lacks the CALL-OUT-NAMED vop.
                  `(%alien-funcall
-                   ,(or (when (and (gethash 'call-out-named *backend-parsed-vops*)
-                                   (lvar-matches function :fun-names '(%sap-alien)
-                                                          :arg-count 2))
-                          (let ((sap (first (combination-args (lvar-use function)))))
-                            (when (lvar-matches sap :fun-names '(foreign-symbol-sap)
-                                                    :arg-count 1)
-                              (let ((sym (first (combination-args (lvar-use sap)))))
-                                (when (and (constant-lvar-p sym)
-                                           (stringp (lvar-value sym)))
-                                  (setq ignore-fun t)
-                                  (lvar-value sym))))))
+                   ,(or (when-vop-existsp (:named call-out-named)
+                          (when (lvar-matches function :fun-names '(%sap-alien)
+                                                       :arg-count 2)
+                            (let ((sap (first (combination-args (lvar-use function)))))
+                              (when (lvar-matches sap :fun-names '(foreign-symbol-sap)
+                                                      :arg-count 1)
+                                (let ((sym (first (combination-args (lvar-use sap)))))
+                                  (when (and (constant-lvar-p sym)
+                                             (stringp (lvar-value sym)))
+                                    (setq ignore-fun t)
+                                    (lvar-value sym)))))))
                         `(deport function ',alien-type))
                    ',alien-type
                    ,@(deports))))
diff --git src/compiler/arm/arith.lisp src/compiler/arm/arith.lisp
index 0001b31a5..876f9f67c 100644
--- src/compiler/arm/arith.lisp
+++ src/compiler/arm/arith.lisp
@@ -236,8 +236,14 @@
 (define-vop (fast-logand/signed-unsigned=>unsigned fast-logand/unsigned=>unsigned)
   (:args (x :scs (signed-reg) :target r)
          (y :scs (unsigned-reg) :target r))
-  (:arg-types signed-num unsigned-num)
-  (:translate logand))
+  (:arg-types signed-num unsigned-num))
+
+(define-vop (fast-logand-c/signed-unsigned=>unsigned fast-logand-c/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r))
+  (:arg-types signed-num (:constant (eql #.most-positive-word)))
+  (:ignore y)
+  (:generator 1
+    (move r x)))
 
 (define-source-transform logeqv (&rest args)
   (if (oddp (length args))
@@ -885,9 +891,6 @@
     (inst umull lo temp x y)
     (inst bic hi temp fixnum-tag-mask)))
 
-(define-vop (bignum-lognot lognot-mod32/unsigned=>unsigned)
-  (:translate sb-bignum:%lognot))
-
 (define-vop (bignum-floor)
   (:translate sb-bignum:%bigfloor)
   (:policy :fast-safe)
diff --git src/compiler/arm/macros.lisp src/compiler/arm/macros.lisp
index cb143a21d..35329a6f4 100644
--- src/compiler/arm/macros.lisp
+++ src/compiler/arm/macros.lisp
@@ -236,7 +236,7 @@
          (storew null-tn result-tn -1 0 :ne)
          (inst orr result-tn result-tn lowtag))
         (t
-         (let ((region-disp (- mixed-region nil-value))
+         (let ((region-disp (- mixed-region-offset nil-value-offset))
                (alloc (gen-label))
                (back-from-alloc (gen-label)))
            (inst ldr result-tn (@ null-tn region-disp)) ; free ptr
diff --git src/compiler/arm/move.lisp src/compiler/arm/move.lisp
index baf1882df..66258e9d4 100644
--- src/compiler/arm/move.lisp
+++ src/compiler/arm/move.lisp
@@ -63,7 +63,8 @@
            ;; same comment as for LOAD-SYMBOL - how is this guaranteed
            ;; to be GC-safe ? Because we always ignore static-space pointers ?
            (composite-immediate-instruction add y null-tn
-             (- sb-vm::lockfree-list-tail-value sb-vm:nil-value))
+             (- lockfree-list-tail-value-offset
+                nil-value-offset))
            (bug "immediate structure-object ~S" val))))))
 
 (define-move-fun (load-number 1) (vop x y)
diff --git src/compiler/arm64/alloc.lisp src/compiler/arm64/alloc.lisp
index 896e017ad..ee123f731 100644
--- src/compiler/arm64/alloc.lisp
+++ src/compiler/arm64/alloc.lisp
@@ -87,7 +87,7 @@
   (:translate make-fdefn)
   (:generator 37
     (with-fixed-allocation (result lr fdefn-widetag fdefn-size)
-      (load-inline-constant temp '(:fixup undefined-tramp :assembly-routine))
+      (load-asm-routine temp 'undefined-tramp)
       (storew name result fdefn-name-slot other-pointer-lowtag)
       (storew null-tn result fdefn-fun-slot other-pointer-lowtag)
       (storew temp result fdefn-raw-addr-slot other-pointer-lowtag))))
@@ -112,7 +112,7 @@
 ;;; The compiler likes to be able to directly make value cells.
 ;;;
 (define-vop (make-value-cell)
-  (:args (value :to :save :scs (descriptor-reg any-reg)))
+  (:args (value :to :save :scs (descriptor-reg any-reg zero)))
   (:temporary (:scs (non-descriptor-reg) :offset lr-offset) lr)
   (:info stack-allocate-p)
   (:results (result :scs (descriptor-reg)))
@@ -134,7 +134,7 @@
   (:args)
   (:results (result :scs (any-reg)))
   (:generator 1
-    (load-inline-constant result '(:fixup funcallable-instance-tramp :assembly-routine))))
+    (load-asm-routine result 'funcallable-instance-tramp)))
 
 (define-vop (fixed-alloc)
   (:args)
@@ -148,7 +148,7 @@
                             :stack-allocate-p stack-allocate-p))))
 
 (define-vop (var-alloc)
-  (:args (extra :scs (any-reg)))
+  (:args (extra :scs (any-reg) :target bytes))
   (:arg-types positive-fixnum)
   (:info name words type lowtag stack-allocate-p)
   (:ignore name stack-allocate-p)
@@ -160,7 +160,9 @@
     ;; Build the object header, assuming that the header was in WORDS
     ;; but should not be in the header
     (inst lsl bytes extra (- word-shift n-fixnum-tag-bits))
-    (inst add bytes bytes (add-sub-immediate (* (1- words) n-word-bytes)))
+    (let ((words (add-sub-immediate (* (1- words) n-word-bytes))))
+      (unless (eql words 0)
+        (inst add bytes bytes words)))
     (inst lsl header bytes (- (length-field-shift type) word-shift))
     (inst add header header type)
     ;; Add the object header to the allocation size and round up to
@@ -194,9 +196,8 @@
      (move c-arg1 size-class)
      (move c-arg2 nwords)
      (move c-arg3 header)
-     (load-inline-constant lr '(:fixup "call_into_c" :foreign))
-     (load-inline-constant cfunc '(:fixup "alloc_immobile_fixedobj" :foreign))
-     (inst blr lr)
+     (load-foreign-symbol cfunc "alloc_immobile_fixedobj")
+     (invoke-foreign-routine "call_into_c" lr)
      (when cur-nfp
        (load-stack-tn cur-nfp nfp-save))
      (move result nl0))))
diff --git src/compiler/arm64/arith.lisp src/compiler/arm64/arith.lisp
index 0c545e35f..c1cf8e748 100644
--- src/compiler/arm64/arith.lisp
+++ src/compiler/arm64/arith.lisp
@@ -147,38 +147,43 @@
 
 (defmacro define-binop (translate untagged-penalty op
                         &key
-                             (constant-test 'encode-logical-immediate)
-                             (constant-fixnum-test 'fixnum-encode-logical-immediate)
-                             swap
-                             (constant-op op)
-                             (constant-transform 'identity))
+                          (constant-test 'encode-logical-immediate)
+                          (constant-fixnum-test 'fixnum-encode-logical-immediate)
+                          swap
+                          (constant-op op)
+                          (constant-transform 'identity)
+                          negative-op)
   `(progn
      (define-vop (,(symbolicate 'fast- translate '/fixnum=>fixnum)
                   fast-fixnum-binop)
        (:translate ,translate)
        (:generator 2
-                   ,(if swap
-                        `(inst ,op r y x)
-                        `(inst ,op r x y))))
+         ,(if swap
+              `(inst ,op r y x)
+              `(inst ,op r x y))))
      (define-vop (,(symbolicate 'fast- translate '-c/fixnum=>fixnum)
-                    fast-fixnum-binop-c)
+                  fast-fixnum-binop-c)
        ,(if swap
             `(:arg-types (:constant (satisfies ,constant-fixnum-test))
                          tagged-num)
             `(:arg-types tagged-num
                          (:constant (satisfies ,constant-fixnum-test))))
-         (:translate ,translate)
-         (:generator 1
-                     (inst ,constant-op r x (,constant-transform (fixnumize y)))))
+       (:translate ,translate)
+       (:generator 1
+         (cond ,@(and negative-op
+                      `(((minusp y)
+                         (inst ,negative-op r x (,constant-transform (fixnumize (- y)))))))
+               (t
+                (inst ,constant-op r x (,constant-transform (fixnumize y)))))))
      (define-vop (,(symbolicate 'fast- translate '/signed=>signed)
                   fast-signed-binop)
        (:translate ,translate)
        (:generator ,(1+ untagged-penalty)
-                   ,(if swap
-                        `(inst ,op r y x)
-                        `(inst ,op r x y))))
+         ,(if swap
+              `(inst ,op r y x)
+              `(inst ,op r x y))))
      (define-vop (,(symbolicate 'fast- translate '-c/signed=>signed)
-                   fast-signed-binop-c)
+                  fast-signed-binop-c)
        (:translate ,translate)
        ,(if swap
             `(:arg-types (:constant (satisfies ,constant-test))
@@ -186,16 +191,20 @@
             `(:arg-types signed-num
                          (:constant (satisfies ,constant-test))))
        (:generator ,untagged-penalty
-                   (inst ,constant-op r x (,constant-transform y))))
+         (cond ,@(and negative-op
+                      `(((minusp y)
+                         (inst ,negative-op r x (,constant-transform (- y))))))
+               (t
+                (inst ,constant-op r x (,constant-transform y))))))
      (define-vop (,(symbolicate 'fast- translate '/unsigned=>unsigned)
                   fast-unsigned-binop)
        (:translate ,translate)
        (:generator ,(1+ untagged-penalty)
-                   ,(if swap
-                        `(inst ,op r y x)
-                        `(inst ,op r x y))))
+         ,(if swap
+              `(inst ,op r y x)
+              `(inst ,op r x y))))
      (define-vop (,(symbolicate 'fast- translate '-c/unsigned=>unsigned)
-                   fast-unsigned-binop-c)
+                  fast-unsigned-binop-c)
        (:translate ,translate)
        ,(if swap
             `(:arg-types (:constant (satisfies ,constant-test))
@@ -203,10 +212,16 @@
             `(:arg-types unsigned-num
                          (:constant (satisfies ,constant-test))))
        (:generator ,untagged-penalty
-                   (inst ,constant-op r x (,constant-transform y))))))
-
-(define-binop + 4 add :constant-test add-sub-immediate-p :constant-fixnum-test fixnum-add-sub-immediate-p)
-(define-binop - 4 sub :constant-test add-sub-immediate-p :constant-fixnum-test fixnum-add-sub-immediate-p)
+         (cond ,@(and negative-op
+                      `(((minusp y)
+                         (inst ,negative-op r x (,constant-transform (- y))))))
+               (t
+                (inst ,constant-op r x (,constant-transform y))))))))
+
+(define-binop + 4 add :constant-test abs-add-sub-immediate-p :constant-fixnum-test fixnum-abs-add-sub-immediate-p
+  :negative-op sub)
+(define-binop - 4 sub :constant-test abs-add-sub-immediate-p :constant-fixnum-test fixnum-abs-add-sub-immediate-p
+  :negative-op add)
 (define-binop logand 2 and)
 (define-binop logior 2 orr)
 (define-binop logxor 2 eor)
@@ -372,7 +387,7 @@
   (:note "inline (unsigned-byte 64) arithmetic")
   (:vop-var vop)
   (:save-p :compute-only)
-  (:generator 33
+  (:generator 34
     (when (types-equal-or-intersect (tn-ref-type y-ref)
                                     (specifier-type '(eql 0)))
       (let ((zero (generate-error-code vop 'division-by-zero-error x y)))
@@ -384,6 +399,67 @@
     (unless (eq (tn-kind rem) :unused)
       (inst msub rem quo y x))))
 
+(defun power-of-two-p (x)
+  (and (typep x 'signed-word)
+       (let ((abs (abs x)))
+         (and (> abs 1)
+              (= (logcount abs) 1)))))
+
+(define-vop (truncate/signed-power-of-two fast-safe-arith-op)
+  (:translate truncate)
+  (:args (x :scs (signed-reg) :to :result))
+  (:arg-types signed-num (:constant (satisfies power-of-two-p)))
+  (:arg-refs nil y-ref)
+  (:info y)
+  (:results (quo :scs (signed-reg) :from :eval)
+            (rem :scs (signed-reg) :from :eval))
+  (:optional-results rem)
+  (:result-types signed-num signed-num)
+  (:note "inline (signed-byte 64) arithmetic")
+  (:vop-var vop)
+  (:save-p :compute-only)
+  (:generator 10
+    (let* ((abs-y (abs y))
+           (shift (1- (integer-length abs-y))))
+      (if (eq abs-y 2)
+          (cond ((eq (tn-kind rem) :unused)
+                 (inst add quo x (lsr x 63))
+                 (if (minusp y)
+                     (inst neg quo (asr quo 1))
+                     (inst asr quo quo 1)))
+                (t
+                 (inst cmp x 0)
+                 (inst and rem x 1)
+                 (inst add quo x (lsr x 63))
+                 (inst csneg rem rem rem :ge)
+                 (if (minusp y)
+                     (inst neg quo (asr quo shift))
+                     (inst asr quo quo shift))))
+          (cond ((eq (tn-kind rem) :unused)
+                 (inst add quo x (add-sub-immediate (1- abs-y)))
+                 (inst cmp x 0)
+                 (inst csel quo quo x :lt)
+                 (if (minusp y)
+                     (inst neg quo (asr quo shift))
+                     (inst asr quo quo shift)))
+                ((minusp y)
+                 (let ((not-y (add-sub-immediate (lognot y))))
+                  (inst negs rem x)
+                  (inst and quo x not-y)
+                  (inst and rem rem not-y)
+                  (inst csneg rem quo rem :mi)
+                  (inst add quo x not-y)
+                  (inst cmp x 0)
+                  (inst csel quo quo x :lt)
+                  (inst neg quo (asr quo shift))))
+                (t
+                 (inst add quo x (add-sub-immediate (1- y)))
+                 (inst cmp x 0)
+                 (inst csel rem quo x :lt)
+                 (inst asr quo rem shift)
+                 (inst and rem rem (- y))
+                 (inst sub rem x rem)))))))
+
 ;;;
 (define-vop (fast-lognor/fixnum=>fixnum fast-fixnum-binop)
   (:translate lognor)
@@ -536,26 +612,17 @@
   (:variant-vars variant)
   (:generator 5
     (let ((positive (csubtypep (tn-ref-type amount-ref)
-                               (specifier-type '(integer 0))))
-          (negative (csubtypep (tn-ref-type amount-ref)
-                               (specifier-type '(integer * 0)))))
+                               (specifier-type '(integer 0)))))
       (cond
         ((csubtypep (tn-ref-type amount-ref)
                     (specifier-type `(integer -63 63)))
-         (unless negative
-           (ecase variant
-             (:signed (inst asr result number amount))
-             (:unsigned (inst lsr result number amount))))
+         (ecase variant
+           (:signed (inst asr result number amount))
+           (:unsigned (inst lsr result number amount)))
          (unless positive
-           (unless negative
-             (inst tbz amount 63 done))
+           (inst tbz amount 63 done)
            (inst neg temp amount)
            (inst lsl result number amount)))
-        (negative
-         (inst neg temp amount)
-         (inst cmp temp n-word-bits)
-         (inst csinv temp temp zr-tn :lo)
-         (inst lsl result number temp))
         (positive
          (inst cmp amount n-word-bits)
          (inst csinv temp amount zr-tn :lo)
@@ -778,11 +845,9 @@
   (:results (res :scs (any-reg)))
   (:result-types positive-fixnum)
   (:temporary (:scs (non-descriptor-reg) :from (:argument 0)) temp)
-  (:generator 30
-    (inst cmp arg 0)
-    (inst csinv temp arg arg :ge)
-    (inst clz temp temp)
-    (inst mov res (fixnumize 64))
+  (:generator 5
+    (inst cls temp arg)
+    (inst mov res (fixnumize 63))
     (inst sub res res (lsl temp n-fixnum-tag-bits))))
 
 (define-vop (unsigned-byte-64-len)
@@ -794,12 +859,11 @@
   (:results (res :scs (any-reg)))
   (:result-types positive-fixnum)
   (:temporary (:scs (non-descriptor-reg) :from (:argument 0)) temp)
-  (:generator 29
+  (:generator 5
     (inst clz temp arg)
     (inst mov res (fixnumize 64))
     (inst sub res res (lsl temp n-fixnum-tag-bits))))
 
-
 (define-vop (unsigned-byte-64-count)
   (:translate logcount)
   (:note "inline (unsigned-byte 64) logcount")
@@ -835,32 +899,11 @@
     (:variant t)
     (:variant-cost 30))
 
-(defknown %%ldb (integer unsigned-byte unsigned-byte) unsigned-byte
-  (movable foldable flushable always-translatable))
-
-(defknown %%dpb (integer unsigned-byte unsigned-byte integer) integer
-  (movable foldable flushable always-translatable))
-
-;;; Constant folding
-(defun %%ldb (integer size posn)
-  (%ldb size posn integer))
-
-(deftransform %%ldb ((integer size posn) (unsigned-byte t (constant-arg (integer #.n-word-bits))) *
-                     :important nil)
-  0)
-
-(deftransform %%ldb ((integer size posn) ((integer * -1) t (constant-arg (integer #.n-word-bits))) *
-                     :important nil)
-  1)
-
-(defun %%dpb (newbyte size posn integer)
-  (%dpb newbyte size posn integer))
 
 (define-vop (ldb-c/fixnum)
-  (:translate %%ldb)
+  (:translate %ldb)
   (:args (x :scs (any-reg)))
-  (:arg-types tagged-num
-              (:constant integer) (:constant integer))
+  (:arg-types (:constant integer) (:constant integer) tagged-num)
   (:info size posn)
   (:results (res :scs (unsigned-reg)))
   (:result-types unsigned-num)
@@ -877,10 +920,9 @@
            (inst and res res (ash most-positive-word (- size sb-vm:n-word-bits)))))))
 
 (define-vop (ldb-c)
-  (:translate %%ldb)
+  (:translate %ldb)
   (:args (x :scs (unsigned-reg signed-reg)))
-  (:arg-types (:or unsigned-num signed-num)
-              (:constant integer) (:constant integer))
+  (:arg-types (:constant integer) (:constant integer) (:or unsigned-num signed-num))
   (:info size posn)
   (:results (res :scs (unsigned-reg)))
   (:result-types unsigned-num)
@@ -892,7 +934,7 @@
         (inst ubfm res x posn (+ posn size -1)))))
 
 (define-vop (dpb-c/fixnum)
-  (:translate %%dpb)
+  (:translate %dpb)
   (:args (x :scs (signed-reg) :to :save)
          (y :scs (any-reg)))
   (:arg-types signed-num
@@ -907,7 +949,7 @@
     (inst bfm res x (- (1- n-word-bits) posn) (1- size))))
 
 (define-vop (dpb-c/signed)
-  (:translate %%dpb)
+  (:translate %dpb)
   (:args (x :scs (signed-reg) :to :save)
          (y :scs (signed-reg)))
   (:arg-types signed-num
@@ -924,7 +966,7 @@
                         (- n-word-bits posn)) (1- size))))
 
 (define-vop (dpb-c/unsigned)
-  (:translate %%dpb)
+  (:translate %dpb)
   (:args (x :scs (unsigned-reg) :to :save)
          (y :scs (unsigned-reg)))
   (:arg-types unsigned-num
@@ -1215,19 +1257,12 @@
 (define-source-transform lognand (x y)
   `(lognot (logand ,x ,y)))
 
-(defknown %logbitp (integer unsigned-byte) boolean
-  (movable foldable flushable always-translatable))
-
-;;; For constant folding
-(defun %logbitp (integer index)
-  (logbitp index integer))
-
 (define-vop ()
-  (:translate %logbitp)
+  (:translate logbitp)
   (:policy :fast-safe)
   (:args (x :scs (any-reg signed-reg unsigned-reg)))
   (:info y)
-  (:arg-types (:or tagged-num signed-num unsigned-num) (:constant (mod #.n-word-bits)))
+  (:arg-types (:constant (mod #.n-word-bits)) (:or tagged-num signed-num unsigned-num))
   (:conditional :ne)
   (:generator 2
     (inst tst x (ash 1 (min (if (sc-is x any-reg)
@@ -1465,9 +1500,6 @@
   (:generator 20
     (inst smulh hi x y)))
 
-(define-vop (bignum-lognot lognot-mod64/unsigned=>unsigned)
-  (:translate sb-bignum:%lognot))
-
 (define-vop (bignum-floor)
   (:translate sb-bignum:%bigfloor)
   (:policy :fast-safe)
@@ -2218,11 +2250,269 @@
             (inst b :cc error)
             done)))))
 
+(define-vop (overflow-negate-signed)
+  (:translate overflow-negate)
+  (:args (x :scs (signed-reg)))
+  (:arg-types signed-num)
+  (:info type)
+  (:results (r :scs (signed-reg)))
+  (:result-types signed-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::add-sub-overflow-error r)))
+      (inst negs r x)
+      (inst b :vs error))))
+
+(define-vop (overflow-negate-unsigned)
+  (:translate overflow-negate)
+  (:args (x :scs (unsigned-reg)))
+  (:arg-types unsigned-num)
+  (:info type)
+  (:results (r :scs (unsigned-reg)))
+  (:result-types unsigned-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::negate-overflow-error r)))
+      (move r x)
+      (inst cbnz x error))))
+
+(define-vop (overflow-negate-unsigned=>signed)
+  (:translate overflow-negate)
+  (:args (x :scs (unsigned-reg)))
+  (:arg-types unsigned-num)
+  (:info type)
+  (:results (r :scs (signed-reg)))
+  (:result-types signed-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::negate-overflow-error x)))
+      (inst mov tmp-tn 9223372036854775808)
+      (inst cmp x tmp-tn)
+      (inst b :hi error)
+      (inst neg r x))))
+
+(define-vop (overflow-negate-signed=>unsigned)
+  (:translate overflow-negate)
+  (:args (x :scs (signed-reg)))
+  (:arg-types signed-num)
+  (:info type)
+  (:results (r :scs (unsigned-reg)))
+  (:result-types unsigned-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::negate-overflow-error x)))
+      (inst cmp x 1)
+      (inst b :ge error)
+      (inst neg r x))))
+
+(define-vop (overflow-ash-signed)
+  (:translate overflow-ash)
+  (:args (number :scs (signed-reg))
+         (amount :scs (unsigned-reg signed-reg immediate)))
+  (:arg-types signed-num untagged-num)
+  (:arg-refs nil amount-ref)
+  (:info type)
+  (:results (r :scs (signed-reg) :from :load))
+  (:result-types signed-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 4
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (amount-error amount)
+           (error (generate-error-code+
+                   (when (sc-is amount immediate)
+                     (setf amount (tn-value amount)
+                           amount-error
+                           (make-random-tn :kind :normal
+                                           :sc (sc-or-lose (if (typep amount 'word)
+                                                               'unsigned-reg
+                                                               'signed-reg))
+                                           :offset (tn-offset tmp-tn)))
+                     (lambda ()
+                       (load-immediate-word amount-error amount)))
+                   vop 'sb-kernel::ash-overflow2-error number amount-error))
+           (fits (csubtypep (tn-ref-type amount-ref)
+                            (specifier-type `(integer -63 63)))))
+      (cond ((numberp amount)
+             (cond ((minusp amount)
+                    (setf amount (min (- amount) 63))
+                    (inst asr r number amount))
+                   ((> amount 63)
+                    (inst cbnz number error)
+                    (move r number))
+                   ((zerop amount)
+                    (move r number))
+                   (t
+                    (inst lsl r number amount)
+                    (inst asr tmp-tn number (- 64 amount))
+                    (inst cmp tmp-tn (asr r 63))
+                    (inst b :ne error))))
+            ((csubtypep (tn-ref-type amount-ref)
+                        (specifier-type 'unsigned-byte))
+             (unless fits
+               (move r number)
+               (inst cbz number done)
+               (inst cmp amount n-word-bits)
+               (inst b :ge error))
+             (inst neg tmp-tn amount)
+             (inst lsl r number amount)
+             (inst cbz amount done)
+             (inst asr tmp-tn number tmp-tn)
+             (inst cmp tmp-tn (asr r 63))
+             (inst b :ne error))
+            (t
+             (inst neg tmp-tn amount)
+             (cond (fits
+                    (inst asr r number tmp-tn))
+                   (t
+                    (inst cmp tmp-tn n-word-bits)
+                    (inst csinv r tmp-tn zr-tn :lo)
+                    (inst asr r number r)))
+             (inst cmp amount 0)
+             (inst b :le done)
+             (unless fits
+               (inst cbz number done)
+               (inst cmp amount n-word-bits)
+               (inst b :ge error))
+             (inst lsl r number amount)
+             (inst asr tmp-tn number tmp-tn) ;; a negated shift is the same as (- 64 shift)
+             (inst cmp tmp-tn (asr r 63))
+             (inst b :ne error))))
+    done))
+
+
+
+(define-vop (overflow-ash-unsigned)
+  (:translate overflow-ash)
+  (:args (number :scs (unsigned-reg))
+         (amount :scs (unsigned-reg signed-reg immediate)))
+  (:arg-types unsigned-num untagged-num)
+  (:arg-refs nil amount-ref)
+  (:info type)
+  (:results (r :scs (unsigned-reg) :from :load))
+  (:result-types unsigned-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:variant-vars signed fixnum)
+  (:generator 3
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (amount-error amount)
+           (error (generate-error-code+
+                   (when (sc-is amount immediate)
+                     (setf amount (tn-value amount)
+                           amount-error
+                           (make-random-tn :kind :normal
+                                           :sc (sc-or-lose (if (typep amount 'word)
+                                                               'unsigned-reg
+                                                               'signed-reg))
+                                           :offset (tn-offset tmp-tn)))
+                     (lambda ()
+                       (load-immediate-word amount-error amount)))
+                   vop 'sb-kernel::ash-overflow2-error number amount-error))
+           (fits (csubtypep (tn-ref-type amount-ref)
+                            (specifier-type `(integer -63 63)))))
+      (when signed
+        (inst tbnz number 63 error))
+      (cond ((numberp amount)
+             (cond ((< amount -63)
+                    (inst mov r 0))
+                   ((minusp amount)
+                    (inst lsr r number amount))
+                   ((> amount 63)
+                    (inst cbnz number error)
+                    (move r number))
+                   ((zerop amount)
+                    (move r number))
+                   (t
+                    (inst lsl r number amount)
+                    (cond ((= amount 1)
+                           (inst tbnz* number (if fixnum
+                                                  62
+                                                  63) error))
+                          (t
+                           (inst cmp zr-tn (lsr number (- (if fixnum
+                                                              n-fixnum-bits
+                                                              64)
+                                                          amount)))
+                           (inst b :ne error))))))
+            ((csubtypep (tn-ref-type amount-ref)
+                        (specifier-type 'unsigned-byte))
+             (unless fits
+               (move r number)
+               (inst cbz number done)
+               (inst cmp amount n-word-bits)
+               (inst b :ge error))
+             (if fixnum
+                 (inst mvn tmp-tn amount)  ; (- 63 amount)
+                 (inst neg tmp-tn amount)) ; (- 64 amount)
+             (inst lsl r number amount)
+             (unless fixnum
+               (inst cbz amount done))
+             (inst asr tmp-tn number tmp-tn)
+             (inst cbnz tmp-tn error))
+            (t
+             (inst neg tmp-tn amount)
+             (cond (fits
+                    (inst lsr r number tmp-tn))
+                   (t
+                    (inst cmp tmp-tn n-word-bits)
+                    (inst csel r number zr-tn :lo)
+                    (inst lsr r r tmp-tn)))
+             (inst cmp amount 0)
+             (inst b :le done)
+             (unless fits
+               (inst cbz number done)
+               (inst cmp amount n-word-bits)
+               (inst b :ge error))
+             (inst lsl r number amount)
+             (inst asr tmp-tn number tmp-tn)
+             (inst cbnz tmp-tn error))))
+    done))
+
+(define-vop (overflow-ash-fixnum overflow-ash-signed)
+  (:args (number :scs (any-reg))
+         (amount :scs (unsigned-reg immediate)))
+  (:arg-types tagged-num unsigned-num)
+  (:results (r :scs (any-reg) :from :load))
+  (:result-types tagged-num)
+  (:variant-cost 2))
+
+(define-vop (overflow-ash-unsigned-fixnum overflow-ash-unsigned)
+  (:args (number :scs (any-reg))
+         (amount :scs (unsigned-reg immediate)))
+  (:arg-types positive-fixnum unsigned-num)
+  (:results (r :scs (any-reg) :from :load))
+  (:result-types positive-fixnum)
+  (:variant nil t)
+  (:variant-cost 1))
+
+(define-vop (overflow-ash-signed=>unsigned overflow-ash-unsigned)
+  (:args (number :scs (signed-reg))
+         (amount :scs (unsigned-reg signed-reg immediate)))
+  (:arg-types signed-num untagged-num)
+  (:variant t nil)
+  (:variant-cost 4))
+
 (define-vop (overflow+t)
   (:translate overflow+)
-  (:args (x :scs (descriptor-reg))
+  (:args (x :scs (any-reg descriptor-reg))
          (y :scs (any-reg signed-reg)))
-  (:arg-types t tagged-num)
+  (:arg-types (:or t tagged-num) tagged-num)
+  (:arg-refs x-ref)
   (:info type)
   (:results (r :scs (any-reg) :from :load))
   (:result-types tagged-num)
@@ -2232,7 +2522,8 @@
     (let* ((*location-context* (unless (eq type 'fixnum)
                                  type))
            (error (generate-error-code vop 'sb-kernel::add-overflow2-error x y)))
-      (inst tbnz x 0 error)
+      (unless (csubtypep (tn-ref-type x-ref) (specifier-type 'fixnum))
+        (inst tbnz x 0 error))
       (inst adds r x (if (sc-is y any-reg)
                          y
                          (lsl y n-fixnum-tag-bits)))
@@ -2240,9 +2531,10 @@
 
 (define-vop (overflow-t)
   (:translate overflow-)
-  (:args (x :scs (descriptor-reg))
+  (:args (x :scs (any-reg descriptor-reg))
          (y :scs (any-reg signed-reg)))
-  (:arg-types t tagged-num)
+  (:arg-types (:or t tagged-num) tagged-num)
+  (:arg-refs x-ref)
   (:info type)
   (:results (r :scs (any-reg) :from :load))
   (:result-types tagged-num)
@@ -2252,18 +2544,46 @@
     (let* ((*location-context* (unless (eq type 'fixnum)
                                  type))
            (error (generate-error-code vop 'sb-kernel::sub-overflow2-error x y)))
-      (inst tbnz x 0 error)
+      (unless (csubtypep (tn-ref-type x-ref) (specifier-type 'fixnum))
+        (inst tbnz x 0 error))
       (inst subs r x (if (sc-is y any-reg)
                          y
                          (lsl y n-fixnum-tag-bits)))
       (inst b :vs error))))
 
+(define-vop (overflow-t-y)
+  (:translate overflow-)
+  (:args (x :scs (any-reg))
+         (y :scs (any-reg descriptor-reg)))
+  (:arg-types tagged-num (:or t tagged-num))
+  (:arg-refs nil y-ref)
+  (:info type)
+  (:results (r :scs (any-reg) :from :load))
+  (:result-types tagged-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::sub-overflow2-error x y)))
+      (unless (csubtypep (tn-ref-type y-ref) (specifier-type 'fixnum))
+        (inst tbnz y 0 error))
+      (inst subs r x y)
+      (inst b :vs error))))
+
 (define-vop (overflow*t)
   (:translate overflow*)
-  (:args (x :scs (descriptor-reg))
-         (y :scs (signed-reg)))
-  (:arg-types t tagged-num)
+  (:args (x :scs (any-reg descriptor-reg))
+         (y :scs (signed-reg immediate)))
+  (:arg-types (:or t tagged-num) tagged-num)
+  (:arg-refs x-ref)
   (:info type)
+  (:temporary (:sc signed-reg
+               :unused-if
+               (or (not (sc-is y immediate))
+                   (and (plusp (tn-value y))
+                        (= (logcount (tn-value y)) 1))))
+              temp)
   (:results (r :scs (any-reg) :from :load))
   (:result-types tagged-num)
   (:policy :fast-safe)
@@ -2271,12 +2591,36 @@
   (:generator 2
     (let* ((*location-context* (unless (eq type 'fixnum)
                                  type))
-           (error (generate-error-code vop 'sb-kernel::mul-overflow2-error x y)))
-      (inst tbnz x 0 error)
-      (inst mul r x y)
-      (inst smulh tmp-tn x y)
-      (inst cmp tmp-tn (asr r 63))
-      (inst b :ne error))))
+           (value (and (sc-is y immediate)
+                       (tn-value y)))
+           (shift (and value
+                       (plusp value)
+                       (= (logcount value) 1)
+                       (1- (integer-length value))))
+           (error (generate-error-code+ (cond (shift
+                                               (setf y r)
+                                               (lambda ()
+                                                 (load-immediate-word y (fixnumize value))))
+                                              (value
+                                               (setf y temp)
+                                               (load-immediate-word y value)
+                                               nil))
+                                        vop
+                                        'sb-kernel::mul-overflow2-error x y)))
+      (unless (csubtypep (tn-ref-type x-ref) (specifier-type 'fixnum))
+        (inst tbnz x 0 error))
+      (cond ((eql shift 0)
+             (move r x))
+            (shift
+             (inst lsl r x shift)
+             (inst asr tmp-tn x (- 64 shift))
+             (inst cmp tmp-tn (asr r 63))
+             (inst b :ne error))
+            (t
+             (inst smulh tmp-tn x y)
+             (inst mul r x y)
+             (inst cmp tmp-tn (asr r 63))
+             (inst b :ne error))))))
 
 (define-vop (signum-signed signed-unop)
   (:args (x :scs (signed-reg any-reg) :target res))
diff --git src/compiler/arm64/array.lisp src/compiler/arm64/array.lisp
index 4a614b962..c3075dde2 100644
--- src/compiler/arm64/array.lisp
+++ src/compiler/arm64/array.lisp
@@ -153,6 +153,10 @@
                     (inst b :hs error))
                    ((eql index 0)
                     (inst cbz bound error))
+                   ((and (tn-p index)
+                         (sc-is index unsigned-reg signed-reg))
+                    (inst cmp index (lsr bound 1))
+                    (inst b :hs error))
                    (t
                     (inst cmp bound index)
                     (inst b :ls error))))))))
@@ -172,9 +176,9 @@
 
 (define-vop (check-bound/untagged check-bound)
   (:args (array)
-         (bound :scs (unsigned-reg signed-reg))
+         (bound)
          (index :scs (unsigned-reg signed-reg)))
-  (:arg-types * (:or unsigned-num signed-num)
+  (:arg-types * *
                 (:or unsigned-num signed-num))
   (:variant nil)
   (:variant-cost 5))
diff --git src/compiler/arm64/c-call.lisp src/compiler/arm64/c-call.lisp
index c5c6f9fd0..5db088c42 100644
--- src/compiler/arm64/c-call.lisp
+++ src/compiler/arm64/c-call.lisp
@@ -207,7 +207,7 @@
   (:results (res :scs (sap-reg)))
   (:result-types system-area-pointer)
   (:generator 2
-    (load-inline-constant res `(:fixup ,foreign-symbol :foreign))))
+    (load-foreign-symbol res foreign-symbol)))
 
 (define-vop (foreign-symbol-dataref-sap)
   (:translate foreign-symbol-dataref-sap)
@@ -218,19 +218,12 @@
   (:results (res :scs (sap-reg)))
   (:result-types system-area-pointer)
   (:generator 2
-    (load-inline-constant res `(:fixup ,foreign-symbol :foreign-dataref))
-    (inst ldr res (@ res))))
+    (load-foreign-symbol res foreign-symbol :dataref t)))
 
 (defun emit-c-call (vop nfp-save temp temp2 cfunc function)
   (let ((cur-nfp (current-nfp-tn vop)))
     (when cur-nfp
       (store-stack-tn nfp-save cur-nfp))
-    (if (stringp function)
-        (load-inline-constant cfunc `(:fixup ,function :foreign))
-        (sc-case function
-          (sap-reg (move cfunc function))
-          (sap-stack
-           (load-stack-offset cfunc cur-nfp function))))
     (assemble ()
       #+sb-thread
       (progn
@@ -240,8 +233,14 @@
         (inst adr temp2 return)
         (inst stp cfp-tn temp2 (@ csp-tn))
         (storew-pair csp-tn thread-control-frame-pointer-slot temp thread-control-stack-pointer-slot thread-tn)
-        (inst blr cfunc)
-
+        (cond ((stringp function)
+               (invoke-foreign-routine function cfunc))
+              (t
+               (sc-case function
+                 (sap-reg (move cfunc function))
+                 (sap-stack
+                  (load-stack-offset cfunc cur-nfp function)))
+               (inst blr cfunc)))
         (loop for reg in (list r0-offset r1-offset r2-offset r3-offset
                                r4-offset r5-offset r6-offset r7-offset
                                #-darwin r8-offset)
@@ -257,8 +256,13 @@
       #-sb-thread
       (progn
         temp2
-        (load-inline-constant temp '(:fixup "call_into_c" :foreign))
-        (inst blr temp))
+        (if (stringp function)
+            (load-foreign-symbol cfunc function)
+            (sc-case function
+              (sap-reg (move cfunc function))
+              (sap-stack
+              (load-stack-offset cfunc cur-nfp function))))
+        (invoke-foreign-routine "call_into_c" temp))
       (when cur-nfp
         (load-stack-tn cur-nfp nfp-save)))))
 
diff --git src/compiler/arm64/call.lisp src/compiler/arm64/call.lisp
index fea2cd0bc..e5698df7c 100644
--- src/compiler/arm64/call.lisp
+++ src/compiler/arm64/call.lisp
@@ -615,8 +615,7 @@
                       (lambda ()
                         ;; The size will be computed by subtracting from CSP
                         (inst mov tmp-tn context)
-                        (load-inline-constant lr `(:fixup listify-&rest :assembly-routine))
-                        (inst blr lr)
+                        (invoke-asm-routine 'listify-&rest lr)
                         (inst mov result tmp-tn)
                         (inst b leave-pa))))
         (move result dst)
@@ -1121,26 +1120,24 @@
       (when cur-nfp
         (inst add nsp-tn cur-nfp (add-sub-immediate
                                   (bytes-needed-for-non-descriptor-stack-frame)))))
-    (load-inline-constant tmp-tn
-      (if (eq fun-type :function)
-          '(:fixup tail-call-variable :assembly-routine)
-          '(:fixup tail-call-callable-variable :assembly-routine)))
-    (inst br tmp-tn)))
+    (invoke-asm-routine (if (eq fun-type :function)
+                            'tail-call-variable
+                            'tail-call-callable-variable)
+                        tmp-tn
+                        :tail t)))
 
 ;;; Invoke the function-designator FUN.
 (defun tail-call-unnamed (lexenv lr type)
   (case type
     (:symbol
-     (load-inline-constant tmp-tn '(:fixup tail-call-symbol :assembly-routine))
-     (inst br tmp-tn))
+     (invoke-asm-routine 'tail-call-symbol tmp-tn :tail t))
     (t
      (assemble ()
        (when (eq type :designator)
          (inst and tmp-tn lexenv lowtag-mask)
          (inst cmp tmp-tn fun-pointer-lowtag)
          (inst b :eq call)
-         (load-inline-constant tmp-tn '(:fixup tail-call-symbol :assembly-routine))
-         (inst br tmp-tn))
+         (invoke-asm-routine 'tail-call-symbol tmp-tn :tail t))
        call
        (loadw lr lexenv closure-fun-slot fun-pointer-lowtag)
        (inst add lr lr 4)
@@ -1149,16 +1146,14 @@
 (defun call-unnamed (lexenv lr type)
   (case type
     (:symbol
-     (load-inline-constant tmp-tn '(:fixup call-symbol :assembly-routine))
-     (inst blr tmp-tn))
+     (invoke-asm-routine 'call-symbol tmp-tn))
     (t
      (assemble ()
        (when (eq type :designator)
          (inst and tmp-tn lexenv lowtag-mask)
          (inst cmp tmp-tn fun-pointer-lowtag)
          (inst b :eq call)
-         (load-inline-constant tmp-tn '(:fixup call-symbol :assembly-routine))
-         (inst blr tmp-tn)
+         (invoke-asm-routine 'call-symbol tmp-tn)
          (inst b ret))
        call
        (loadw lr lexenv closure-fun-slot fun-pointer-lowtag)
@@ -1284,8 +1279,7 @@
     (move old-fp old-fp-arg)
     (move vals vals-arg)
     (move nvals nvals-arg)
-    (load-inline-constant tmp-tn '(:fixup return-multiple :assembly-routine))
-    (inst br tmp-tn)))
+    (invoke-asm-routine 'return-multiple tmp-tn :tail t)))
 
 ;;; Single-stepping
 
diff --git src/compiler/arm64/cell.lisp src/compiler/arm64/cell.lisp
index 4fe899bfc..c777a4862 100644
--- src/compiler/arm64/cell.lisp
+++ src/compiler/arm64/cell.lisp
@@ -33,8 +33,8 @@
 
 (define-vop (compare-and-swap-slot)
   (:args (object :scs (descriptor-reg))
-         (old :scs (descriptor-reg any-reg))
-         (new :scs (descriptor-reg any-reg)))
+         (old :scs (descriptor-reg any-reg zero))
+         (new :scs (descriptor-reg any-reg zero)))
   (:info name offset lowtag)
   (:ignore name)
   (:temporary (:sc non-descriptor-reg) lip)
@@ -247,8 +247,8 @@
 (define-vop (%compare-and-swap-symbol-value)
   (:translate %compare-and-swap-symbol-value)
   (:args (symbol :scs (descriptor-reg))
-         (old :scs (descriptor-reg any-reg))
-         (new :scs (descriptor-reg any-reg)))
+         (old :scs (descriptor-reg any-reg zero))
+         (new :scs (descriptor-reg any-reg zero)))
   (:results (result :scs (descriptor-reg any-reg) :from :load))
   #+sb-thread
   (:temporary (:sc any-reg) tls-index)
@@ -351,7 +351,7 @@
     (load-type type function (- fun-pointer-lowtag))
     (inst cmp type simple-fun-widetag)
     (inst b :eq SIMPLE-FUN)
-    (load-inline-constant lip '(:fixup closure-tramp :assembly-routine))
+    (load-asm-routine lip 'closure-tramp)
     SIMPLE-FUN
     (storew lip fdefn fdefn-raw-addr-slot other-pointer-lowtag)
     (storew function fdefn fdefn-fun-slot other-pointer-lowtag)
@@ -364,7 +364,7 @@
   (:temporary (:scs (non-descriptor-reg)) temp)
   (:generator 38
     (storew null-tn fdefn fdefn-fun-slot other-pointer-lowtag)
-    (load-inline-constant temp '(:fixup undefined-tramp :assembly-routine))
+    (load-asm-routine temp 'undefined-tramp)
     (storew temp fdefn fdefn-raw-addr-slot other-pointer-lowtag)))
 
 
@@ -392,8 +392,7 @@
       (inst ldr (32-bit-reg tls-index) (tls-index-of symbol))
       (inst cbnz (32-bit-reg tls-index) TLS-INDEX-VALID)
       (move alloc-tls-symbol symbol)
-      (load-inline-constant lr '(:fixup alloc-tls-index :assembly-routine))
-      (inst blr lr)
+      (invoke-asm-routine 'alloc-tls-index lr)
       TLS-INDEX-VALID
       (inst ldr alloc-tls-symbol (@ thread-tn tls-index))
       (inst stp alloc-tls-symbol tls-index
@@ -626,8 +625,7 @@
   (:temporary (:scs (non-descriptor-reg)) temp card)
   (:temporary (:sc non-descriptor-reg) pa-flag)
   (:generator 10
-    (load-inline-constant temp `(:fixup "gc_card_table_mask" :foreign-dataref))
-    (inst ldr temp (@ temp))
+    (load-foreign-symbol temp "gc_card_table_mask" :dataref t)
     (inst ldr (32-bit-reg temp) (@ temp)) ; 4-byte int
     (pseudo-atomic (pa-flag)
       #+immobile-space
@@ -667,8 +665,7 @@
       (inst lsr card object gencgc-card-shift)
       (inst and card card temp)
       ;; Load mark table base
-      (load-inline-constant temp `(:fixup "gc_card_mark" :foreign-dataref))
-      (inst ldr temp (@ temp))
+      (load-foreign-symbol temp "gc_card_mark" :dataref t)
       (inst ldr temp (@ temp))
       ;; Touch the card mark byte.
       (inst strb null-tn (@ temp card))
diff --git src/compiler/arm64/insts.lisp src/compiler/arm64/insts.lisp
index 3f8fb7a3c..0029375d7 100644
--- src/compiler/arm64/insts.lisp
+++ src/compiler/arm64/insts.lisp
@@ -1462,17 +1462,24 @@
   (:printer ldr-str-reg ((op #b11)))
   (:printer ldr-str-unscaled-imm ((op #b11)))
   (:emitter
-   (if (label-p address)
-       (emit-back-patch segment 4
-                        (lambda (segment posn)
-                          (emit-ldr-literal segment
-                                            #b01
-                                            (if (fp-register-p dst)
-                                                1
-                                                0)
-                                            (ash (- (label-position address) posn) -2)
-                                            (reg-offset dst))))
-       (emit-load-store nil 1 segment dst address))))
+   (typecase address
+     (fixup
+      (note-fixup segment :pc-relative-ldr-str address)
+      (emit-pc-relative segment 1 0 0 (reg-offset dst))  ; ADRP
+      (assemble (segment)
+        (inst ldr dst (@ dst))))
+     (label
+      (emit-back-patch segment 4
+                       (lambda (segment posn)
+                         (emit-ldr-literal segment
+                                           #b01
+                                           (if (fp-register-p dst)
+                                               1
+                                               0)
+                                           (ash (- (label-position address) posn) -2)
+                                           (reg-offset dst)))))
+     (t
+      (emit-load-store nil 1 segment dst address)))))
 
 (def-emitter ldr-str-pair
   (opc 2 30)
@@ -2079,7 +2086,14 @@
 (define-instruction adr (segment rd label &optional (offset 0))
   (:printer pc-relative ((op 0)))
   (:emitter
-   (emit-pc-relative-inst 0 segment rd label offset)))
+   (cond ((fixup-p label)
+          (aver (zerop offset))
+          (note-fixup segment :pc-relative label)
+          (emit-pc-relative segment 1 0 0 (reg-offset rd)) ; ADRP
+          (assemble (segment)
+            (inst add rd rd 0)))
+         (t
+          (emit-pc-relative-inst 0 segment rd label offset)))))
 
 (define-instruction adrp (segment rd label)
   (:printer pc-relative ((op 1)))
@@ -3314,6 +3328,28 @@
       (:uncond-branch
        (setf (ldb (byte 26 0) (sap-ref-32 sap offset))
              (ash (- value (+ (sap-int sap) offset)) -2)))
+      (:pc-relative
+       (let ((page-displacement
+               (- (ash value -12)
+                  (ash (+ (sap-int sap) offset) -12))))
+         (setf (ldb (byte 2 29) (sap-ref-32 sap offset))
+               (ldb (byte 2 0) page-displacement))
+         (setf (ldb (byte 19 5) (sap-ref-32 sap offset))
+               (ldb (byte 19 2) page-displacement)))
+       (setf (ldb (byte 12 10) (sap-ref-32 sap (+ offset 4)))
+             (ldb (byte 12 0) value)))
+      (:pc-relative-ldr-str
+       (let ((page-displacement
+               (- (ash value -12)
+                  (ash (+ (sap-int sap) offset) -12))))
+         (setf (ldb (byte 2 29) (sap-ref-32 sap offset))
+               (ldb (byte 2 0) page-displacement))
+         (setf (ldb (byte 19 5) (sap-ref-32 sap offset))
+               (ldb (byte 19 2) page-displacement))
+         (unless (zerop (logand value (1- n-word-bytes)))
+           (error "Unaligned LDR/STR fixup at #x~x?" value))
+         (setf (ldb (byte 12 10) (sap-ref-32 sap (+ offset 4)))
+               (ash (ldb (byte 12 0) value) (- word-shift)))))
       (:ldr-str
        (setf (ldb (byte 12 10) (sap-ref-32 sap offset))
              (ash (the (unsigned-byte #.(+ 12 word-shift)) value)
diff --git src/compiler/arm64/macros.lisp src/compiler/arm64/macros.lisp
index 83732c6a6..e1634709b 100644
--- src/compiler/arm64/macros.lisp
+++ src/compiler/arm64/macros.lisp
@@ -164,8 +164,7 @@
       (load-immediate-word tmp-tn size)
       (inst mov tmp-tn size))
   (let ((asm-routine (if (eq type 'list) 'list-alloc-tramp 'alloc-tramp)))
-    (load-inline-constant alloc-tn `(:fixup ,asm-routine :assembly-routine)))
-  (inst blr alloc-tn)
+    (invoke-asm-routine asm-routine alloc-tn))
   (inst b back-label))
 
 ;;; Leaves the untagged pointer in TMP-TN,
@@ -184,20 +183,20 @@
         (inst add result-tn tmp-tn lowtag))
       (let ((alloc (gen-label))
             #+sb-thread (tlab (if (eq type 'list) thread-cons-tlab-slot thread-mixed-tlab-slot))
-            #-sb-thread (region (if (eq type 'list) cons-region mixed-region))
+            #-sb-thread (region-offset (if (eq type 'list)
+                                           cons-region-offset
+                                           mixed-region-offset))
             (back-from-alloc (gen-label)))
         #-sb-thread
         (progn
-          ;; load-pair can't base off null-tn because the displacement
-          ;; has to be a multiple of 8
-          (load-immediate-word flag-tn region)
-          (inst ldp result-tn flag-tn (@ flag-tn 0)))
+          (loadw result-tn null-tn 0 (- nil-value-offset region-offset))
+          (loadw flag-tn null-tn 1 (- nil-value-offset region-offset)))
         #+sb-thread
         (inst ldp tmp-tn flag-tn (@ thread-tn (* n-word-bytes tlab)))
         (inst add result-tn tmp-tn (add-sub-immediate size result-tn))
         (inst cmp result-tn flag-tn)
         (inst b :hi ALLOC)
-        #-sb-thread (inst str result-tn (@ null-tn (load-store-offset (- region nil-value))))
+        #-sb-thread (inst str result-tn (@ null-tn (load-store-offset (- region-offset nil-value-offset))))
         #+sb-thread (storew result-tn thread-tn tlab)
 
         (emit-label BACK-FROM-ALLOC)
@@ -276,11 +275,16 @@
     (emit-alignment 2)))
 
 (defun generate-error-code (vop error-code &rest values)
+  (apply #'generate-error-code+ nil vop error-code values))
+
+(defun generate-error-code+ (preamble-emitter vop error-code &rest values)
   "Generate-Error-Code Error-code Value*
   Emit code for an error with the specified Error-Code and context Values."
   (assemble (:elsewhere)
     (let ((start-lab (gen-label)))
       (emit-label start-lab)
+      (when preamble-emitter
+        (funcall preamble-emitter))
       (emit-error-break vop
                         (if (eq error-code 'invalid-arg-count-error)
                             invalid-arg-count-trap
@@ -343,7 +347,7 @@
              `((:translate ,translate)))
      (:policy :fast-safe)
      (:args (object :scs (descriptor-reg))
-            (index :scs (any-reg immediate)))
+            (index :scs (any-reg unsigned-reg signed-reg immediate)))
      (:arg-types ,type tagged-num)
      (:temporary (:scs (non-descriptor-reg)
                   :unused-if (sc-is index immediate)) lip)
@@ -356,7 +360,9 @@
                                      (- (ash (+ ,offset (tn-value index)) word-shift)
                                         ,lowtag)))))
          (t
-          (inst add lip object (lsl index (- word-shift n-fixnum-tag-bits)))
+          (inst add lip object (lsl index (- word-shift (if (sc-is index any-reg)
+                                                            n-fixnum-tag-bits
+                                                            0))))
           (loadw value lip ,offset ,lowtag))))))
 
 (defmacro define-full-setter (name type offset lowtag scs el-type
@@ -366,7 +372,7 @@
              `((:translate ,translate)))
      (:policy :fast-safe)
      (:args (object :scs (descriptor-reg))
-            (index :scs (any-reg immediate))
+            (index :scs (any-reg unsigned-reg signed-reg immediate))
             (value :scs (,@scs zero)))
      (:arg-types ,type tagged-num ,el-type)
      (:temporary (:scs (non-descriptor-reg)
@@ -378,7 +384,9 @@
                                      (- (ash (+ ,offset (tn-value index)) word-shift)
                                         ,lowtag)))))
          (t
-          (inst add lip object (lsl index (- word-shift n-fixnum-tag-bits)))
+          (inst add lip object (lsl index (- word-shift (if (sc-is index any-reg)
+                                                            n-fixnum-tag-bits
+                                                            0))))
           (storew value lip ,offset ,lowtag))))))
 
 (defmacro define-partial-reffer (name type size signed offset lowtag scs
@@ -388,7 +396,7 @@
              `((:translate ,translate)))
      (:policy :fast-safe)
      (:args (object :scs (descriptor-reg))
-            (index :scs (any-reg unsigned-reg immediate)))
+            (index :scs (any-reg unsigned-reg signed-reg immediate)))
      (:arg-types ,type tagged-num)
      (:results (value :scs ,scs))
      (:result-types ,el-type)
@@ -417,9 +425,8 @@
                                                (- (* ,offset n-word-bytes) ,lowtag))))))
                  (t
                   (let ((shift ,shift))
-                    (sc-case index
-                      (any-reg
-                       (decf shift n-fixnum-tag-bits)))
+                    (when (sc-is index any-reg)
+                      (decf shift n-fixnum-tag-bits))
                     (inst add lip object (if (minusp shift)
                                              (asr index (- shift))
                                              (lsl index shift)))
@@ -439,7 +446,7 @@
       (:args ,@(when setf-p
                  value)
              (object :scs (descriptor-reg))
-             (index :scs (any-reg unsigned-reg immediate))
+             (index :scs (any-reg unsigned-reg signed-reg immediate))
              ,@(unless setf-p
                  value))
       (:arg-types ,@(when setf-p
@@ -472,9 +479,8 @@
                                                 (- (* ,offset n-word-bytes) ,lowtag))))))
                   (t
                    (let ((shift ,shift))
-                     (sc-case index
-                       (any-reg
-                        (decf shift n-fixnum-tag-bits)))
+                     (when (sc-is index any-reg)
+                       (decf shift n-fixnum-tag-bits))
                      (inst add lip object (if (minusp shift)
                                               (asr index (- shift))
                                               (lsl index shift)))
diff --git src/compiler/arm64/memory.lisp src/compiler/arm64/memory.lisp
index d754111f3..480e0bb8c 100644
--- src/compiler/arm64/memory.lisp
+++ src/compiler/arm64/memory.lisp
@@ -35,8 +35,8 @@
 (define-vop (word-index-cas)
   (:args (object :scs (descriptor-reg))
          (index :scs (any-reg))
-         (old-value :scs (any-reg descriptor-reg))
-         (new-value :scs (any-reg descriptor-reg)))
+         (old-value :scs (any-reg descriptor-reg zero))
+         (new-value :scs (any-reg descriptor-reg zero)))
   (:arg-types * tagged-num * *)
   (:temporary (:sc non-descriptor-reg) lip)
   (:results (result :scs (any-reg descriptor-reg) :from :load))
diff --git src/compiler/arm64/move.lisp src/compiler/arm64/move.lisp
index e435cad16..297605ebc 100644
--- src/compiler/arm64/move.lisp
+++ src/compiler/arm64/move.lisp
@@ -146,7 +146,8 @@
        (load-symbol y val))
       (structure-object
        (if (eq val sb-lockless:+tail+)
-           (inst add y null-tn (- sb-vm::lockfree-list-tail-value sb-vm:nil-value))
+           (inst add y null-tn (- lockfree-list-tail-value-offset
+                                  nil-value-offset))
            (bug "immediate structure-object ~S" val))))))
 
 (define-move-fun (load-number 1) (vop x y)
diff --git src/compiler/arm64/nlx.lisp src/compiler/arm64/nlx.lisp
index 94766259e..bdfee9110 100644
--- src/compiler/arm64/nlx.lisp
+++ src/compiler/arm64/nlx.lisp
@@ -303,8 +303,7 @@
       (storew temp block catch-block-entry-pc-slot)
 
       ;; Run any required UWPs.
-      (load-inline-constant tmp-tn '(:fixup unwind :assembly-routine))
-      (inst br tmp-tn)
+      (invoke-asm-routine 'unwind tmp-tn :tail t)
 
       (emit-label ENTRY-LABEL)
       (inst mov nargs 0)
diff --git src/compiler/arm64/parms.lisp src/compiler/arm64/parms.lisp
index 2859a4f58..71590e846 100644
--- src/compiler/arm64/parms.lisp
+++ src/compiler/arm64/parms.lisp
@@ -67,20 +67,12 @@
 
 ;;;; Where to put the different spaces.
 
-#+(and immobile-space darwin)
-(error "can't work because immobile text must be under 2GB")
-
-#+immobile-space
-(!gencgc-space-setup #x50000000
-                     :read-only-space-size 0
+(!gencgc-space-setup #+(or linux openbsd netbsd freebsd)
+                     #x2F0000000
+                     #+darwin #x300000000
+                     #-darwin :read-only-space-size #-darwin 0
                      :fixedobj-space-size #.(* 65536 1024)
                      :text-space-size #.(* 2 65536 1024)
-                     :dynamic-space-start #x1000000000)
-
-#-immobile-space
-(!gencgc-space-setup #+(or linux openbsd freebsd) #xF0000000
-                     #+darwin #x300000000
-                     #+netbsd #x2F0000000
                      :dynamic-space-start
                      #-darwin #x1000000000
                      #+darwin #x7003000000)
diff --git src/compiler/arm64/show.lisp src/compiler/arm64/show.lisp
index 02945a2a3..8e6acc6cc 100644
--- src/compiler/arm64/show.lisp
+++ src/compiler/arm64/show.lisp
@@ -26,9 +26,8 @@
       (when cur-nfp
         (store-stack-tn nfp-save cur-nfp))
       (move nl0 object)
-      (load-inline-constant lr '(:fixup "call_into_c" :foreign))
-      (load-inline-constant cfunc '(:fixup "debug_print" :foreign))
-      (inst blr lr)
+      (load-foreign-symbol cfunc "debug_print")
+      (invoke-foreign-routine "call_into_c" lr)
       (when cur-nfp
         (load-stack-tn cur-nfp nfp-save))
       (move result nl0))))
diff --git src/compiler/arm64/target-insts.lisp src/compiler/arm64/target-insts.lisp
index 322aceb70..f507c82f1 100644
--- src/compiler/arm64/target-insts.lisp
+++ src/compiler/arm64/target-insts.lisp
@@ -417,6 +417,7 @@
                             (ash (cadr value) 2))
                     (ash value 2)))
          (address (+ value (dstate-cur-addr dstate))))
+    (maybe-note-assembler-routine address nil dstate)
     ;; LRA pointer
     (if (= (logand address lowtag-mask) other-pointer-lowtag)
         (- address (- other-pointer-lowtag n-word-bytes))
diff --git src/compiler/arm64/type-vops.lisp src/compiler/arm64/type-vops.lisp
index 4b540f629..a4d5e7171 100644
--- src/compiler/arm64/type-vops.lisp
+++ src/compiler/arm64/type-vops.lisp
@@ -195,8 +195,11 @@
 (define-vop (unsigned-byte-64-p type-predicate)
   (:translate unsigned-byte-64-p)
   (:generator 10
-    (let ((fixnum-p (types-equal-or-intersect (tn-ref-type args) (specifier-type 'fixnum)))
-          (other-pointer-p (fixnum-or-other-pointer-tn-ref-p args t)))
+    (let* ((fixnum-p (types-equal-or-intersect (tn-ref-type args) (specifier-type 'fixnum)))
+           (other-pointer-p (fixnum-or-other-pointer-tn-ref-p args t))
+           (not-signed-byte-64-p (not (types-equal-or-intersect (tn-ref-type args) (specifier-type 'signed-word))))
+           (unsigned-p (or not-signed-byte-64-p
+                           (not (types-equal-or-intersect (tn-ref-type args) (specifier-type '(integer * -1)))))))
       (multiple-value-bind (yep nope)
           (if not-p
               (values not-target target)
@@ -210,33 +213,45 @@
                 (fixnum-p
                  (move temp value)))
           (when fixnum-p
-            (%test-fixnum temp nil fixnum nil))
+            (%test-fixnum temp nil (if unsigned-p
+                                       yep
+                                       fixnum) nil))
           (unless other-pointer-p
             (inst cmp (32-bit-reg temp) other-pointer-lowtag)
             (inst b :ne nope))
           ;; Get the header.
           (loadw temp value 0 other-pointer-lowtag)
-          ;; Is it one?
-          (inst cmp temp (+ (ash 1 n-widetag-bits) bignum-widetag))
-          (inst b :eq single-word)
+          (unless not-signed-byte-64-p
+            ;; Is it one?
+            (inst cmp temp (+ (ash 1 n-widetag-bits) bignum-widetag))
+            (inst b :eq (if unsigned-p
+                            yep
+                            single-word)))
           ;; If it's other than two, it can't be an (unsigned-byte 64)
           (inst cmp temp (+ (ash 2 n-widetag-bits) bignum-widetag))
           (inst b :ne nope)
           ;; Get the second digit.
           (loadw temp value (1+ bignum-digits-offset) other-pointer-lowtag)
           ;; All zeros, it's an (unsigned-byte 64).
-          (inst cbz temp yep)
-          (inst b nope)
+          (cond (unsigned-p
+                 (if not-p
+                     (inst cbnz temp target)
+                     (inst cbz temp target)))
+                (t
+                 (inst cbz temp yep)
+                 (inst b nope)))
 
           single-word
-          ;; Get the single digit.
-          (loadw temp value bignum-digits-offset other-pointer-lowtag)
+          (unless unsigned-p
+            ;; Get the single digit.
+            (loadw temp value bignum-digits-offset other-pointer-lowtag))
 
           ;; positive implies (unsigned-byte 64).
           fixnum
-          (if not-p
-              (inst tbnz* temp (1- n-word-bits) target)
-              (inst tbz* temp (1- n-word-bits) target))))
+          (unless unsigned-p
+            (if not-p
+                (inst tbnz* temp (1- n-word-bits) target)
+                (inst tbz* temp (1- n-word-bits) target)))))
       (values))
     NOT-TARGET))
 
@@ -598,7 +613,7 @@
   (:results (r :scs (unsigned-reg)))
   (:result-types unsigned-num)
   (:generator 1
-    (unless (other-pointer-tn-ref-p args)
+    (unless (other-pointer-tn-ref-p args (not null-label))
       (when null-label
         (inst cmp value null-tn)
         (inst b :eq null-label))
diff --git src/compiler/arm64/vm.lisp src/compiler/arm64/vm.lisp
index abcf39260..7bf0e126e 100644
--- src/compiler/arm64/vm.lisp
+++ src/compiler/arm64/vm.lisp
@@ -12,7 +12,7 @@
 (in-package "SB-VM")
 
 (defconstant-eqx +fixup-kinds+ #(:absolute :cond-branch :uncond-branch :layout-id
-                                 :ldr-str :move-wide)
+                                 :pc-relative :pc-relative-ldr-str :ldr-str :move-wide)
   #'equalp)
 
 
@@ -329,8 +329,7 @@
        (cond
          ((or (valid-funtype `((constant-arg (mod ,n-word-bits)) signed-word) '*)
               (valid-funtype `((constant-arg (mod ,n-word-bits)) word) '*))
-          (values :transform '(lambda (index integer)
-                               (%logbitp integer index))))
+          (values :direct nil))
          (t (values :default nil))))
       (%ldb
        (flet ((validp (type)
@@ -348,8 +347,7 @@
                                     n-word-bits)))))))
          (if (or (validp 'word)
                  (validp 'signed-word))
-             (values :transform '(lambda (size posn integer)
-                                  (%%ldb integer size posn)))
+             (values :direct nil)
              (values :default nil))))
       (%dpb
        (flet ((validp (type result-type)
@@ -360,14 +358,22 @@
                                result-type)))
          (if (or (validp 'signed-word 'signed-word)
                  (validp 'word 'word))
-             (values :transform '(lambda (newbyte size posn integer)
-                                  (%%dpb newbyte size posn integer)))
+             (values :direct nil)
              (values :default nil))))
       (signum
        (if (or (valid-funtype '(signed-word) '*)
                (valid-funtype '(word) '*))
            (values :direct nil)
            (values :default nil)))
+      (truncate
+       (destructuring-bind (n &optional d) (sb-c::basic-combination-args node)
+         (if (and d
+                  (constant-lvar-p d)
+                  (power-of-two-p (lvar-value d))
+                  (and (csubtypep (sb-c::lvar-type n) (specifier-type 'signed-word))
+                       (not (csubtypep (sb-c::lvar-type n) (specifier-type 'word)))))
+             (values :direct nil)
+             (values :default nil))))
       (t (values :default nil)))))
 
 (defun primitive-type-indirect-cell-type (ptype)
@@ -399,4 +405,5 @@
         bic-encode-immediate
         bic-fixnum-encode-immediate
         logical-immediate-or-word-mask
-        sb-arm64-asm::ldr-str-offset-encodable))
+        sb-arm64-asm::ldr-str-offset-encodable
+        power-of-two-p))
diff --git src/compiler/array-tran.lisp src/compiler/array-tran.lisp
index 2900953cf..f33fb23a5 100644
--- src/compiler/array-tran.lisp
+++ src/compiler/array-tran.lisp
@@ -996,7 +996,7 @@
                                  :initial-element
                                  :initial-contents))))
   (let ((fp-type (and fill-pointer
-                      (lvar-type fill-pointer)) ))
+                      (lvar-type fill-pointer))))
     (when (and fp-type
                (csubtypep fp-type (specifier-type '(or index (eql t)))))
       (let* ((dims (and (constant-lvar-p dims)
@@ -1016,73 +1016,90 @@
                               length))))))
   (macrolet ((maybe-arg (arg)
                `(and ,arg `(,,(keywordicate arg) ,',arg))))
-    (let* ((eltype (cond ((not element-type) t)
-                         ((not (constant-lvar-p element-type))
-                          (give-up-ir1-transform
-                           "ELEMENT-TYPE is not constant."))
-                         (t
-                          (lvar-value element-type))))
-           (eltype-type (ir1-transform-specifier-type eltype))
-           (saetp (if (unknown-type-p eltype-type)
-                      (give-up-ir1-transform
-                       "ELEMENT-TYPE ~s is not a known type"
-                       eltype-type)
-                      (find eltype-type
-                            sb-vm:*specialized-array-element-type-properties*
-                            :key #'sb-vm:saetp-ctype
-                            :test #'csubtypep)))
-           (creation-form `(%make-array
-                            dims
-                            ,(if saetp
-                                 (sb-vm:saetp-typecode saetp)
-                                 (give-up-ir1-transform))
-                            ,(sb-vm:saetp-n-bits-shift saetp)
-                            ,@(maybe-arg initial-contents)
-                            ,@(maybe-arg adjustable)
-                            ,@(maybe-arg fill-pointer)
-                            ,@(maybe-arg displaced-to)
-                            ,@(maybe-arg displaced-index-offset))))
-      (cond ((not initial-element) creation-form)
-            ;; with ubsan the call to %MAKE-ARRAY needs to see the :INITIAL-ELEMENT
-            ;; even if it looks like the default, otherwise %MAKE-ARRAY reserves the right
-            ;; to scribble on the array. Same for allocators that don't prezero
-            #-ubsan
-            ((and (constant-lvar-p initial-element)
-                  (eql (lvar-value initial-element)
-                       (sb-vm:saetp-initial-element-default saetp)))
-             creation-form)
-            (t
-             ;; error checking for target, disabled on the host because
-             ;; (CTYPE-OF #\Null) is not possible.
-             #-sb-xc-host
-             (when (constant-lvar-p initial-element)
-               (let ((value (lvar-value initial-element)))
-                 (cond
-                   ((not (ctypep value (sb-vm:saetp-ctype saetp)))
-                    ;; this case will cause an error at runtime, so we'd
-                    ;; better WARN about it now.
-                    (warn 'array-initial-element-mismatch
-                          :format-control "~@<~S is not a ~S (which is the ~
+    (block nil
+      (let* ((eltype (cond ((not element-type) t)
+                           ((not (constant-lvar-p element-type))
+                            (let ((uses (lvar-uses element-type)))
+                              (when (splice-fun-args element-type 'array-element-type 1)
+                                (return
+                                  `(multiple-value-bind (widetag shift)
+                                       (with-source-path ,(node-source-path uses)
+                                         (sb-vm::array-underlying-widetag-and-shift element-type))
+                                     (%make-array
+                                      dims
+                                      widetag
+                                      shift
+                                      ,@(maybe-arg initial-element)
+                                      ,@(maybe-arg initial-contents)
+                                      ,@(maybe-arg adjustable)
+                                      ,@(maybe-arg fill-pointer)
+                                      ,@(maybe-arg displaced-to)
+                                      ,@(maybe-arg displaced-index-offset))))))
+                            (give-up-ir1-transform
+                             "ELEMENT-TYPE is not constant."))
+                           (t
+                            (lvar-value element-type))))
+             (eltype-type (ir1-transform-specifier-type eltype))
+             (saetp (if (unknown-type-p eltype-type)
+                        (give-up-ir1-transform
+                         "ELEMENT-TYPE ~s is not a known type"
+                         eltype-type)
+                        (find eltype-type
+                              sb-vm:*specialized-array-element-type-properties*
+                              :key #'sb-vm:saetp-ctype
+                              :test #'csubtypep)))
+             (creation-form `(%make-array
+                              dims
+                              ,(if saetp
+                                   (sb-vm:saetp-typecode saetp)
+                                   (give-up-ir1-transform))
+                              ,(sb-vm:saetp-n-bits-shift saetp)
+                              ,@(maybe-arg initial-contents)
+                              ,@(maybe-arg adjustable)
+                              ,@(maybe-arg fill-pointer)
+                              ,@(maybe-arg displaced-to)
+                              ,@(maybe-arg displaced-index-offset))))
+        (cond ((not initial-element) creation-form)
+              ;; with ubsan the call to %MAKE-ARRAY needs to see the :INITIAL-ELEMENT
+              ;; even if it looks like the default, otherwise %MAKE-ARRAY reserves the right
+              ;; to scribble on the array. Same for allocators that don't prezero
+              #-ubsan
+              ((and (constant-lvar-p initial-element)
+                    (eql (lvar-value initial-element)
+                         (sb-vm:saetp-initial-element-default saetp)))
+               creation-form)
+              (t
+               ;; error checking for target, disabled on the host because
+               ;; (CTYPE-OF #\Null) is not possible.
+               #-sb-xc-host
+               (when (constant-lvar-p initial-element)
+                 (let ((value (lvar-value initial-element)))
+                   (cond
+                     ((not (ctypep value (sb-vm:saetp-ctype saetp)))
+                      ;; this case will cause an error at runtime, so we'd
+                      ;; better WARN about it now.
+                      (warn 'array-initial-element-mismatch
+                            :format-control "~@<~S is not a ~S (which is the ~
                                          ~S of ~S).~@:>"
-                          :format-arguments
-                          (list
-                           value
-                           (type-specifier (sb-vm:saetp-ctype saetp))
-                           'upgraded-array-element-type
-                           eltype)))
-                   ((multiple-value-bind (typep surep)
-                        (ctypep value eltype-type)
-                      (and (not typep) surep))
-                    ;; This case will not cause an error at runtime, but
-                    ;; it's still worth STYLE-WARNing about.
-                    (compiler-style-warn 'initial-element-mismatch-style-warning
-                                         :format-control "~S is not a ~S."
-                                         :format-arguments (list value eltype))))))
-             `(let ((array ,creation-form))
-                (multiple-value-bind (vector)
-                    (%data-vector-and-index array 0)
-                  (fill vector (the ,(sb-vm:saetp-specifier saetp) initial-element)))
-                array))))))
+                            :format-arguments
+                            (list
+                             value
+                             (type-specifier (sb-vm:saetp-ctype saetp))
+                             'upgraded-array-element-type
+                             eltype)))
+                     ((multiple-value-bind (typep surep)
+                          (ctypep value eltype-type)
+                        (and (not typep) surep))
+                      ;; This case will not cause an error at runtime, but
+                      ;; it's still worth STYLE-WARNing about.
+                      (compiler-style-warn 'initial-element-mismatch-style-warning
+                                           :format-control "~S is not a ~S."
+                                           :format-arguments (list value eltype))))))
+               `(let ((array ,creation-form))
+                  (multiple-value-bind (vector)
+                      (%data-vector-and-index array 0)
+                    (fill vector (the ,(sb-vm:saetp-specifier saetp) initial-element)))
+                  array)))))))
 
 ;;; The list type restriction does not ensure that the result will be a
 ;;; multi-dimensional array. But the lack of adjustable, fill-pointer,
diff --git src/compiler/checkgen.lisp src/compiler/checkgen.lisp
index 61cb58553..a75a9fd26 100644
--- src/compiler/checkgen.lisp
+++ src/compiler/checkgen.lisp
@@ -237,30 +237,33 @@
          ;; deemed unreachable?
          (and
           (almost-immediately-used-p lvar cast)
-
           (cond ((and (lvar-fun-is (combination-fun dest)
                                    '(hairy-data-vector-set/check-bounds
                                      hairy-data-vector-ref/check-bounds
                                      hairy-data-vector-ref
                                      hairy-data-vector-set))
-                      (eql (car (combination-args dest))
-                           lvar))
-                 ;; These functions work on all arrays, but the error
-                 ;; message is about vectors, which is used more frequently.
-                 (csubtypep (specifier-type 'vector)
-                            (single-value-type (cast-type-to-check cast))))
+                      (eq (car (combination-args dest)) lvar)
+                      (type= (specifier-type 'vector)
+                             (single-value-type (cast-type-to-check cast))))
+                 (change-full-call dest
+                                   (getf '(hairy-data-vector-set/check-bounds vector-hairy-data-vector-set/check-bounds
+                                           hairy-data-vector-ref/check-bounds vector-hairy-data-vector-ref/check-bounds
+                                           hairy-data-vector-ref vector-hairy-data-vector-ref
+                                           hairy-data-vector-set vector-hairy-data-vector-set)
+                                         (lvar-fun-name (combination-fun dest) t))))
                 #+(or arm64 x86-64)
-                ((lvar-fun-is (combination-fun dest)
-                              '(values-list)))
+                ((lvar-fun-is (combination-fun dest) '(values-list)))
                 ;; Not great
-                ((lvar-fun-is (combination-fun dest)
-                              '(%%primitive))
+                ((lvar-fun-is (combination-fun dest) '(%%primitive))
                  (destructuring-bind (vop &rest args) (combination-args dest)
                    (and (constant-lvar-p vop)
-                        (memq (vop-info-name (lvar-value vop)) '(sb-vm::overflow+t
-                                                                 sb-vm::overflow-t
-                                                                 sb-vm::overflow*t))
-                        (eq lvar (car args)))))
+                        (let ((name (vop-info-name (lvar-value vop))))
+                          (or (and (memq name '(sb-vm::overflow+t
+                                                sb-vm::overflow-t
+                                                sb-vm::overflow*t))
+                                   (eq lvar (car args)))
+                              (and (memq name '(sb-vm::overflow-t-y))
+                                   (eq lvar (cadr args))))))))
                 (t
                  (values-subtypep (lvar-externally-checkable-type lvar)
                                   (cast-type-to-check cast))))))))
diff --git src/compiler/codegen.lisp src/compiler/codegen.lisp
index bea6e1e8a..4e25f5a9b 100644
--- src/compiler/codegen.lisp
+++ src/compiler/codegen.lisp
@@ -232,91 +232,6 @@
       (dovector (constant (sb-vm:sort-inline-constants constants) t)
         (sb-vm:emit-inline-constant section (car constant) (cdr constant))))))
 
-;;; If a constant is already loaded into a register use that register.
-(defun optimize-constant-loads (component)
-  (let* ((register-sb (sb-or-lose 'sb-vm::registers))
-         (loaded-constants
-           (make-array (sb-size register-sb)
-                       :initial-element nil)))
-    (do-ir2-blocks (block component)
-      (fill loaded-constants nil)
-      (do ((vop (ir2-block-start-vop block) (vop-next vop)))
-          ((null vop))
-        (labels ((register-p (tn)
-                   (and (tn-p tn)
-                        (not (eq (tn-kind tn) :unused))
-                        (eq (sc-sb (tn-sc tn)) register-sb)))
-                 (constant-eql-p (a b)
-                   (or (eq a b)
-                       (and (eq (sc-name (tn-sc a)) 'constant)
-                            (eq (tn-sc a) (tn-sc b))
-                            (eql (tn-offset a) (tn-offset b)))))
-                 (remove-constant (tn)
-                   (when (register-p tn)
-                     (setf (svref loaded-constants (tn-offset tn)) nil)))
-                 (remove-written-tns ()
-                   (cond ((memq (vop-info-save-p (vop-info vop))
-                                '(t :force-to-stack))
-                          (fill loaded-constants nil))
-                         (t
-                          (do ((ref (vop-results vop) (tn-ref-across ref)))
-                              ((null ref))
-                            (remove-constant (tn-ref-tn ref))
-                            (remove-constant (tn-ref-load-tn ref)))
-                          (do ((ref (vop-temps vop) (tn-ref-across ref)))
-                              ((null ref))
-                            (remove-constant (tn-ref-tn ref)))
-                          (do ((ref (vop-args vop) (tn-ref-across ref)))
-                              ((null ref))
-                            (remove-constant (tn-ref-load-tn ref))))))
-                 (compatible-scs-p (a b)
-                   (or (eql a b)
-                       (and (eq (sc-name a) 'sb-vm::control-stack)
-                            (eq (sc-name b) 'sb-vm::descriptor-reg))
-                       (and (eq (sc-name b) 'sb-vm::control-stack)
-                            (eq (sc-name a) 'sb-vm::descriptor-reg))))
-                 (find-constant-tn (constant sc)
-                   (loop for (saved-constant . tn) across loaded-constants
-                         when (and saved-constant
-                                   (constant-eql-p saved-constant constant)
-                                   (compatible-scs-p (tn-sc tn) sc))
-                         return tn)))
-          (case (vop-name vop)
-            ((move sb-vm::move-arg)
-             (let* ((args (vop-args vop))
-                    (results (vop-results vop))
-                    (x (tn-ref-tn args))
-                    (x-load-tn (tn-ref-load-tn args))
-                    (y (tn-ref-tn results))
-                    constant)
-               (cond ((or (eq (sc-name (tn-sc x)) 'null)
-                          (not (eq (tn-kind x) :constant)))
-                      (remove-written-tns))
-                     ((setf constant (find-constant-tn x (tn-sc y)))
-                      (when (register-p y)
-                        (setf (svref loaded-constants (tn-offset y))
-                              (cons x y)))
-                      ;; XOR is more compact on x86oids and many
-                      ;; RISCs have a zero register
-                      (unless (and (constant-p (tn-leaf x))
-                                   (eql (tn-value x) 0)
-                                   (register-p y))
-                        (change-tn-ref-tn args constant)
-                        (setf (tn-ref-load-tn args) nil)))
-                     ((register-p y)
-                      (setf (svref loaded-constants (tn-offset y))
-                            (cons x y)))
-                     ((and x-load-tn
-                           (or (not (tn-ref-load-tn results))
-                               (location= (tn-ref-load-tn results)
-                                          x-load-tn)))
-                      (setf (svref loaded-constants (tn-offset x-load-tn))
-                            (cons x x-load-tn)))
-                     (t
-                      (remove-written-tns)))))
-            (t
-             (remove-written-tns))))))))
-
 ;; Collect "static" count of number of times each vop is employed.
 ;; (as opposed to "dynamic" - how many times its code is hit at runtime)
 (defglobal *static-vop-usage-counts* nil)
diff --git src/compiler/ctype.lisp src/compiler/ctype.lisp
index 3797b6609..8a3699cfa 100644
--- src/compiler/ctype.lisp
+++ src/compiler/ctype.lisp
@@ -58,11 +58,13 @@
 
 ;;; Signal a warning if appropriate and set *FOO-DETECTED*.
 (defun note-lossage (format-string &rest format-args)
+  (declare (explicit-check))
   (setq *lossage-detected* t)
   (when *lossage-fun*
     (apply *lossage-fun* format-string format-args))
   (values))
 (defun note-unwinnage (format-string &rest format-args)
+  (declare (explicit-check))
   (setq *unwinnage-detected* t)
   (when *unwinnage-fun*
     (apply *unwinnage-fun* format-string format-args))
diff --git src/compiler/deftype.lisp src/compiler/deftype.lisp
deleted file mode 100644
index b3fe09d88..000000000
--- src/compiler/deftype.lisp
+++ /dev/null
@@ -1,100 +0,0 @@
-;;;; This software is part of the SBCL system. See the README file for
-;;;; more information.
-;;;;
-;;;; This software is derived from the CMU CL system, which was
-;;;; written at Carnegie Mellon University and released into the
-;;;; public domain. The software is in the public domain and is
-;;;; provided with absolutely no warranty. See the COPYING and CREDITS
-;;;; files for more information.
-
-(in-package "SB-IMPL")
-
-(defun constant-type-expander (name expansion)
-  (declare (optimize safety))
-  ;; Dummy implementation of SET-CLOSURE-NAME for the host.
-  (flet (#+sb-xc-host (set-closure-name (f junk name) (declare (ignore junk name)) f))
-    (set-closure-name
-     (lambda (whole)
-       ;; NB: It does not in general work to set the lambda-list of a closure,
-       ;; but all constant-type-expanders have NIL as the lambda-list
-       ;; because if they didn't, they wouldn't be constant.
-       (declare (sb-c::lambda-list ()))
-       (if (cdr whole)
-           (error 'sb-kernel::arg-count-error
-                  :kind 'deftype :name (car whole) :args (cdr whole)
-                  :lambda-list '() :minimum 0 :maximum 0)
-           expansion))
-     t
-     `(type-expander ,name))))
-
-(defmacro sb-xc:deftype (name lambda-list &body body &environment env)
-  "Define a new type, with syntax like DEFMACRO."
-  (declare (ignore env))
-  (check-designator name 'deftype)
-  (multiple-value-bind (expander-form doc source-location-form)
-      (multiple-value-bind (forms decls doc) (parse-body body t)
-        (acond ((and (not lambda-list) (not decls)
-                    (let ((expr `(progn ,@forms)))
-                      ;; While CONSTANTP works early, %MACROEXPAND does not,
-                      ;; so we can't pass ENV because it'd try to macroexpand.
-                      (if (constantp expr) expr)))
-                #-sb-xc-host
-                (check-deprecated-type (constant-form-value it))
-                (values `(constant-type-expander ',name ,it) doc
-                        '(sb-c:source-location)))
-               (t
-                ;; FIXME: it seems non-ANSI-compliant to pretend every lexenv
-                ;; is nil. See also lp#309140.
-                ;; Source-location and docstring are associated with the lambda
-                ;; so we don't store them separately.
-                (make-macro-lambda `(type-expander ,name)
-                                   lambda-list body 'deftype name
-                                   :doc-string-allowed :external
-                                   :environment :ignore))))
-    ;; Maybe kill docstring, but only under the cross-compiler.
-    #+(and (not sb-doc) sb-xc-host) (setq doc nil)
-    `(progn
-       (eval-when (:compile-toplevel :load-toplevel :execute)
-         (%deftype ',name ,expander-form ,source-location-form
-                   ,@(when doc `(,doc)))))))
-
-(defun %deftype (name expander source-location &optional doc)
-  (declare (ignorable doc))
-  (with-single-package-locked-error
-      (:symbol name "defining ~A as a type specifier"))
-  (ecase (info :type :kind name)
-    (:primitive
-     ;; Detecting illegal redefinition in the cross-compiler
-     ;; adds unnecessary complexity, so don't bother.
-     #-sb-xc-host
-     (when *type-system-initialized*
-       (error "illegal to redefine standard type: ~S" name)))
-    (:instance
-     (warn "The class ~S is being redefined to be a DEFTYPE." name)
-     (undeclare-structure (find-classoid name) t)
-     ;; FIXME: shouldn't this happen only at eval-time?
-     (setf (classoid-cell-classoid (find-classoid-cell name :create t)) nil)
-     (clear-info :type :compiler-layout name)
-     (setf (info :type :kind name) :defined))
-    (:defined
-     ;; Note: It would be nice to warn here when a type is being
-     ;; incompatibly redefined, but it's hard to tell, since type
-     ;; expanders are often function objects which can't easily be
-     ;; compared for equivalence. And just warning on redefinition
-     ;; isn't good, since DEFTYPE necessarily does its thing once at
-     ;; compile time and again at load time, so that it's very common
-     ;; and normal for types to be defined twice. So since there
-     ;; doesn't seem to be anything simple and obvious to do, and
-     ;; since mistakenly redefining a type isn't a common error
-     ;; anyway, we just don't worry about trying to warn about it.
-     )
-    ((nil :forthcoming-defclass-type)
-     (setf (info :type :kind name) :defined)))
-  (setf (info :type :expander name) expander)
-  (when source-location
-    (setf (info :type :source-location name) source-location))
-  #-sb-xc-host
-  (when doc
-    (setf (documentation name 'type) doc))
-  (sb-c::%note-type-defined name)
-  name)
diff --git src/compiler/fndb.lisp src/compiler/fndb.lisp
index 3b818f8d1..376c9cdd5 100644
--- src/compiler/fndb.lisp
+++ src/compiler/fndb.lisp
@@ -1311,7 +1311,7 @@
    (:start (inhibit-flushing index 0))
    (:end (inhibit-flushing sequence-end nil)))
   simple-string (flushable)
-  :derive-type (sequence-result-nth-arg 0 :preserve-dimensions t))
+  :derive-type (sequence-result-nth-arg 0 :preserve-dimensions t :string-designator t))
 
 (defknown (nstring-upcase nstring-downcase nstring-capitalize)
   ((modifying string) &key (:start index) (:end sequence-end))
@@ -1953,6 +1953,12 @@
 (defknown hairy-data-vector-set (array index t) t (no-verify-arg-count))
 (defknown hairy-data-vector-ref/check-bounds (array index) t (foldable no-verify-arg-count))
 (defknown hairy-data-vector-set/check-bounds (array index t) t (no-verify-arg-count))
+
+(defknown vector-hairy-data-vector-ref (vector index) t (foldable flushable no-verify-arg-count))
+(defknown vector-hairy-data-vector-set (vector index t) t (no-verify-arg-count))
+(defknown vector-hairy-data-vector-ref/check-bounds (vector index) t (foldable no-verify-arg-count))
+(defknown vector-hairy-data-vector-set/check-bounds (vector index t) t (no-verify-arg-count))
+
 (defknown %caller-frame () t (flushable))
 (defknown %caller-pc () system-area-pointer (flushable))
 (defknown %with-array-data (array index (or index null))
@@ -2108,7 +2114,7 @@
 (defknown %program-error (&optional t &rest t) nil ())
 (defknown compiler-error (t &rest t) nil ())
 (defknown (compiler-warn compiler-style-warn) (t &rest t) (values) ())
-(defknown (compiler-mumble note-lossage note-unwinnage) (string &rest t) (values) ())
+(defknown (compiler-mumble note-lossage note-unwinnage) (format-control &rest t) (values) ())
 (defknown (compiler-notify maybe-compiler-notify) ((or format-control symbol) &rest t)
   (values)
   ())
@@ -2240,7 +2246,13 @@
   (defknown round-single (single-float #1#) single-float
       (foldable flushable movable always-translatable)))
 
-(defknown (overflow* overflow+ overflow-)
+(defknown (overflow* overflow+ overflow-
+           overflow-ash)
   (integer integer t)
   integer
   (movable always-translatable))
+
+(defknown overflow-negate
+  (integer t)
+  integer
+  (movable always-translatable))
diff --git src/compiler/generic/early-objdef.lisp src/compiler/generic/early-objdef.lisp
index 73c72bda6..65cb4fe97 100644
--- src/compiler/generic/early-objdef.lisp
+++ src/compiler/generic/early-objdef.lisp
@@ -290,6 +290,14 @@
 ;;; on the heap.
 (defconstant no-tls-value-marker most-positive-word)
 
+(defmacro unbound-marker-bits ()
+  ;; By having unbound-marker-bits appear to be a valid pointer into static
+  ;; space, it admits some optimizations that might "dereference" the value
+  ;; before checking the widetag.
+  ;; Architectures other than x86-64 do not take that liberty.
+  #+x86-64 (logior (+ sb-vm:static-space-start #x100) unbound-marker-widetag)
+  #-x86-64 unbound-marker-widetag)
+
 ;;; Map each widetag symbol to a string to go in 'tagnames.h'.
 ;;; I didn't want to mess with the formatting of the table above.
 (defparameter *widetag-string-alist*
@@ -451,13 +459,12 @@
   #-sb-thread
   (defglobal function-layout 0))        ; set by genesis
 
-;;; MIXED-REGION is at the beginning of static space
-;;; Be sure to update "#define main_thread_mixed_region" etc
-;;; if these get changed.
+;;; These regions occupy the initial words of static space.
 #-sb-thread
-(progn (defconstant mixed-region static-space-start)
-       (defconstant cons-region (+ mixed-region (* 3 n-word-bytes)))
-       (defconstant boxed-region (+ cons-region (* 3 n-word-bytes))))
+(progn
+  (defconstant mixed-region-offset 0)
+  (defconstant cons-region-offset (* 3 n-word-bytes))
+  (defconstant boxed-region-offset (* 6 n-word-bytes)))
 
 #|
 ;; Run this in the SB-VM package once for each target feature combo.
diff --git src/compiler/generic/genesis.lisp src/compiler/generic/genesis.lisp
index e12f93341..b46ff4544 100644
--- src/compiler/generic/genesis.lisp
+++ src/compiler/generic/genesis.lisp
@@ -1706,11 +1706,10 @@ core and return a descriptor to it."
 ;;; It might be nice to put NIL on a readonly page by itself to prevent unsafe
 ;;; code from destroying the world with (RPLACx nil 'kablooey)
 (defun make-nil-descriptor ()
-  ;; 10 words prior to NIL is an array of three 'struct alloc_region'.
-  ;; The lisp objects begin at STATIC_SPACE_OBJECTS_START.
-  ;; See also (DEFCONSTANT NIL-VALUE) in early-objdef.
-  #+(and gencgc (not sb-thread)) (gspace-claim-n-words *static* 10)
-  #+64-bit (setf (gspace-free-word-index *static*) (/ 256 sb-vm:n-word-bytes))
+  (gspace-claim-n-words *static* (/ (- sb-vm::nil-value-offset
+                                       (* 2 sb-vm:n-word-bytes)
+                                       sb-vm:list-pointer-lowtag)
+                                    sb-vm:n-word-bytes))
   (let* ((des (allocate-otherptr *static* (1+ sb-vm:symbol-size) 0))
          (nil-val (make-descriptor (+ (descriptor-bits des)
                                       (* 2 sb-vm:n-word-bytes)
@@ -1753,6 +1752,8 @@ core and return a descriptor to it."
         (write-wordindexed des 1 (make-other-immediate-descriptor (1- sb-vm:symbol-size)
                                                                   sb-vm:symbol-widetag))
         (write-wordindexed des (+ 1 sb-vm:symbol-value-slot) nil-val)
+        #+relocatable-static-space
+        (write-wordindexed des (+ 1 sb-vm::symbol-unused-slot) nil-val)
         (write-wordindexed des (+ 1 sb-vm:symbol-hash-slot) nil-val)
         (write-wordindexed des (+ 1 sb-vm:symbol-info-slot) initial-info)
         (write-wordindexed des (+ 1 sb-vm:symbol-name-slot) name)
@@ -2941,7 +2942,10 @@ Legal values for OFFSET are -4, -8, -12, ..."
                    (error "Space overlap: ~A with ~A" space (car other))))
                (push (cons space type) types))))
       (check sb-vm:read-only-space-start sb-vm:read-only-space-end :read-only)
+      #-relocatable-static-space
       (check sb-vm:static-space-start sb-vm:static-space-end :static)
+      #+relocatable-static-space
+      (check sb-vm:static-space-start (+ sb-vm:static-space-start sb-vm::static-space-size) :static)
       #+gencgc
       (check sb-vm:dynamic-space-start
              (+ sb-vm:dynamic-space-start sb-vm::default-dynamic-space-size)
@@ -3084,7 +3088,8 @@ Legal values for OFFSET are -4, -8, -12, ..."
                    sb-vm:dsd-raw-type-mask
                    sb-vm:short-header-max-words
                    sb-vm:array-flags-position
-                   sb-vm:array-rank-position))
+                   sb-vm:array-rank-position
+                   sb-vm::nil-value-offset))
         (record (c-symbol-name c) -1 c ""))
       ;; More symbols that doesn't fit into the pattern above.
       (dolist (c '(sb-impl::+magic-hash-vector-value+
@@ -3092,9 +3097,12 @@ Legal values for OFFSET are -4, -8, -12, ..."
                    ;; but one's a vector header bit, the other a layout flag bit.
                    sb-vm::+vector-alloc-mixed-region-bit+
                    sb-kernel::+strictly-boxed-flag+
-                   sb-vm::nil-symbol-slots-start
-                   sb-vm::nil-symbol-slots-end
-                   sb-vm::static-space-objects-start))
+                   #-sb-thread sb-vm::mixed-region-offset
+                   #-sb-thread sb-vm::cons-region-offset
+                   #-sb-thread sb-vm::boxed-region-offset
+                   sb-vm::nil-symbol-slots-offset
+                   sb-vm::nil-symbol-slots-end-offset
+                   sb-vm::static-space-objects-offset))
         (record (c-symbol-name c) 7 #| arb |# c +c-literal-64bit+)))
     ;; Sort by <priority, value, alpha> which is TOO COMPLICATED imho.
     ;; Priority and then alphabetical would suffice.
@@ -3433,19 +3441,28 @@ lispobj symbol_package(struct symbol*);~%" (genesis-header-prefix))
             (let ((val (if (listp binding) (second binding))))
               (if (eq val 't) "LISP_T" val)))))
 
+(defun maybe-relativize (value)
+  #-relocatable-static-space value
+  #+relocatable-static-space (- value sb-vm:static-space-start))
+
 (defun write-static-symbols (stream)
   (dolist (symbol (cons nil (coerce sb-vm:+static-symbols+ 'list)))
-    (format stream "#define ~A LISPOBJ(0x~X)~%"
+    (format stream "#define ~A LISPOBJ(~:[~;STATIC_SPACE_START + ~]0x~X)~%"
             ;; FIXME: It would be nice not to need to strip anything
             ;; that doesn't get stripped always by C-SYMBOL-NAME.
             (if (eq symbol 't) "LISP_T" (c-symbol-name symbol "%*.!"))
-            (if *static*                ; if we ran GENESIS
-              ;; We actually ran GENESIS, use the real value.
-              (descriptor-bits (cold-intern symbol))
-              (+ sb-vm:nil-value
-                 (if symbol (sb-vm:static-symbol-offset symbol) 0)))))
-  (format stream "#define LFLIST_TAIL_ATOM LISPOBJ(0x~X)~%"
-          (descriptor-bits *lflist-tail-atom*))
+            #-relocatable-static-space nil
+            #+relocatable-static-space t
+            (maybe-relativize
+             (if *static*               ; if we ran GENESIS
+                 ;; We actually ran GENESIS, use the real value.
+                 (descriptor-bits (cold-intern symbol))
+                 (+ sb-vm:nil-value
+                    (if symbol (sb-vm:static-symbol-offset symbol) 0))))))
+  (format stream "#define LFLIST_TAIL_ATOM LISPOBJ(~:[~;STATIC_SPACE_START + ~]0x~X)~%"
+          #-relocatable-static-space nil
+          #+relocatable-static-space t
+          (maybe-relativize (descriptor-bits *lflist-tail-atom*)))
   #+sb-thread
   (dolist (binding sb-vm::per-thread-c-interface-symbols)
     (let* ((symbol (car (ensure-list binding)))
@@ -3461,7 +3478,7 @@ lispobj symbol_package(struct symbol*);~%" (genesis-header-prefix))
           "FUNCTION"
           "FIXEDOBJ"
           (- (cold-layout-descriptor-bits 'function)
-                        (gspace-byte-address (symbol-value *cold-layout-gspace*))))
+             (gspace-byte-address (symbol-value *cold-layout-gspace*))))
   ;; For immobile code on x86-64, define a constant for the address of the vector of
   ;; C-callable fdefns, and then fdefns in terms of indices to that vector.
   #+(and x86-64 immobile-code)
@@ -3478,16 +3495,19 @@ lispobj symbol_package(struct symbol*);~%" (genesis-header-prefix))
   (loop for symbol in sb-vm::+c-callable-fdefns+
         for index from 0
         do
-    (format stream "#define ~A_FDEFN LISPOBJ(0x~X)~%"
+    (format stream "#define ~A_FDEFN LISPOBJ(~:[~;STATIC_SPACE_START + ~]0x~X)~%"
             (c-symbol-name symbol)
-            (if *static*                ; if we ran GENESIS
-              ;; We actually ran GENESIS, use the real value.
-              (descriptor-bits (ensure-cold-fdefn symbol))
-              ;; We didn't run GENESIS, so guess at the address.
-              (+ sb-vm:nil-value
-                 (* (length sb-vm:+static-symbols+)
-                    (sb-vm:pad-data-block sb-vm:symbol-size))
-                 (* index (sb-vm:pad-data-block sb-vm:fdefn-size)))))))
+            #-relocatable-static-space nil
+            #+relocatable-static-space t
+            (maybe-relativize
+             (if *static*               ; if we ran GENESIS
+                 ;; We actually ran GENESIS, use the real value.
+                 (descriptor-bits (ensure-cold-fdefn symbol))
+                 ;; We didn't run GENESIS, so guess at the address.
+                 (+ sb-vm:nil-value
+                    (* (length sb-vm:+static-symbols+)
+                       (sb-vm:pad-data-block sb-vm:symbol-size))
+                    (* index (sb-vm:pad-data-block sb-vm:fdefn-size))))))))
 
 (defun init-runtime-routines ()
   (dolist (symbol sb-vm::*runtime-asm-routines*)
diff --git src/compiler/generic/interr.lisp src/compiler/generic/interr.lisp
index 97093d8e4..8d0b7d173 100644
--- src/compiler/generic/interr.lisp
+++ src/compiler/generic/interr.lisp
@@ -127,9 +127,11 @@
    #+x86-64
    ("Sub overflow" sub-overflow 1)
    ("Add overflow" signed-unsigned-add-overflow 1)
-   ("ADd overflow" add-overflow2 2)
+   ("Add overflow" add-overflow2 2)
    ("Sub overflow" sub-overflow2 2)
-   ("Mul overflow" mul-overflow2 2))
+   ("Mul overflow" mul-overflow2 2)
+   ("ASH overflow" ash-overflow2 2)
+   ("Negate overflow" negate-overflow 1))
   ;; (II) All the type specifiers X for which there is a unique internal
   ;;      error code corresponding to a primitive object-not-X-error.
   function
diff --git src/compiler/generic/objdef.lisp src/compiler/generic/objdef.lisp
index 07207878c..e3f1a64db 100644
--- src/compiler/generic/objdef.lisp
+++ src/compiler/generic/objdef.lisp
@@ -384,7 +384,10 @@ during backtrace.
   ;; regardless of whether the object being tested is known to be a symbol.
   ;; Accessing the hash requires masking off bits to yield a fixnum result,
   ;; all the more so if the object is any random type.
+  #-relocatable-static-space
   (hash :set-trans %set-symbol-hash)
+  #+relocatable-static-space
+  unused
   (value :init :unbound
          :set-trans %set-symbol-global-value
          :set-known ())
@@ -412,6 +415,8 @@ during backtrace.
         :type (or instance list)
         :init :null)
   (name :init :arg #-compact-symbol :ref-trans #-compact-symbol symbol-name)
+  #+relocatable-static-space
+  (hash :set-trans %set-symbol-hash)
   #-compact-symbol
   (package-id :type index ; actually 16 bits. (Could go in the header)
               :ref-trans symbol-package-id
@@ -499,7 +504,16 @@ during backtrace.
   (assign-header-slot-indices))
 
 (eval-when (:compile-toplevel :load-toplevel :execute)
-(defconstant histogram-small-bins 32)) ; for consing size histogram
+  ;; allocator histogram capacity
+  (defconstant n-histogram-bins-small 32)
+  (defconstant n-histogram-bins-large 32))
+;;; the #+allocation-size-histogram has an exact count of objects allocated
+;;; for all sizes up to (* cons-size n-word-bytes n-histogram-bins-small).
+;;; Larger allocations are grouped by the binary log of the size.
+;;; It seems that 99.5% of all allocations are less than the small bucket limit,
+;;; making the histogram exact except for the tail.
+(defconstant first-large-histogram-bin-log2size
+  (integer-length (* n-histogram-bins-small cons-size n-word-bytes)))
 
 ;;; this isn't actually a lisp object at all, it's a c structure that lives
 ;;; in c-land.  However, we need sight of so many parts of it from Lisp that
@@ -610,8 +624,11 @@ during backtrace.
   (et-allocator-mutex-acq) ; elapsed times
   (et-find-freeish-page)
   (et-bzeroing)
-  (obj-size-histo :c-type "size_histogram"
-                  :length #.(+ histogram-small-bins n-word-bits))
+  (allocator-histogram :c-type "size_histogram"
+                       ;; small bins store just a count
+                       ;; large bins store a count and size
+                       :length #.(+ (* 2 n-histogram-bins-large)
+                                    n-histogram-bins-small))
 
   ;; The *current-thread* MUST be the last slot in the C thread structure.
   ;; It it the only slot that needs to be noticed by the garbage collector.
@@ -664,25 +681,26 @@ during backtrace.
 
 ) ; end PROGN
 
+;;; The offset of NIL in static space, including the tag.
+(defconstant nil-value-offset
+  (+ ;; Make space for the different regions, if they exist.
+     ;; If you change this, then also change zero_all_free_ranges() in
+     ;; gencgc.
+     #+(and gencgc (not sb-thread) (not 64-bit))
+     (* 10 n-word-bytes)
+     ;; This offset of #x100 has to do with some edge cases where a vop
+     ;; might treat UNBOUND-MARKER as a pointer. So it has an address
+     ;; that is somewhere near NIL which makes it sort of "work"
+     ;; to dereference it. See git rev f1a956a6a771 for more info.
+     #+64-bit #x100
+     ;; magic padding because of NIL's symbol/cons-like duality
+     (* 2 n-word-bytes)
+     list-pointer-lowtag))
+
 ;;; The definitions below want to use ALIGN-UP, which is not defined
 ;;; in time to put these in early-objdef, but it turns out that we don't
 ;;; need them there.
-(defconstant nil-value
-    (+ static-space-start
-       ;; mixed_region precedes NIL
-       ;; 10 is the number of words to reserve at the beginning of static space
-       ;; prior to the words of NIL.
-       ;; If you change this, then also change MAKE-NIL-DESCRIPTOR in genesis,
-       ;; and zero_all_free_ranges() in gencgc.
-       #+(and gencgc (not sb-thread) (not 64-bit)) (ash 10 word-shift)
-       ;; This offset of #x100 has to do with some edge cases where a vop
-       ;; might treat UNBOUND-MARKER as a pointer. So it has an address
-       ;; that is somewhere near NIL which makes it sort of "work"
-       ;; to dereference it. See git rev f1a956a6a771 for more info.
-       #+64-bit #x100
-       ;; magic padding because of NIL's symbol/cons-like duality
-       (* 2 n-word-bytes)
-       list-pointer-lowtag))
+(#-relocatable-static-space defconstant #+relocatable-static-space define-symbol-macro nil-value (+ static-space-start nil-value-offset))
 
 #+sb-xc-host (defun get-nil-taggedptr () nil-value)
 
@@ -711,8 +729,8 @@ during backtrace.
 ;;; nil-as-a-list. So subtract the lowtag and then go back one more word.
 ;;; This address is NOT double-lispword-aligned, but the scavenge method
 ;;; does not assert that.
-(defconstant nil-symbol-slots-start
-  (- nil-value list-pointer-lowtag n-word-bytes))
+(defconstant nil-symbol-slots-offset
+  (- nil-value-offset list-pointer-lowtag n-word-bytes))
 
 ;;; NIL as a symbol contains the usual number of words for a symbol,
 ;;; aligned to a double-lispword. This will NOT end at a double-lispword boundary.
@@ -723,8 +741,9 @@ during backtrace.
 ;;; count because of the assertion in heap_scavenge that the scan ends as expected,
 ;;; and scavenge methods must return an even number because nothing can be smaller
 ;;; than 1 cons cell or not a multiple thereof.
-(defconstant nil-symbol-slots-end
-  (+ nil-symbol-slots-start (ash (align-up symbol-size 2) word-shift)))
+(defconstant nil-symbol-slots-end-offset
+  (+ nil-symbol-slots-offset
+     (ash (align-up symbol-size 2) word-shift)))
 
 ;;; This constant is the number of words to report that NIL consumes
 ;;; when Lisp asks for its primitive-object-size. So we say that it consumes
@@ -735,10 +754,11 @@ during backtrace.
 ;;; Basically skip over MIXED-REGION (if it's in static space) and NIL.
 ;;; Or: go to NIL's header word, subtract 1 word, and add in the physical
 ;;; size of NIL in bytes that we report for primitive-object-size.
-(defconstant static-space-objects-start
-  (+ nil-symbol-slots-start (ash (1- sizeof-nil-in-words) word-shift)))
+(defconstant static-space-objects-offset
+  (+ nil-symbol-slots-offset
+     (ash (1- sizeof-nil-in-words) word-shift)))
 
-(defconstant lockfree-list-tail-value
-  (+ static-space-objects-start
+(defconstant lockfree-list-tail-value-offset
+  (+ static-space-objects-offset
      (* (length +static-symbols+) (ash (align-up symbol-size 2) word-shift))
      instance-pointer-lowtag))
diff --git src/compiler/generic/parms.lisp src/compiler/generic/parms.lisp
index b4d3e598c..658e1f92c 100644
--- src/compiler/generic/parms.lisp
+++ src/compiler/generic/parms.lisp
@@ -103,7 +103,7 @@
                  appending
                  (let* ((relocatable
                           ;; READONLY is usually movable now.
-                          (member space '(fixedobj text
+                          (member space '(fixedobj text #+relocatable-static-space static
                                           #+immobile-space alien-linkage-table
                                           #-darwin-jit read-only)))
                         (start ptr)
@@ -322,6 +322,12 @@
       ;; fdefn pointers in the core. A couple others were high on the list as well.
       hairy-data-vector-set
       hairy-data-vector-ref
+      vector-hairy-data-vector-set
+      vector-hairy-data-vector-ref
+      hairy-data-vector-set/check-bounds
+      hairy-data-vector-ref/check-bounds
+      vector-hairy-data-vector-set/check-bounds
+      vector-hairy-data-vector-ref/check-bounds
       %ldb
       sb-kernel:vector-unsigned-byte-8-p)
   #'equalp)
diff --git src/compiler/generic/utils.lisp src/compiler/generic/utils.lisp
index 56b1bbddc..064f8eb3c 100644
--- src/compiler/generic/utils.lisp
+++ src/compiler/generic/utils.lisp
@@ -314,11 +314,11 @@
 (define-load-time-global *store-barriers-potentially-emitted* 0)
 (define-load-time-global *store-barriers-emitted* 0)
 
-(defun require-gc-store-barrier-p (object value-tn-ref value-tn)
+(defun require-gengc-barrier-p (object value-tn-ref value-tn)
   (incf *store-barriers-potentially-emitted*)
   ;; If OBJECT is stack-allocated, elide the barrier
   (when (stack-consed-p object)
-    (return-from require-gc-store-barrier-p nil))
+    (return-from require-gengc-barrier-p nil))
   (flet ((potential-heap-pointer-p (tn tn-ref)
            (when (sc-is tn any-reg) ; must be fixnum
              (return-from potential-heap-pointer-p nil))
@@ -343,7 +343,7 @@
            (unless (eq (tn-ref-tn value-tn-ref) value-tn)
              (aver (eq (tn-ref-load-tn value-tn-ref) value-tn)))
            (unless (potential-heap-pointer-p value-tn value-tn-ref)
-             (return-from require-gc-store-barrier-p nil)))
+             (return-from require-gengc-barrier-p nil)))
           (value-tn-ref ; a list of refs linked through TN-REF-ACROSS
            ;; (presumably from INSTANCE-SET-MULTIPLE)
            (let ((any-pointer
@@ -352,7 +352,7 @@
                     (when (potential-heap-pointer-p (tn-ref-tn ref) ref)
                       (return t)))))
              (unless any-pointer
-               (return-from require-gc-store-barrier-p nil))))))
+               (return-from require-gengc-barrier-p nil))))))
   (incf *store-barriers-emitted*)
   t)
 
diff --git src/compiler/generic/vm-fndb.lisp src/compiler/generic/vm-fndb.lisp
index 277409e94..e05d8d0b3 100644
--- src/compiler/generic/vm-fndb.lisp
+++ src/compiler/generic/vm-fndb.lisp
@@ -606,16 +606,6 @@
     (values bignum-element-type bignum-element-type)
     (foldable flushable movable always-translatable))
 
-(defknown %lognot (bignum-element-type) bignum-element-type
-    (foldable flushable movable always-translatable))
-
-(defknown (%logand %logior %logxor) (bignum-element-type bignum-element-type)
-  bignum-element-type
-  (foldable flushable movable))
-
-(defknown %fixnum-to-digit (fixnum) bignum-element-type
-  (foldable flushable movable #-(or arm arm64) always-translatable))
-
 ;;; This takes three digits and returns the FLOOR'ed result of
 ;;; dividing the first two as a 2*digit-size integer by the third.
 (defknown %bigfloor (bignum-element-type bignum-element-type bignum-element-type)
diff --git src/compiler/ir1-translators.lisp src/compiler/ir1-translators.lisp
index 9500bfc3c..773cf26eb 100644
--- src/compiler/ir1-translators.lisp
+++ src/compiler/ir1-translators.lisp
@@ -1156,6 +1156,11 @@ care."
                             *current-path*)))
     (ir1-convert start next result form)))
 
+(def-ir1-translator with-source-path ((source-path form)
+                                      start next result)
+  (let ((*current-path* source-path))
+    (ir1-convert start next result form)))
+
 (def-ir1-translator bound-cast ((array bound index) start next result)
   (let ((check-bound-tran (make-ctran))
         (index-ctran (make-ctran))
diff --git src/compiler/ir1final.lisp src/compiler/ir1final.lisp
index 2fb55678b..b48b333e7 100644
--- src/compiler/ir1final.lisp
+++ src/compiler/ir1final.lisp
@@ -144,7 +144,7 @@
 
 (defglobal *two-arg-functions*
     `((* two-arg-*
-         ,@(sb-c::unless-vop-existsp (:translate sb-c::fixnum*)
+         ,@(sb-c::unless-vop-existsp (:named sb-vm::*/signed=>integer)
              `((,(specifier-type 'fixnum) ,(specifier-type 'fixnum))
                multiply-fixnums)))
       (+ two-arg-+)
@@ -296,13 +296,21 @@
               (setf (getf (functional-plist (ref-leaf ref)) 'verify-arg-count)
                     nil))))))))
 
+(defun change-full-call (combination new-fun-name)
+  (let ((ref (lvar-uses (combination-fun combination))))
+    (when (ref-p ref)
+      (setf (combination-fun-info combination)
+            (fun-info-or-lose new-fun-name))
+      (change-ref-leaf
+       ref
+       (find-free-fun new-fun-name ""))
+      t)))
+
 (defun rewrite-full-call (combination)
   (let ((combination-name (lvar-fun-name (combination-fun combination) t))
         (args (combination-args combination)))
-    (let ((two-arg (assoc combination-name *two-arg-functions*))
-          (ref (lvar-uses (combination-fun combination))))
+    (let ((two-arg (assoc combination-name *two-arg-functions*)))
       (when (and two-arg
-                 (ref-p ref)
                  (= (length args) 2)
                  (not (fun-lexically-notinline-p combination-name
                                                  (node-lexenv combination))))
@@ -313,11 +321,7 @@
                            for type in types
                            always (csubtypep (lvar-type arg) type)))
             (setf two-arg typed-two-arg))
-          (setf (combination-fun-info combination)
-                (fun-info-or-lose two-arg))
-          (change-ref-leaf
-           ref
-           (find-free-fun two-arg "rewrite-full-call")))))))
+          (change-full-call combination two-arg))))))
 
 ;;; Do miscellaneous things that we want to do once all optimization
 ;;; has been done:
diff --git src/compiler/ir1report.lisp src/compiler/ir1report.lisp
index c8299547f..4e858147c 100644
--- src/compiler/ir1report.lisp
+++ src/compiler/ir1report.lisp
@@ -485,6 +485,7 @@ has written, having proved that it is unreachable."))
 ;;; it needs to be reprinted, and we also FORCE-OUTPUT so that the
 ;;; message gets seen right away.
 (defun compiler-mumble (control &rest args)
+  (declare (explicit-check))
   (let ((stream *standard-output*))
     (note-message-repeats stream)
     (setq *last-error-context* nil)
diff --git src/compiler/ir1util.lisp src/compiler/ir1util.lisp
index 8846e316d..496b50662 100644
--- src/compiler/ir1util.lisp
+++ src/compiler/ir1util.lisp
@@ -2029,41 +2029,45 @@
 ;;; of arguments changes, the transform must be prepared to return a
 ;;; lambda with a new lambda-list with the correct number of
 ;;; arguments.
-(defun splice-fun-args (lvar fun num-args)
+(defun splice-fun-args (lvar fun num-args &optional (give-up t))
   "If LVAR is a call to FUN with NUM-ARGS args, change those arguments to feed
 directly to the LVAR-DEST of LVAR, which must be a combination. If FUN
 is :ANY, the function name is not checked."
   (declare (type lvar lvar)
            (type symbol fun)
            (type index num-args))
-  (let ((outside (lvar-dest lvar))
-        (inside (lvar-uses lvar)))
-    (aver (combination-p outside))
-    (unless (combination-p inside)
-      (give-up-ir1-transform))
-    (let ((inside-fun (combination-fun inside)))
-      (unless (or (eq fun :any)
-                  (eq (lvar-fun-name inside-fun) fun))
-        (give-up-ir1-transform))
-      (let ((inside-args (combination-args inside)))
-        (unless (= (length inside-args) num-args)
-          (give-up-ir1-transform))
-        (let* ((outside-args (combination-args outside))
-               (arg-position (position lvar outside-args))
-               (before-args (subseq outside-args 0 arg-position))
-               (after-args (subseq outside-args (1+ arg-position))))
-          (dolist (arg inside-args)
-            (setf (lvar-dest arg) outside))
-          (setf (combination-args inside) nil)
-          (setf (combination-args outside)
-                (append before-args inside-args after-args))
-          (change-ref-leaf (lvar-uses inside-fun)
-                           (find-free-fun 'list "???"))
-          (setf (combination-fun-info inside) (info :function :info 'list)
-                (combination-kind inside) :known)
-          (setf (node-derived-type inside) *wild-type*)
-          (flush-dest lvar)
-          inside-args)))))
+  (flet ((give-up ()
+           (if give-up
+               (give-up-ir1-transform)
+               (return-from splice-fun-args nil))))
+    (let ((outside (lvar-dest lvar))
+          (inside (lvar-uses lvar)))
+      (aver (combination-p outside))
+      (unless (combination-p inside)
+        (give-up))
+      (let ((inside-fun (combination-fun inside)))
+        (unless (or (eq fun :any)
+                    (eq (lvar-fun-name inside-fun) fun))
+          (give-up))
+        (let ((inside-args (combination-args inside)))
+          (unless (= (length inside-args) num-args)
+            (give-up))
+          (let* ((outside-args (combination-args outside))
+                 (arg-position (position lvar outside-args))
+                 (before-args (subseq outside-args 0 arg-position))
+                 (after-args (subseq outside-args (1+ arg-position))))
+            (dolist (arg inside-args)
+              (setf (lvar-dest arg) outside))
+            (setf (combination-args inside) nil)
+            (setf (combination-args outside)
+                  (append before-args inside-args after-args))
+            (change-ref-leaf (lvar-uses inside-fun)
+                             (find-free-fun 'list "???"))
+            (setf (combination-fun-info inside) (info :function :info 'list)
+                  (combination-kind inside) :known)
+            (setf (node-derived-type inside) *wild-type*)
+            (flush-dest lvar)
+            inside-args))))))
 
 ;;; Eliminate keyword arguments from the call (leaving the
 ;;; parameters in place.
diff --git src/compiler/ir2opt.lisp src/compiler/ir2opt.lisp
index 24649fe66..f56bce6a9 100644
--- src/compiler/ir2opt.lisp
+++ src/compiler/ir2opt.lisp
@@ -1047,11 +1047,14 @@
     (let (vops
           stop
           null
-          (value (tn-ref-tn (vop-args vop))))
+          (value (tn-ref-tn (vop-args vop)))
+          zero-extend)
       (labels ((good-vop-p (vop)
                  (and (singleton-p (ir2block-predecessors (vop-block vop)))
                       (or (getf sb-vm::*other-pointer-type-vops* (vop-name vop))
-                          (eq (vop-name vop) '%other-pointer-subtype-p))
+                          (eq (vop-name vop) '%other-pointer-subtype-p)
+                          (and (eq (vop-name vop) '%other-pointer-widetag)
+                               (setf zero-extend t)))
                       (eq (tn-ref-tn (vop-args vop)) value)))
                (chain (vop &optional (collect t))
                  (let ((next (branch-destination vop nil)))
@@ -1090,7 +1093,8 @@
                                  vop
                                  (list (ir2-block-label stop)
                                        (and null
-                                            (ir2-block-label (vop-block null)))))
+                                            (ir2-block-label (vop-block null)))
+                                       #+x86-64 zero-extend))
             (update-block-succ block
                                (cons stop
                                      (ir2block-successors block)))
@@ -1102,18 +1106,25 @@
                                    (third info)
                                    (getf sb-vm::*other-pointer-type-vops* (vop-name vop)))
                     do
-                    (let ((next (vop-next vop)))
-                      (when (and next
-                                 (eq (vop-name next) 'branch-if))
-                        (setf info (vop-codegen-info next))
-                        (delete-vop next))
-                      (emit-and-insert-vop (vop-node vop)
-                                           (vop-block vop)
-                                           test-vop
-                                           (reference-tn widetag nil)
-                                           nil
-                                           vop
-                                           (list (first info) (second info) tags)))
+                    (if (eq (vop-name vop) '%other-pointer-widetag)
+                        (emit-and-insert-vop (vop-node vop)
+                                             (vop-block vop)
+                                             (template-or-lose 'move)
+                                             (reference-tn widetag nil)
+                                             (reference-tn (tn-ref-tn (vop-results vop )) t)
+                                             vop)
+                        (let ((next (vop-next vop)))
+                          (when (and next
+                                     (eq (vop-name next) 'branch-if))
+                            (setf info (vop-codegen-info next))
+                            (delete-vop next))
+                          (emit-and-insert-vop (vop-node vop)
+                                               (vop-block vop)
+                                               test-vop
+                                               (reference-tn widetag nil)
+                                               nil
+                                               vop
+                                               (list (first info) (second info) tags))))
                     (delete-vop vop)))))))
     nil)
 
@@ -1250,6 +1261,42 @@
           (delete-vop return))
         nil))))
 
+;; Try to combine consecutive uses of %INSTANCE-SET. This can't be
+;; done prior to selecting representations because
+;; SELECT-REPRESENTATIONS might insert some things like
+;; MOVE-FROM-DOUBLE which makes the "consecutive" vops no longer
+;; consecutive.
+;; It seems like this should also supplant the #+arm64 hack in GENERATE-CODE.
+(when-vop-existsp (:named sb-vm::instance-set-multiple)
+  (defoptimizer (vop-optimize sb-vm::instance-index-set select-representations) (vop)
+    (let ((instance (tn-ref-tn (vop-args vop)))
+          (this vop)
+          (pairs))
+      (loop
+       (let ((index (tn-ref-tn (tn-ref-across (vop-args this)))))
+         (unless (constant-tn-p index) (return))
+         (push (cons (tn-value index) (tn-ref-tn (sb-vm::vop-nth-arg 2 this)))
+               pairs))
+       (let ((next (vop-next this)))
+         (unless (and next
+                      (eq (vop-name next) 'sb-vm::instance-index-set)
+                      (eq (tn-ref-tn (vop-args next)) instance))
+           (return))
+         (setq this next)))
+      (when (cdr pairs)                 ; if at least 2
+        (setq pairs (nreverse pairs))
+        (let ((new (emit-and-insert-vop
+                    (vop-node vop) (vop-block vop)
+                    (template-or-lose 'sb-vm::instance-set-multiple)
+                    (reference-tn-list (cons instance (mapcar #'cdr pairs)) nil)
+                    nil vop (list (mapcar #'car pairs)))))
+          (loop (let ((next (vop-next vop)))
+                  (delete-vop vop)
+                  (pop pairs)
+                  (setq vop next))
+                (unless pairs (return)))
+          new)))))
+
 (defun very-temporary-p (tn)
   (let ((writes (tn-writes tn))
         (reads (tn-reads tn)))
@@ -1318,52 +1365,6 @@
                                      (funcall it vop))))
                           (vop-next vop)))))))
 
-(defun merge-instance-set-vops (vop)
-  (let ((instance (tn-ref-tn (vop-args vop)))
-        (this vop)
-        (pairs))
-    (loop
-       (let ((index (tn-ref-tn (tn-ref-across (vop-args this)))))
-         (unless (constant-tn-p index) (return))
-         (push (cons (tn-value index) (tn-ref-tn (sb-vm::vop-nth-arg 2 this)))
-               pairs))
-       (let ((next (vop-next this)))
-         (unless (and next
-                      (eq (vop-name next) 'sb-vm::instance-index-set)
-                      (eq (tn-ref-tn (vop-args next)) instance))
-           (return))
-         (setq this next)))
-    (unless (cdr pairs) ; if at least 2
-      (return-from merge-instance-set-vops nil))
-    (setq pairs (nreverse pairs))
-    (let ((new (emit-and-insert-vop
-                (vop-node vop) (vop-block vop)
-                (template-or-lose 'sb-vm::instance-set-multiple)
-                (reference-tn-list (cons instance (mapcar #'cdr pairs)) nil)
-                nil vop (list (mapcar #'car pairs)))))
-      (loop (let ((next (vop-next vop)))
-              (delete-vop vop)
-              (pop pairs)
-              (setq vop next))
-            (unless pairs (return)))
-      new)))
-
-(defun ir2-optimize-stores (component)
-  ;; This runs after representation selection. It's the same as RUN-VOP-OPTIMIZERS,
-  ;; but with hardcoded vop names and function to call.
-  ;; It seems like this should also supplant the #+arm64 hack in GENERATE-CODE.
-  (do-ir2-blocks (block component)
-    (let ((vop (ir2-block-start-vop block)))
-      (loop (unless vop (return))
-            (let ((optimizer
-                   (case (vop-name vop)
-                     (sb-vm::instance-index-set
-                      (when (gethash 'sb-vm::instance-set-multiple
-                                     *backend-parsed-vops*)
-                        'merge-instance-set-vops)))))
-              (setq vop (or (awhen optimizer (funcall it vop))
-                            (vop-next vop))))))))
-
 ;;; These are the acceptable vops in a sequence that can be brought together
 ;;; under one pseudo-atomic invocation. In general any vop that does not
 ;;; allocate is OK, but I'd rather be restrictive than permissive here.
@@ -1475,6 +1476,91 @@
             ;; As long as we don't re-process an allocation vop, all it well.
             (setq vop (vop-next vop)))))))
 
+;;; If a constant is already loaded into a register use that register.
+(defun optimize-constant-loads (component)
+  (let* ((register-sb (sb-or-lose 'sb-vm::registers))
+         (loaded-constants
+           (make-array (sb-size register-sb)
+                       :initial-element nil)))
+    (do-ir2-blocks (block component)
+      (fill loaded-constants nil)
+      (do ((vop (ir2-block-start-vop block) (vop-next vop)))
+          ((null vop))
+        (labels ((register-p (tn)
+                   (and (tn-p tn)
+                        (not (eq (tn-kind tn) :unused))
+                        (eq (sc-sb (tn-sc tn)) register-sb)))
+                 (constant-eql-p (a b)
+                   (or (eq a b)
+                       (and (eq (sc-name (tn-sc a)) 'constant)
+                            (eq (tn-sc a) (tn-sc b))
+                            (eql (tn-offset a) (tn-offset b)))))
+                 (remove-constant (tn)
+                   (when (register-p tn)
+                     (setf (svref loaded-constants (tn-offset tn)) nil)))
+                 (remove-written-tns ()
+                   (cond ((memq (vop-info-save-p (vop-info vop))
+                                '(t :force-to-stack))
+                          (fill loaded-constants nil))
+                         (t
+                          (do ((ref (vop-results vop) (tn-ref-across ref)))
+                              ((null ref))
+                            (remove-constant (tn-ref-tn ref))
+                            (remove-constant (tn-ref-load-tn ref)))
+                          (do ((ref (vop-temps vop) (tn-ref-across ref)))
+                              ((null ref))
+                            (remove-constant (tn-ref-tn ref)))
+                          (do ((ref (vop-args vop) (tn-ref-across ref)))
+                              ((null ref))
+                            (remove-constant (tn-ref-load-tn ref))))))
+                 (compatible-scs-p (a b)
+                   (or (eql a b)
+                       (and (eq (sc-name a) 'sb-vm::control-stack)
+                            (eq (sc-name b) 'sb-vm::descriptor-reg))
+                       (and (eq (sc-name b) 'sb-vm::control-stack)
+                            (eq (sc-name a) 'sb-vm::descriptor-reg))))
+                 (find-constant-tn (constant sc)
+                   (loop for (saved-constant . tn) across loaded-constants
+                         when (and saved-constant
+                                   (constant-eql-p saved-constant constant)
+                                   (compatible-scs-p (tn-sc tn) sc))
+                         return tn)))
+          (case (vop-name vop)
+            ((move sb-vm::move-arg)
+             (let* ((args (vop-args vop))
+                    (results (vop-results vop))
+                    (x (tn-ref-tn args))
+                    (x-load-tn (tn-ref-load-tn args))
+                    (y (tn-ref-tn results))
+                    constant)
+               (cond ((or (eq (sc-name (tn-sc x)) 'null)
+                          (not (eq (tn-kind x) :constant)))
+                      (remove-written-tns))
+                     ((setf constant (find-constant-tn x (tn-sc y)))
+                      (when (register-p y)
+                        (setf (svref loaded-constants (tn-offset y))
+                              (cons x y)))
+                      ;; XOR is more compact on x86oids and many
+                      ;; RISCs have a zero register
+                      (unless (and (constant-p (tn-leaf x))
+                                   (eql (tn-value x) 0)
+                                   (register-p y))
+                        (change-tn-ref-tn args constant)
+                        (setf (tn-ref-load-tn args) nil)))
+                     ((register-p y)
+                      (setf (svref loaded-constants (tn-offset y))
+                            (cons x y)))
+                     ((and x-load-tn
+                           (or (not (tn-ref-load-tn results))
+                               (location= (tn-ref-load-tn results)
+                                          x-load-tn)))
+                      (setf (svref loaded-constants (tn-offset x-load-tn))
+                            (cons x x-load-tn)))
+                     (t
+                      (remove-written-tns)))))
+            (t
+             (remove-written-tns))))))))
+
 (defun ir2-optimize (component &optional stage)
   (let ((*2block-info* (make-hash-table :test #'eq)))
     (initialize-ir2-blocks-flow-info component)
@@ -1489,13 +1575,7 @@
        ;; Give the optimizers a second opportunity to alter newly inserted vops
        ;; by looking for patterns that have a shorter expression as a single vop.
        (run-vop-optimizers component stage t)
-       (delete-unused-ir2-blocks component)
-       ;; Try to combine consecutive uses of %INSTANCE-SET.
-       ;; This can't be done prior to selecting representations
-       ;; because SELECT-REPRESENTATIONS might insert some
-       ;; things like MOVE-FROM-DOUBLE which makes the
-       ;; "consecutive" vops no longer consecutive.
-       (ir2-optimize-stores component))
+       (delete-unused-ir2-blocks component))
       (t
        (when (and *compiler-trace-output*
                   (member :pre-ir2-optimize *compile-trace-targets*))
diff --git src/compiler/ir2tran.lisp src/compiler/ir2tran.lisp
index 7d13a74fa..68bb2840b 100644
--- src/compiler/ir2tran.lisp
+++ src/compiler/ir2tran.lisp
@@ -26,7 +26,7 @@
 ;;; Determine whether we should emit a single-stepper breakpoint
 ;;; around a call / before a vop.
 (defun emit-step-p (node)
-  (if (and (policy node (> insert-step-conditions 1))
+  (if (and (policy node (= insert-step-conditions 3))
            (typep node 'combination))
       (combination-step-info node)
       nil))
@@ -1109,7 +1109,7 @@
   (let ((fun-info (combination-fun-info combination)))
     (declare (ignorable fun-info))
     (and #+(or arm64 x86-64)
-         (or (policy combination (> insert-step-conditions 1))
+         (or (policy combination (= insert-step-conditions 3))
              (and
               (combination-pass-nargs combination)
               (not (and (eq (combination-kind combination) :known)
@@ -1868,9 +1868,7 @@ not stack-allocated LVAR ~S." source-lvar)))))
     ;; If only one exists, it's DYNBIND.
     ;; Even if the backend supports load-time TLS index assignment,
     ;; there might be only one vop.
-    (macrolet ((doit (bind dynbind)
-                 (if (gethash 'bind *backend-parsed-vops*) bind dynbind)))
-      (doit
+    (if-vop-existsp (:named bind)
        (progn
          ;; Inform later SYMBOL-VALUE calls that they can
          ;; assume a nonzero tls-index.
@@ -1883,7 +1881,7 @@ not stack-allocated LVAR ~S." source-lvar)))))
          (emit-constant name)
          (vop bind node block (lvar-tn node block value) name))
        (vop dynbind node block (lvar-tn node block value)
-            (emit-constant name))))))
+            (emit-constant name)))))
 
 (defoptimizer (%special-unbind ir2-convert) ((&rest symbols) node block)
   (if-vop-existsp (:named sb-c:unbind-n)
diff --git src/compiler/knownfun.lisp src/compiler/knownfun.lisp
index 43abbe6ed..869fc848c 100644
--- src/compiler/knownfun.lisp
+++ src/compiler/knownfun.lisp
@@ -334,16 +334,23 @@
 ;;; N'th argument. If arg is a list, result is a list. If arg is a
 ;;; vector, result is a vector with the same element type.
 (defun sequence-result-nth-arg (n &key preserve-dimensions
-                                       preserve-vector-type)
+                                       preserve-vector-type
+                                       string-designator)
   (lambda (call)
     (declare (type combination call))
     (let ((lvar (nth n (combination-args call))))
       (when lvar
         (let ((type (lvar-type lvar)))
-          (cond ((simplify-list-type type
-                                     :preserve-dimensions preserve-dimensions))
+          (cond ((and (not string-designator)
+                      (simplify-list-type type
+                                          :preserve-dimensions preserve-dimensions)))
                 ((not (csubtypep type (specifier-type 'vector)))
-                 nil)
+                 (cond ((not string-designator) nil)
+                       ((csubtypep type (specifier-type 'character))
+                        (specifier-type `(simple-string 1)))
+                       ((and (constant-lvar-p lvar)
+                             (symbolp (lvar-value lvar)))
+                        (ctype-of (symbol-name (lvar-value lvar))))))
                 (preserve-vector-type
                  type)
                 (t
diff --git src/compiler/meta-vmdef.lisp src/compiler/meta-vmdef.lisp
index 87a855ecd..d7f283a93 100644
--- src/compiler/meta-vmdef.lisp
+++ src/compiler/meta-vmdef.lisp
@@ -1757,34 +1757,58 @@
             (temps)
             (results)
             (result-types))
-    (loop for (var arg) in vars
-          for (name this-sc) = var
-          for (nil sc type . rest) = (if this-sc
-                                         var
-                                         prev)
-          for prev = (if this-sc
-                         var
-                         prev)
-          do (cond ((eq name :info)
-                    (infos this-sc)
-                    (input arg))
-                   (arg
-                    (input arg)
-                    (args (list* name :scs (list sc) rest))
-                    (arg-types (or type '*)))
-                   (t
-                    (temps `(:temporary (:sc ,sc ,@rest)
-                                        ,name)))))
-    (loop for result in results
-          for (name this-sc) = result
-          for (nil sc type . rest) = (if this-sc
-                                         result
-                                         prev)
-          for prev = (if this-sc
-                         result
-                         prev)
-          do (results (list* name :scs (list sc) rest))
-             (result-types (or type '*)))
+    (flet ((sc-to-type (sc)
+             (case sc
+               (sb-vm::any-reg
+                'fixnum)
+               (sb-vm::unsigned-reg
+                'sb-vm::unsigned-num)
+               (sb-vm::signed-reg
+                'sb-vm::signed-num)
+               (sb-vm::sap-reg
+                'system-area-pointer)
+               (sb-vm::descriptor-reg
+                t)
+               (t
+                '*))))
+     (loop for (var arg) in vars
+           for (name this-sc) = var
+           for (nil sc type . rest) = (if this-sc
+                                          var
+                                          prev)
+           for prev = (if this-sc
+                          var
+                          prev)
+           do (cond ((eq name :info)
+                     (infos this-sc)
+                     (input arg))
+                    (arg
+                     (args (list* name :scs (list sc) rest))
+                     (let ((type (or type (sc-to-type sc))))
+                       (arg-types type)
+                       (input `(the ,(case type
+                                       (sb-vm::unsigned-num
+                                        'word)
+                                       (sb-vm::signed-num
+                                        'sb-vm:signed-word)
+                                       (sb-vm::tagged-num
+                                        'fixnum)
+                                       (* t)
+                                       (t (primitive-type-specifier (primitive-type-or-lose type))))
+                                    ,arg))))
+                    (t
+                     (temps `(:temporary (:sc ,sc ,@rest)
+                                         ,name)))))
+     (loop for result in results
+           for (name this-sc) = result
+           for (nil sc type . rest) = (if this-sc
+                                          result
+                                          prev)
+           for prev = (if this-sc
+                          result
+                          prev)
+           do (results (list* name :scs (list sc) rest))
+              (result-types (or type (sc-to-type sc)))))
     `(inline-%primitive
       ,(eval (%define-vop nil nil
                           (delete nil
diff --git src/compiler/mips/alloc.lisp src/compiler/mips/alloc.lisp
index 930e8210b..1ab7ed18d 100644
--- src/compiler/mips/alloc.lisp
+++ src/compiler/mips/alloc.lisp
@@ -19,14 +19,16 @@
         (t
          (let ((end-addr (car temps))
                (new-freeptr (cadr temps))
-               (region (if (eq type 'list) cons-region mixed-region)))
+               (region-offset (if (eq type 'list)
+                                  cons-region-offset
+                                  mixed-region-offset)))
            (without-scheduling ()
-             (inst lw result null-tn (- region nil-value))
-             (inst lw end-addr null-tn (+ 4 (- region nil-value)))
+             (inst lw result null-tn (- region-offset nil-value-offset))
+             (inst lw end-addr null-tn (+ 4 (- region-offset nil-value-offset)))
              (inst add new-freeptr result size)
              (inst tltu end-addr new-freeptr
                    (logior (if (eq type 'list) #x100 0) (reg-tn-encoding result)))
-             (inst sw new-freeptr null-tn (- region nil-value))
+             (inst sw new-freeptr null-tn (- region-offset nil-value-offset))
              (unless (= lowtag 0)
                (inst or result lowtag)))))))
 
diff --git src/compiler/mips/arith.lisp src/compiler/mips/arith.lisp
index 8b8b0badd..5c931039a 100644
--- src/compiler/mips/arith.lisp
+++ src/compiler/mips/arith.lisp
@@ -150,6 +150,18 @@
 (define-binop logand 1 3 and (unsigned-byte 14) (unsigned-byte 16))
 (define-binop logxor 1 3 xor (unsigned-byte 14) (unsigned-byte 16))
 
+(define-vop (fast-logand/signed-unsigned=>unsigned fast-logand/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r)
+         (y :scs (unsigned-reg) :target r))
+  (:arg-types signed-num unsigned-num))
+
+(define-vop (fast-logand-c/signed-unsigned=>unsigned fast-logand-c/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r))
+  (:arg-types signed-num (:constant (eql #.most-positive-word)))
+  (:ignore y)
+  (:generator 1
+    (move r x)))
+
 ;;; No -C/ VOPs for LOGNOR because the NOR instruction doesn't take
 ;;; immediate args.  -- CSR, 2003-09-11
 (define-vop (fast-lognor/fixnum=>fixnum fast-fixnum-binop)
@@ -794,19 +806,6 @@
     (inst mflo lo)
     (inst mfhi hi)))
 
-(define-vop (bignum-lognot lognot-mod32/unsigned=>unsigned)
-  (:translate sb-bignum:%lognot))
-
-(define-vop (fixnum-to-digit)
-  (:translate sb-bignum:%fixnum-to-digit)
-  (:policy :fast-safe)
-  (:args (fixnum :scs (any-reg)))
-  (:arg-types tagged-num)
-  (:results (digit :scs (unsigned-reg)))
-  (:result-types unsigned-num)
-  (:generator 1
-    (inst sra digit fixnum n-fixnum-tag-bits)))
-
 (define-vop (bignum-floor)
   (:translate sb-bignum:%bigfloor)
   (:policy :fast-safe)
diff --git src/compiler/mips/call.lisp src/compiler/mips/call.lisp
index 3056c0200..d4177f7ea 100644
--- src/compiler/mips/call.lisp
+++ src/compiler/mips/call.lisp
@@ -1180,8 +1180,8 @@ default-value-8
                      (new-freeptr temp)
                      (continue (gen-label)))
                  (without-scheduling ()
-                   (inst lw result null-tn (- cons-region nil-value))
-                   (inst lw end-addr null-tn (+ 4 (- cons-region nil-value)))
+                   (inst lw result null-tn (- cons-region-offset nil-value-offset))
+                   (inst lw end-addr null-tn (+ 4 (- cons-region-offset nil-value-offset)))
                    (inst add new-freeptr result count)
                    ;; Use a different 'code' field for listify. Technically there are enough
                    ;; bits in the code field to indicate how many bytes to skip to branch out
@@ -1196,7 +1196,7 @@ default-value-8
                    (inst beq zero-tn leave-pa)
                    (inst nop)
                    (emit-label continue)
-                   (inst sw new-freeptr null-tn (- cons-region nil-value))
+                   (inst sw new-freeptr null-tn (- cons-region-offset nil-value-offset))
                    (inst or result list-pointer-lowtag)))))
 
         (move dst result)
diff --git src/compiler/mips/memory.lisp src/compiler/mips/memory.lisp
index 9e293ffd7..19f231bf7 100644
--- src/compiler/mips/memory.lisp
+++ src/compiler/mips/memory.lisp
@@ -3,7 +3,7 @@
 ;;; You should generally put WITHOUT-SCHEDULING around this because the fixup patcher
 ;;; wants to see the two shifts as consecutive instructions.
 (defun emit-gengc-barrier (object cell-address temp &optional value-tn-ref value-tn)
-  (when (require-gc-store-barrier-p object value-tn-ref value-tn)
+  (when (require-gengc-barrier-p object value-tn-ref value-tn)
     (inst sll temp (or cell-address object) (make-fixup nil :card-table-index-mask))
     (inst srl temp temp 0)
     (inst addu temp temp cardbase-tn)
diff --git src/compiler/mips/move.lisp src/compiler/mips/move.lisp
index 59244dc92..db3095a81 100644
--- src/compiler/mips/move.lisp
+++ src/compiler/mips/move.lisp
@@ -17,7 +17,8 @@
                           character-widetag)))
       (structure-object
        (if (eq val sb-lockless:+tail+)
-           (inst add y null-tn (- sb-vm::lockfree-list-tail-value sb-vm:nil-value))
+           (inst add y null-tn (- lockfree-list-tail-value-offset
+                                  nil-value-offset))
            (bug "immediate structure-object ~S" val))))))
 
 (define-move-fun (load-number 1) (vop x y)
diff --git src/compiler/policies.lisp src/compiler/policies.lisp
index 5270eff15..c0574eab8 100644
--- src/compiler/policies.lisp
+++ src/compiler/policies.lisp
@@ -88,7 +88,7 @@ and will refer to the new function, bound to FOO.")
     (if (> debug (max speed space compilation-speed))
         debug
         0)
-  ("no" "no" "partial" "full")
+  ("no" "no" "no" "yes")
   "Control instrumentation of code, enabling single-stepping through
 it in the debugger.
 
diff --git src/compiler/ppc/alloc.lisp src/compiler/ppc/alloc.lisp
index da0288b20..93550e1bb 100644
--- src/compiler/ppc/alloc.lisp
+++ src/compiler/ppc/alloc.lisp
@@ -32,7 +32,10 @@
   (binding*  ((cons-region-p (or #+use-cons-region (eq type 'list)))
               ((region-base-tn field-offset)
                #-sb-thread
-               (values null-tn (- (if cons-region-p cons-region mixed-region) nil-value))
+               (values null-tn (- (if cons-region-p
+                                      cons-region-offset
+                                      mixed-region-offset)
+                                  nil-value-offset))
                #+sb-thread
                (values thread-base-tn
                        (ash (if cons-region-p thread-cons-tlab-slot thread-mixed-tlab-slot)
diff --git src/compiler/ppc/arith.lisp src/compiler/ppc/arith.lisp
index cc8719ef6..2f37c7473 100644
--- src/compiler/ppc/arith.lisp
+++ src/compiler/ppc/arith.lisp
@@ -417,6 +417,18 @@
 (!define-const-logop logior 2 ori oris)
 (!define-const-logop logxor 2 xori xoris)
 
+(define-vop (fast-logand/signed-unsigned=>unsigned fast-logand/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r)
+         (y :scs (unsigned-reg) :target r))
+  (:arg-types signed-num unsigned-num))
+
+(define-vop (fast-logand-c/signed-unsigned=>unsigned fast-logand-c/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r))
+  (:arg-types signed-num (:constant (eql #.most-positive-word)))
+  (:ignore y)
+  (:generator 1
+    (move r x)))
+
 (define-vop (fast-*/fixnum=>fixnum fast-fixnum-binop)
   (:temporary (:scs (non-descriptor-reg)) temp)
   (:translate *)
@@ -1148,19 +1160,6 @@
     (inst lr mask fixnum-tag-mask)
     (inst andc hi temp mask)))
 
-(define-vop (bignum-lognot lognot-mod32/unsigned=>unsigned)
-  (:translate sb-bignum:%lognot))
-
-(define-vop (fixnum-to-digit)
-  (:translate sb-bignum:%fixnum-to-digit)
-  (:policy :fast-safe)
-  (:args (fixnum :scs (any-reg)))
-  (:arg-types tagged-num)
-  (:results (digit :scs (unsigned-reg)))
-  (:result-types unsigned-num)
-  (:generator 1
-    (inst srawi digit fixnum n-fixnum-tag-bits)))
-
 (define-vop (bignum-floor)
   (:translate sb-bignum:%bigfloor)
   (:policy :fast-safe)
diff --git src/compiler/ppc/move.lisp src/compiler/ppc/move.lisp
index 1e01f195a..a793dd4cc 100644
--- src/compiler/ppc/move.lisp
+++ src/compiler/ppc/move.lisp
@@ -27,7 +27,8 @@
                           character-widetag)))
       (structure-object
        (if (eq val sb-lockless:+tail+)
-           (inst addi y null-tn (- sb-vm::lockfree-list-tail-value sb-vm:nil-value))
+           (inst addi y null-tn (- lockfree-list-tail-value-offset
+                                   nil-value-offset))
            (bug "immediate structure-object ~S" val))))))
 
 (define-move-fun (load-number 1) (vop x y)
diff --git src/compiler/ppc64/arith.lisp src/compiler/ppc64/arith.lisp
index adb3f7574..b4ab61882 100644
--- src/compiler/ppc64/arith.lisp
+++ src/compiler/ppc64/arith.lisp
@@ -240,6 +240,19 @@
   (define-const-logop logior 2 ori oris or)
   (define-const-logop logxor 2 xori xoris xor))
 
+(define-vop (fast-logand/signed-unsigned=>unsigned fast-logand/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r)
+         (y :scs (unsigned-reg) :target r))
+  (:arg-types signed-num unsigned-num))
+
+(define-vop (fast-logand-c/signed-unsigned=>unsigned fast-logand/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r))
+  (:arg-types signed-num (:constant (eql #.most-positive-word)))
+  (:info y)
+  (:ignore y)
+  (:generator 1
+    (move r x)))
+
 (define-vop (fast-*/fixnum=>fixnum fast-fixnum-binop)
   (:temporary (:scs (non-descriptor-reg)) temp)
   (:translate *)
@@ -1016,19 +1029,6 @@
     (inst mulhdu temp x y)
     (inst clrrdi hi temp n-fixnum-tag-bits)))
 
-(define-vop (bignum-lognot lognot-mod64/unsigned=>unsigned)
-  (:translate sb-bignum:%lognot))
-
-(define-vop (fixnum-to-digit)
-  (:translate sb-bignum:%fixnum-to-digit)
-  (:policy :fast-safe)
-  (:args (fixnum :scs (any-reg)))
-  (:arg-types tagged-num)
-  (:results (digit :scs (unsigned-reg)))
-  (:result-types unsigned-num)
-  (:generator 1
-    (inst sradi digit fixnum n-fixnum-tag-bits)))
-
 ;;; Algorithm from page 74 of of Power ISA version 2.07
 ;;; under "Programming Note" for the divweu instruction
 ;;; with modifications as described at the divdeu instruction.
diff --git src/compiler/ppc64/memory.lisp src/compiler/ppc64/memory.lisp
index ea8889006..99a00ecf4 100644
--- src/compiler/ppc64/memory.lisp
+++ src/compiler/ppc64/memory.lisp
@@ -14,7 +14,7 @@
 
 (defun emit-gengc-barrier (object cell-address temps &optional value-tn-ref value-tn)
   (aver (neq (car temps) cell-address)) ; LD would clobber the cell-address
-  (when (require-gc-store-barrier-p object value-tn-ref value-tn)
+  (when (require-gengc-barrier-p object value-tn-ref value-tn)
     ;; (inst ld (car temps) thread-base-tn (ash thread-card-table-slot word-shift))
     ;; RLIDCL dest, source, (64-rightshift), (64-indexbits)
     (inst rldicl (car temps) (or cell-address object) (- 64 gencgc-card-shift)
diff --git src/compiler/ppc64/move.lisp src/compiler/ppc64/move.lisp
index 51186d434..c193dcd8c 100644
--- src/compiler/ppc64/move.lisp
+++ src/compiler/ppc64/move.lisp
@@ -27,7 +27,8 @@
                           character-widetag)))
       (structure-object
        (if (eq val sb-lockless:+tail+)
-           (inst addi y null-tn (- sb-vm::lockfree-list-tail-value sb-vm:nil-value))
+           (inst addi y null-tn (- lockfree-list-tail-value-offset
+                                   nil-value-offset))
            (bug "immediate structure-object ~S" val))))))
 
 (define-move-fun (load-number 1) (vop x y)
diff --git src/compiler/riscv/arith.lisp src/compiler/riscv/arith.lisp
index 264f8b7a3..0b982b321 100644
--- src/compiler/riscv/arith.lisp
+++ src/compiler/riscv/arith.lisp
@@ -141,6 +141,18 @@
 (define-binop logxor 1 3 xor xori)
 (define-binop logand 1 3 and andi)
 
+(define-vop (fast-logand/signed-unsigned=>unsigned fast-logand/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r)
+         (y :scs (unsigned-reg) :target r))
+  (:arg-types signed-num unsigned-num))
+
+(define-vop (fast-logand-c/signed-unsigned=>unsigned fast-logand-c/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r))
+  (:arg-types signed-num (:constant (eql #.most-positive-word)))
+  (:ignore y)
+  (:generator 1
+    (move r x)))
+
 (define-source-transform logeqv (&rest args)
   (if (oddp (length args))
       `(logxor ,@args)
@@ -798,20 +810,6 @@
     (inst mulhu temp x y)
     (inst andi hi temp (lognot fixnum-tag-mask))))
 
-(define-vop (bignum-lognot #-64-bit lognot-mod32/unsigned=>unsigned
-                           #+64-bit lognot-mod64/unsigned=>unsigned)
-  (:translate sb-bignum:%lognot))
-
-(define-vop (fixnum-to-digit)
-  (:translate sb-bignum:%fixnum-to-digit)
-  (:policy :fast-safe)
-  (:args (fixnum :scs (any-reg)))
-  (:arg-types tagged-num)
-  (:results (digit :scs (unsigned-reg)))
-  (:result-types unsigned-num)
-  (:generator 1
-    (inst srai digit fixnum n-fixnum-tag-bits)))
-
 (define-vop (bignum-floor)
   (:translate sb-bignum:%bigfloor)
   (:policy :fast-safe)
diff --git src/compiler/riscv/call.lisp src/compiler/riscv/call.lisp
index d6a0aa147..6b407b0e8 100644
--- src/compiler/riscv/call.lisp
+++ src/compiler/riscv/call.lisp
@@ -676,16 +676,15 @@
                     (do-next-filler)
                     (insert-step-instrumenting function)))
                  (:direct
-                  `((let ((offset (static-fun-offset fun)))
-                       (cond ((typep offset 'short-immediate)
-                              (inst #-64-bit lw #+64-bit ld function null-tn offset))
-                             ((typep (+ nil-value offset) 'u+i-immediate)
-                              (multiple-value-bind (u i)
-                                  (u-and-i-inst-immediate (+ nil-value offset))
-                                (inst lui function u)
-                                (inst #-64-bit lw #+64-bit ld function function i)))
-                             (t
-                              (error "Static function offset for ~a too far." fun)))))))
+                  `((etypecase (static-fun-offset fun)
+                      (short-immediate
+                       (inst #-64-bit lw #+64-bit ld function null-tn (static-fun-offset fun)))
+                      (u+i-immediate
+                       (multiple-value-bind (u i)
+                           (u-and-i-inst-immediate (static-fun-offset fun))
+                         (inst lui function u)
+                         (inst add function null-tn function)
+                         (inst #-64-bit lw #+64-bit ld function function i)))))))
              (loop
                (if filler
                    (do-next-filler)
diff --git src/compiler/riscv/insts.lisp src/compiler/riscv/insts.lisp
index b547a70d3..04ff8098c 100644
--- src/compiler/riscv/insts.lisp
+++ src/compiler/riscv/insts.lisp
@@ -20,6 +20,8 @@
             sb-vm::zero
             sb-vm::zero-offset
             sb-vm::lip-tn sb-vm::zero-tn
+            sb-vm::code-tn
+            sb-vm::tn-byte-offset
             ;; Types
             sb-vm::u-and-i-inst-immediate
             sb-vm::short-immediate
@@ -930,6 +932,20 @@
                          (component-header-length))
                       other-pointer-lowtag)))))
 
+(define-instruction load-far-constant (segment dest src)
+  (:emitter
+   ;; pc - (code - other-pointer-tag) = header + position
+   ;; (code - other-pointer-tag) - pc + const = const - header - position
+   (let ((offset (- (tn-byte-offset src) (component-header-length))))
+     (emit-back-patch
+      segment 8
+      (lambda (segment position)
+        (assemble (segment)
+          (multiple-value-bind (u i)
+              (u-and-i-inst-immediate (- offset position))
+            (inst auipc lip-tn u)
+            (inst #-64-bit lw #+64-bit ld dest lip-tn i))))))))
+
 (defun emit-header-data (segment type)
   (emit-back-patch
    segment n-word-bytes
diff --git src/compiler/riscv/macros.lisp src/compiler/riscv/macros.lisp
index b41145349..cdfadfb97 100644
--- src/compiler/riscv/macros.lisp
+++ src/compiler/riscv/macros.lisp
@@ -606,19 +606,19 @@ and
 
 (defun load-alloc-free-pointer (reg)
   #-sb-thread
-  (loadw reg null-tn 0 (- nil-value mixed-region))
+  (loadw reg null-tn 0 (- nil-value-offset mixed-region-offset))
   #+sb-thread
   (loadw reg thread-base-tn thread-mixed-tlab-slot))
 
 (defun load-alloc-end-addr (reg)
   #-sb-thread
-  (loadw reg null-tn 1 (- nil-value mixed-region))
+  (loadw reg null-tn 1 (- nil-value-offset mixed-region-offset))
   #+sb-thread
   (loadw reg thread-base-tn (+ thread-mixed-tlab-slot 1)))
 
 (defun store-alloc-free-pointer (reg)
   #-sb-thread
-  (storew reg null-tn 0 (- nil-value mixed-region))
+  (storew reg null-tn 0 (- nil-value-offset mixed-region-offset))
   #+sb-thread
   (storew reg thread-base-tn thread-mixed-tlab-slot))
 
diff --git src/compiler/riscv/move.lisp src/compiler/riscv/move.lisp
index 916f7150b..59efc2386 100644
--- src/compiler/riscv/move.lisp
+++ src/compiler/riscv/move.lisp
@@ -27,7 +27,8 @@
                           character-widetag)))
       (structure-object
        (if (eq val sb-lockless:+tail+)
-           (inst addi y null-tn (- sb-vm::lockfree-list-tail-value sb-vm:nil-value))
+           (inst addi y null-tn (- lockfree-list-tail-value-offset
+                                   nil-value-offset))
            (bug "immediate structure-object ~S" val))))))
 
 (define-move-fun (load-number 1) (vop x y)
@@ -50,12 +51,7 @@
       (short-immediate
        (loadw y code-tn (tn-offset x) other-pointer-lowtag))
       (u+i-immediate
-       (multiple-value-bind (u i)
-           (u-and-i-inst-immediate offset)
-         ;; Should be GC safe.
-         (inst lui y u)
-         (inst add lip-tn code-tn y)
-         (inst #-64-bit lw #+64-bit ld y lip-tn i))))))
+       (inst load-far-constant y x)))))
 
 (define-move-fun (load-stack 5) (vop x y)
   ((control-stack) (any-reg descriptor-reg))
diff --git src/compiler/sparc/arith.lisp src/compiler/sparc/arith.lisp
index 5bb6c12e4..541e7ed5e 100644
--- src/compiler/sparc/arith.lisp
+++ src/compiler/sparc/arith.lisp
@@ -179,6 +179,13 @@
   (:arg-types signed-num unsigned-num)
   (:translate logand))
 
+(define-vop (fast-logand-c/signed-unsigned=>unsigned fast-logand-c/unsigned=>unsigned)
+  (:args (x :scs (signed-reg) :target r))
+  (:arg-types signed-num (:constant (eql #.most-positive-word)))
+  (:ignore y)
+  (:generator 1
+    (move r x)))
+
 ;;; Truncate
 
 ;; This doesn't work for some reason.
@@ -976,19 +983,6 @@
   (:generator 40
     (emit-multiply x y hi lo)))
 
-(define-vop (bignum-lognot lognot-mod32/unsigned=>unsigned)
-  (:translate sb-bignum:%lognot))
-
-(define-vop (fixnum-to-digit)
-  (:translate sb-bignum:%fixnum-to-digit)
-  (:policy :fast-safe)
-  (:args (fixnum :scs (any-reg)))
-  (:arg-types tagged-num)
-  (:results (digit :scs (unsigned-reg)))
-  (:result-types unsigned-num)
-  (:generator 1
-    (inst sra digit fixnum n-fixnum-tag-bits)))
-
 (define-vop (bignum-floor)
   (:translate sb-bignum:%bigfloor)
   (:policy :fast-safe)
diff --git src/compiler/sparc/macros.lisp src/compiler/sparc/macros.lisp
index 8722d5fa2..61a4c1abb 100644
--- src/compiler/sparc/macros.lisp
+++ src/compiler/sparc/macros.lisp
@@ -174,8 +174,8 @@
 
      ;; Normal allocation to the heap -- gencgc version.
      (t
-      (loadw result-tn null-tn 0 (- nil-value mixed-region)) ; free_pointer
-      (loadw temp-tn null-tn 1 (- nil-value mixed-region))   ; end_addr
+      (loadw result-tn null-tn 0 (- nil-value-offset mixed-region-offset)) ; free_pointer
+      (loadw temp-tn null-tn 1 (- nil-value-offset mixed-region-offset))   ; end_addr
 
       (without-scheduling ()
         (let ((done (gen-label))
@@ -201,7 +201,7 @@
           ;; the branch delay slot to write back the free-pointer
           ;; (on overflow restore it the trap handler to a good value),
           ;; and fold the lowtag addition into the size subtraction.
-          (storew result-tn null-tn 0 (- nil-value mixed-region))
+          (storew result-tn null-tn 0 (- nil-value-offset mixed-region-offset))
           ;; Compute the base pointer and add lowtag.
           (cond ((integerp size)
                  (inst sub result-tn (- size lowtag)))
diff --git src/compiler/sparc/move.lisp src/compiler/sparc/move.lisp
index e930c8e75..5f7a928d0 100644
--- src/compiler/sparc/move.lisp
+++ src/compiler/sparc/move.lisp
@@ -27,7 +27,8 @@
                           character-widetag)))
       (structure-object
        (if (eq val sb-lockless:+tail+)
-           (inst add y null-tn (- sb-vm::lockfree-list-tail-value sb-vm:nil-value))
+           (inst add y null-tn (- lockfree-list-tail-value-offset
+                                  nil-value-offset))
            (bug "immediate structure-object ~S" val))))))
 
 (define-move-fun (load-number 1) (vop x y)
diff --git src/compiler/srctran.lisp src/compiler/srctran.lisp
index aee89a958..4c0184b7f 100644
--- src/compiler/srctran.lisp
+++ src/compiler/srctran.lisp
@@ -685,13 +685,13 @@
 
 ;;; See whether the interval X contains the number P, taking into
 ;;; account that the interval might not be closed.
-(defun interval-contains-p (p x)
+(defun interval-contains-p (p interval)
   (declare (type number p)
-           (type interval x))
-  ;; Does the interval X contain the number P?  This would be a lot
+           (type interval interval))
+  ;; Does the interval INTERVAL contain the number P?  This would be a lot
   ;; easier if all intervals were closed!
-  (let ((lo (interval-low x))
-        (hi (interval-high x)))
+  (let ((lo (interval-low interval))
+        (hi (interval-high interval)))
     (cond ((and lo hi)
            ;; The interval is bounded
            (if (and (sb-xc:<= (type-bound-number lo) p)
@@ -1833,7 +1833,9 @@
            (defun ,r-aux (number-type divisor-type)
              (let* ((divisor-interval
                      (numeric-type->interval divisor-type))
-                    (rem (,r-name divisor-interval))
+                    (number-interval
+                      (numeric-type->interval number-type))
+                    (rem (,r-name number-interval divisor-interval))
                     (result-type (rem-result-type number-type divisor-type)))
                (multiple-value-bind (class format)
                    (ecase result-type
@@ -1930,9 +1932,7 @@
            +
            (type-bound-number hi))))))
 
-(defun floor-rem-bound (div)
-  ;; The remainder depends only on the divisor. Try to get the
-  ;; correct sign for the remainder if we can.
+(defun floor-rem-bound (num div)
   (case (interval-range-info div)
     (+
      ;; The divisor is always positive.
@@ -1943,6 +1943,12 @@
          ;; The remainder never contains the upper bound. However,
          ;; watch out for the case where the high limit is zero!
          (setf (interval-high rem) (list (interval-high rem))))
+       ;; The remainder can't be greater than the number
+       ;; if it's getting truncated towards zero.
+       (when (and (eq (interval-range-info num) '+)
+                  (numberp (interval-high num))
+                  (interval-contains-p (interval-high num) rem))
+         (setf (interval-high rem) (interval-high num)))
        rem))
     (-
      ;; The divisor is always negative.
@@ -1951,6 +1957,12 @@
        (when (numberp (interval-low rem))
          ;; The remainder never contains the lower bound.
          (setf (interval-low rem) (list (interval-low rem))))
+       ;; The remainder can't be greater than the number
+       ;; if it's getting truncated towards zero.
+       (when (and (eq (interval-range-info num) '-)
+                  (numberp (interval-low num))
+                  (interval-contains-p (interval-low num) rem))
+         (setf (interval-low rem) (interval-low num)))
        rem))
     (otherwise
      ;; The divisor can be positive or negative. All bets off. The
@@ -2026,9 +2038,7 @@
            +
            (type-bound-number hi))))))
 
-(defun ceiling-rem-bound (div)
-  ;; The remainder depends only on the divisor. Try to get the
-  ;; correct sign for the remainder if we can.
+(defun ceiling-rem-bound (num div)
   (case (interval-range-info div)
     (+
      ;; Divisor is always positive. The remainder is negative.
@@ -2039,14 +2049,27 @@
          ;; The remainder never contains the upper bound. However,
          ;; watch out for the case when the upper bound is zero!
          (setf (interval-low rem) (list (interval-low rem))))
+       ;; The remainder can't be greater than the number
+       ;; if it's getting truncated towards zero.
+       (when (and (eq (interval-range-info num) '-)
+                  (numberp (interval-low num))
+                  (interval-contains-p (interval-low num) rem))
+         (setf (interval-low rem) (interval-low num)))
        rem))
     (-
-     ;; Divisor is always negative. The remainder is positive
      (let ((rem (interval-abs div)))
+       ;; Divisor is always negative. The remainder is positive
        (setf (interval-low rem) 0)
        (when (numberp (interval-high rem))
          ;; The remainder never contains the lower bound.
-         (setf (interval-high rem) (list (interval-high rem))))
+         (setf (interval-high rem)
+               (list (interval-high rem))))
+       ;; The remainder can't be greater than the number
+       ;; if it's getting truncated towards zero.
+       (when (and (eq (interval-range-info num) '+)
+                  (numberp (interval-high num))
+                  (interval-contains-p (interval-high num) rem))
+         (setf (interval-high rem) (interval-high num)))
        rem))
     (otherwise
      ;; The divisor can be positive or negative. All bets off. The
@@ -2120,9 +2143,9 @@
     (+
      (case (interval-range-info div)
        (+
-        (floor-rem-bound div))
+        (floor-rem-bound num div))
        (-
-        (ceiling-rem-bound div))
+        (ceiling-rem-bound num div))
        (otherwise
         (destructuring-bind (neg pos) (interval-split 0 div t t)
           (interval-merge-pair (truncate-rem-bound num neg)
@@ -2130,9 +2153,9 @@
     (-
      (case (interval-range-info div)
        (+
-        (ceiling-rem-bound div))
+        (ceiling-rem-bound num div))
        (-
-        (floor-rem-bound div))
+        (floor-rem-bound num div))
        (otherwise
         (destructuring-bind (neg pos) (interval-split 0 div t t)
           (interval-merge-pair (truncate-rem-bound num neg)
@@ -2425,60 +2448,45 @@
     (xform spec env int '%deposit-field newbyte)))
 
 (defoptimizer (%ldb derive-type) ((size posn num))
-  (let ((size (lvar-type size)))
-    (if (and (numeric-type-p size)
-             (csubtypep size (specifier-type 'integer)))
-        (let ((size-high (numeric-type-high size)))
-          (if (and size-high (<= size-high sb-vm:n-word-bits))
-              (specifier-type `(unsigned-byte* ,size-high))
-              (specifier-type 'unsigned-byte)))
+  (let ((size-high (nth-value 1 (integer-type-numeric-bounds (lvar-type size)))))
+    (if size-high
+        (if (<= size-high sb-vm:n-word-bits)
+            (specifier-type `(unsigned-byte* ,size-high))
+            (specifier-type 'unsigned-byte))
         *universal-type*)))
 
 (defoptimizer (%mask-field derive-type) ((size posn num))
-  (let ((size (lvar-type size))
-        (posn (lvar-type posn)))
-    (if (and (numeric-type-p size)
-             (csubtypep size (specifier-type 'integer))
-             (numeric-type-p posn)
-             (csubtypep posn (specifier-type 'integer)))
-        (let ((size-high (numeric-type-high size))
-              (posn-high (numeric-type-high posn)))
-          (if (and size-high posn-high
-                   (<= (+ size-high posn-high) sb-vm:n-word-bits))
-              (specifier-type `(unsigned-byte* ,(+ size-high posn-high)))
-              (specifier-type 'unsigned-byte)))
-        *universal-type*)))
+  (let ((size-high (nth-value 1 (integer-type-numeric-bounds (lvar-type size))))
+        (posn-high (nth-value 1 (integer-type-numeric-bounds (lvar-type posn)))))
+    (if (and size-high posn-high
+             (<= (+ size-high posn-high) sb-vm:n-word-bits))
+        (specifier-type `(unsigned-byte* ,(+ size-high posn-high)))
+        (specifier-type 'unsigned-byte))))
 
 (defun %deposit-field-derive-type-aux (size posn int)
-  (let ((size (lvar-type size))
-        (posn (lvar-type posn))
+  (let ((size-high (nth-value 1 (integer-type-numeric-bounds (lvar-type size))))
+        (posn-high (nth-value 1 (integer-type-numeric-bounds (lvar-type posn))))
         (int (lvar-type int)))
-    (when (and (numeric-type-p size)
-               (numeric-type-p posn)
-               (numeric-type-p int))
-      (let ((size-high (numeric-type-high size))
-            (posn-high (numeric-type-high posn))
-            (high (numeric-type-high int))
-            (low (numeric-type-low int)))
-        (when (and size-high posn-high high low
-                   ;; KLUDGE: we need this cutoff here, otherwise we
-                   ;; will merrily derive the type of %DPB as
-                   ;; (UNSIGNED-BYTE 1073741822), and then attempt to
-                   ;; canonicalize this type to (INTEGER 0 (1- (ASH 1
-                   ;; 1073741822))), with hilarious consequences.  We
-                   ;; cutoff at 4*SB-VM:N-WORD-BITS to allow inference
-                   ;; over a reasonable amount of shifting, even on
-                   ;; the alpha/32 port, where N-WORD-BITS is 32 but
-                   ;; machine integers are 64-bits.  -- CSR,
-                   ;; 2003-09-12
-                   (<= (+ size-high posn-high) (* 4 sb-vm:n-word-bits)))
-          (let ((raw-bit-count (max (integer-length high)
-                                    (integer-length low)
-                                    (+ size-high posn-high))))
-            (specifier-type
-             (if (minusp low)
-                 `(signed-byte ,(1+ raw-bit-count))
-                 `(unsigned-byte* ,raw-bit-count)))))))))
+    (multiple-value-bind (low high) (integer-type-numeric-bounds int)
+      (when (and size-high posn-high high low
+                 ;; KLUDGE: we need this cutoff here, otherwise we
+                 ;; will merrily derive the type of %DPB as
+                 ;; (UNSIGNED-BYTE 1073741822), and then attempt to
+                 ;; canonicalize this type to (INTEGER 0 (1- (ASH 1
+                 ;; 1073741822))), with hilarious consequences.  We
+                 ;; cutoff at 4*SB-VM:N-WORD-BITS to allow inference
+                 ;; over a reasonable amount of shifting, even on
+                 ;; the alpha/32 port, where N-WORD-BITS is 32 but
+                 ;; machine integers are 64-bits.  -- CSR,
+                 ;; 2003-09-12
+                 (<= (+ size-high posn-high) (* 4 sb-vm:n-word-bits)))
+        (let ((raw-bit-count (max (integer-length high)
+                                  (integer-length low)
+                                  (+ size-high posn-high))))
+          (specifier-type
+           (if (minusp low)
+               `(signed-byte ,(1+ raw-bit-count))
+               `(unsigned-byte* ,raw-bit-count))))))))
 
 (defoptimizer (%dpb derive-type) ((newbyte size posn int))
   (%deposit-field-derive-type-aux size posn int))
@@ -2486,7 +2494,7 @@
 (defoptimizer (%deposit-field derive-type) ((newbyte size posn int))
   (%deposit-field-derive-type-aux size posn int))
 
-(deftransform %ldb ((size posn int) (fixnum fixnum integer) word)
+(deftransform %ldb ((size posn int) (fixnum fixnum integer) word :node node)
   "convert to inline logical operations"
   (let ((width (and (constant-lvar-p size)
                     (constant-lvar-p posn)
@@ -2503,6 +2511,21 @@
                  (posn (lvar-value posn)))
              `(logand (ash (logand int most-positive-word) ,(- posn))
                       ,(ash most-positive-word (- size sb-vm:n-word-bits)))))
+          ((let* ((size-max (nth-value 1 (integer-type-numeric-bounds (lvar-type size))))
+                  (posn-max (nth-value 1 (integer-type-numeric-bounds (lvar-type posn))))
+                  (width (and size-max posn-max
+                              (+ size-max posn-max))))
+             (cond ((not width) nil)
+                   ((<= width sb-vm:n-fixnum-bits)
+                    `(logand (ash (mask-signed-field sb-vm:n-fixnum-bits int) (- posn))
+                             (ash ,most-positive-word (- size ,sb-vm:n-word-bits))))
+                   ((<= width sb-vm:n-word-bits)
+                    `(logand (ash (logand int most-positive-word) (- posn))
+                             (ash ,most-positive-word (- size ,sb-vm:n-word-bits)))))))
+          ((not (or (csubtypep (lvar-type int) (specifier-type 'sb-vm:signed-word))
+                    (csubtypep (lvar-type int) (specifier-type 'word))))
+           (delay-ir1-transform node :ir1-phases)
+           (give-up-ir1-transform "not a word-sized integer"))
           (t
            `(logand (ash int (- posn))
                     (ash ,most-positive-word (- size ,sb-vm:n-word-bits)))))))
@@ -2634,18 +2657,28 @@
     (two-arg-derive-type n shift #'%ash/right-derive-type-aux #'%ash/right)))
 
 (defmacro combination-typed-p (node name &rest types)
-  `(and (combination-p ,node)
-        (eql (lvar-fun-name (combination-fun ,node)) ',name)
-        (let ((args (combination-args ,node)))
-          ,@(loop for type in types
-                  collect
-                  `(let ((arg (pop args)))
-                     (and arg
-                          ,(if (typep type '(cons (eql :or)))
-                               `(or ,@(loop for type in (cdr type)
-                                            collect
-                                            `(csubtypep (lvar-type arg) (specifier-type ',type))))
-                               `(csubtypep (lvar-type arg) (specifier-type ',type)))))))))
+  (labels ((gen (type)
+             (typecase type
+               ((cons (eql :or))
+                `(or ,@(loop for type in (cdr type)
+                             collect
+                             (gen type))))
+               ((cons (eql :and))
+                `(and ,@(loop for type in (cdr type)
+                              collect
+                              (gen type))))
+               ((cons (eql :not))
+                `(not ,(gen (cadr type))))
+               (t
+                `(csubtypep (lvar-type arg) (specifier-type ',type))))))
+    `(and (combination-p ,node)
+          (eql (lvar-fun-name (combination-fun ,node)) ',name)
+          (let ((args (combination-args ,node)))
+            ,@(loop for type in types
+                    collect
+                    `(let ((arg (pop args)))
+                       (and arg
+                            ,(gen type))))))))
 
 (when-vop-existsp (:translate ash-inverted)
   (defun ash-inverted (integer amount)
@@ -2666,8 +2699,9 @@
                (setf truly-type t))
               (t
                (give-up-ir1-transform))))
-      (cond ((combination-typed-p use %negate (:or word
-                                                   sb-vm:signed-word))
+      (cond ((combination-typed-p use %negate (:and (:not (integer * 0))
+                                                    (:or word
+                                                         sb-vm:signed-word)))
              (splice-fun-args amount '%negate 1)
              (if truly-type
                  `(truly-the word (ash-inverted integer amount))
@@ -2690,8 +2724,9 @@
                (setf truly-type t))
               (t
                (give-up-ir1-transform))))
-      (cond ((combination-typed-p use %negate (:or word
-                                                   sb-vm:signed-word))
+      (cond ((combination-typed-p use %negate (:and (:not (integer * 0))
+                                                    (:or word
+                                                         sb-vm:signed-word)))
              (splice-fun-args amount '%negate 1)
              (if truly-type
                  `(truly-the sb-vm:signed-word (ash-inverted integer amount))
@@ -2828,6 +2863,11 @@
     (when (or (csubtypep type (specifier-type 'word))
               (csubtypep type (specifier-type 'sb-vm:signed-word)))
       (give-up-ir1-transform))
+    (unless (and (or (csubtypep (lvar-type x) (specifier-type 'word))
+                     (csubtypep (lvar-type x) (specifier-type 'sb-vm:signed-word)))
+                 (or (csubtypep (lvar-type y) (specifier-type 'word))
+                     (csubtypep (lvar-type y) (specifier-type 'sb-vm:signed-word))))
+      (give-up-ir1-transform))
     (let* ((vops (fun-info-templates (fun-info-or-lose name)))
            (cast (or (cast-or-check-bound-type (node-lvar node))
                      (give-up-ir1-transform)))
@@ -2849,6 +2889,7 @@
              for (x-type y-type cast-type) = (fun-type-required (vop-info-type vop))
              when (and (csubtypep result-type (single-value-type (fun-type-returns (vop-info-type vop))))
                        (neq x-type *universal-type*)
+                       (neq y-type *universal-type*)
                        (or (and (subp x x-type)
                                 (subp y y-type))
                            (and swap
@@ -2874,15 +2915,23 @@
                  * :node node :important nil)
   (overflow-transform 'overflow- x y node nil))
 
+(deftransform ash ((x y) ((or word sb-vm:signed-word) (or word sb-vm:signed-word))
+                 * :node node :important nil)
+  (overflow-transform 'overflow-ash x y node nil))
 
-(defun overflow-transform-unknown-x (name x y node)
+(defun overflow-transform-unknown-x (name x y node &optional swap)
   (delay-ir1-transform node :ir1-phases)
   (let ((type (single-value-type (node-derived-type node)))
-        (x-type (lvar-type x)))
+        (x-type (lvar-type x))
+        (y-type (lvar-type y)))
     (when (or (csubtypep type (specifier-type 'word))
               (csubtypep type (specifier-type 'sb-vm:signed-word))
-              (csubtypep x-type (specifier-type 'word))
-              (csubtypep x-type (specifier-type 'sb-vm:signed-word)))
+              (if swap
+                  (or
+                   (csubtypep y-type (specifier-type 'word))
+                   (csubtypep y-type (specifier-type 'sb-vm:signed-word)))
+                  (or (csubtypep x-type (specifier-type 'word))
+                      (csubtypep x-type (specifier-type 'sb-vm:signed-word)))))
       (give-up-ir1-transform))
     (let* ((vops (fun-info-templates (fun-info-or-lose name)))
            (cast (or (cast-or-check-bound-type (node-lvar node) t)
@@ -2892,7 +2941,9 @@
         (unless (and (fixnump cast-low)
                      (fixnump cast-high))
           (give-up-ir1-transform))
-        (multiple-value-bind (y-low y-high) (integer-type-numeric-bounds (lvar-type y))
+        (multiple-value-bind (y-low y-high) (if swap
+                                                (integer-type-numeric-bounds x-type)
+                                                (integer-type-numeric-bounds y-type))
           (unless (and (fixnump y-low)
                        (fixnump y-high))
             (give-up-ir1-transform))
@@ -2903,8 +2954,11 @@
                        (and (> y-low distance-high)
                             (< y-high distance-low)))
                       (overflow-
-                       (and (> (- y-high) distance-high)
-                            (< (- y-low) distance-low)))
+                       (if swap
+                           (and (< y-high (+ (1+ most-positive-fixnum) cast-low))
+                                (> y-low (+ (1- most-negative-fixnum) cast-high)))
+                           (and (> (- y-high) distance-high)
+                                (< (- y-low) distance-low))))
                       (overflow*
                        (or (> y-low 0)
                            (< y-high -1))))
@@ -2923,8 +2977,10 @@
                             (sb-xc:typep value type)))))))
             (loop for vop in vops
                   for (x-type y-type cast-type) = (fun-type-required (vop-info-type vop))
-                  when (and (eq x-type *universal-type*)
-                            (csubtypep result-type (single-value-type (fun-type-returns (vop-info-type vop))))
+                  when (and (csubtypep result-type (single-value-type (fun-type-returns (vop-info-type vop))))
+                            (if swap
+                                (eq y-type *universal-type*)
+                                (eq x-type *universal-type*))
                             (and (subp x x-type)
                                  (subp y y-type)))
                   return `(%primitive ,(vop-info-name vop)
@@ -2952,6 +3008,35 @@
                  * :node node :important nil)
   (overflow-transform-unknown-x 'overflow- x y node))
 
+(deftransform - ((x y) ((or word sb-vm:signed-word) t)
+                 * :node node :important nil)
+  (overflow-transform-unknown-x 'overflow- x y node t))
+
+(defun overflow-transform-1 (name x node)
+  (delay-ir1-transform node :ir1-phases)
+  (let ((type (single-value-type (node-derived-type node))))
+    (when (or (csubtypep type (specifier-type 'word))
+              (csubtypep type (specifier-type 'sb-vm:signed-word)))
+      (give-up-ir1-transform))
+    (unless (and (or (csubtypep (lvar-type x) (specifier-type 'word))
+                     (csubtypep (lvar-type x) (specifier-type 'sb-vm:signed-word))))
+      (give-up-ir1-transform))
+    (let* ((vops (fun-info-templates (fun-info-or-lose name)))
+           (cast (or (cast-or-check-bound-type (node-lvar node))
+                     (give-up-ir1-transform)))
+           (result-type (type-intersection type cast)))
+      (loop for vop in vops
+            for (x-type cast-type) = (fun-type-required (vop-info-type vop))
+            when (and (csubtypep result-type (single-value-type (fun-type-returns (vop-info-type vop))))
+                      (neq x-type *universal-type*)
+                      (csubtypep (lvar-type x) x-type))
+            return `(%primitive ,(vop-info-name vop) x ',(type-specifier cast))
+            finally (give-up-ir1-transform)))))
+
+(deftransform %negate ((x) ((or word sb-vm:signed-word))
+                       * :node node :important nil)
+  (overflow-transform-1 'overflow-negate x node))
+
 ;;; These must come before the ones below, so that they are tried
 ;;; first.
 (deftransform floor ((number divisor))
@@ -3213,8 +3298,10 @@
                                 (constant-arg sb-vm:signed-word))
                          *
                          :policy (and (> speed compilation-speed)
-                                      (> speed space)))
+                                      (> speed space))
+                         :node node)
    "convert integer division to multiplication"
+   (delay-ir1-transform node :ir1-phases)
    (let* ((y      (lvar-value y))
           (abs-y  (abs y))
           (x-type (lvar-type x)))
@@ -3229,7 +3316,7 @@
              (values (1- sb-vm:n-word-bits)
                      (expt 2 (1- sb-vm:n-word-bits))))
          ;; Division by zero, one or powers of two is handled elsewhere.
-         (when (or (zerop (logand y (1- y)))
+         (when (or (zerop (logand abs-y (1- abs-y)))
                    ;; Leave it for the unsigned transform
                    (and (plusp y)
                         (not (types-equal-or-intersect x-type
@@ -3274,8 +3361,10 @@
 (deftransform truncate ((x y) (word (constant-arg word))
                         *
                         :policy (and (> speed compilation-speed)
-                                     (> speed space)))
+                                     (> speed space))
+                        :node node)
   "convert integer division to multiplication"
+  (delay-ir1-transform node :ir1-phases)
   (let* ((y      (lvar-value y))
          (x-type (lvar-type x))
          (max-x  (or (and (numeric-type-p x-type)
@@ -3467,6 +3556,18 @@
   (def / x (%negate x))
   (def expt x (/ 1 x)))
 
+(deftransform + ((x y) (number number))
+  (cond ((splice-fun-args y '%negate 1 nil)
+         `(- x y))
+        ((splice-fun-args x '%negate 1 nil)
+         `(- y x))
+        (t
+         (give-up-ir1-transform))))
+
+(deftransform - ((x y) (number number))
+  (splice-fun-args y '%negate 1)
+  `(+ x y))
+
 ;;; Fold (expt x n) into multiplications for small integral values of
 ;;; N; convert (expt x 1/2) to sqrt.
 (deftransform expt ((x y) (t (constant-arg real)) *)
@@ -4244,7 +4345,7 @@
   (def >= > floor))
 
 (macrolet ((def (name x y type-x type-y)
-             `(deftransform ,name ((,x ,y) (,type-x ,type-y) * :node node)
+             `(deftransform ,name ((,x ,y) (,type-x ,type-y) * :node node :important nil)
                 (cond ((or (csubtypep (lvar-type i) (specifier-type 'word))
                            (csubtypep (lvar-type i) (specifier-type 'sb-vm:signed-word)))
                        (give-up-ir1-transform))
@@ -4261,10 +4362,10 @@
   (def > i f (integer * #.most-positive-fixnum) fixnum)
   (def < f i fixnum (integer * #.most-positive-fixnum)))
 
-(deftransform < ((x y) (integer (eql #.(1+ most-positive-fixnum))))
+(deftransform < ((x y) (integer (eql #.(1+ most-positive-fixnum))) * :important nil)
   `(not (> x most-positive-fixnum)))
 
-(deftransform > ((x y) (integer (eql #.(1- most-negative-fixnum))))
+(deftransform > ((x y) (integer (eql #.(1- most-negative-fixnum))) * :important nil)
   `(not (< x most-negative-fixnum)))
 
 (deftransform = ((x y) (rational (constant-arg float)))
diff --git src/compiler/sxhash.lisp src/compiler/sxhash.lisp
index fc0e1c282..bc3c61712 100644
--- src/compiler/sxhash.lisp
+++ src/compiler/sxhash.lisp
@@ -145,7 +145,7 @@
                     (xset-every #'cl:symbol-package
                                 (sb-kernel::member-type-xset (lvar-type x))))))
          `(symbol-hash x)) ; Never need to lazily compute and memoize
-        ((gethash 'ensure-symbol-hash *backend-parsed-vops*)
+        ((vop-existsp :translate ensure-symbol-hash)
          ;; A vop might emit slightly better code than the expression below
          `(ensure-symbol-hash x))
         (t
diff --git src/compiler/typetran.lisp src/compiler/typetran.lisp
index 7f929e0c8..689fb2572 100644
--- src/compiler/typetran.lisp
+++ src/compiler/typetran.lisp
@@ -340,6 +340,9 @@
                     `(and (not (eq ,object 0))
                           ,mod-p)
                     mod-p)))
+             ((type= type (specifier-type '(or word sb-vm:signed-word)))
+              `(or (typep ,object 'sb-vm:signed-word)
+                   (typep ,object 'word)))
              (t
               `(and (typep ,object ',base)
                     ,(transform-numeric-bound-test object type base)))))
diff --git src/compiler/x86-64/alloc.lisp src/compiler/x86-64/alloc.lisp
index 1ebb9a175..3f767bf05 100644
--- src/compiler/x86-64/alloc.lisp
+++ src/compiler/x86-64/alloc.lisp
@@ -52,17 +52,6 @@
   (aver (= thread-tot-bytes-alloc-unboxed-slot
            (1+ thread-tot-bytes-alloc-boxed-slot))))
 
-;;; the #+allocator metrics histogram contains an exact count
-;;; for all sizes up to (* cons-size n-word-bytes histogram-small-bins).
-;;; Larger allocations are grouped by the binary log of the size.
-;;; It seems that 99.5% of all allocations are less than the small bucket limit,
-;;; making the histogram fairly exact except for the tail.
-(defparameter *consing-histo* nil)
-(defconstant non-small-bucket-offset
-  (+ histogram-small-bins
-     (- (integer-length (* sb-vm::histogram-small-bins
-                           sb-vm:cons-size sb-vm:n-word-bytes)))))
-
 ;;; Emit counter increments for SB-APROF. SCRATCH-REGISTERS is either a TN
 ;;; or list of TNs that can be used to store into the profiling data.
 ;;; We pick one of the available TNs to use for addressing the data buffer.
@@ -85,51 +74,66 @@
   ;; so we may as well take advantage of this fact to load the temp reg
   ;; here, if provided, rather than spewing more #+gs-seg tests around.
   #+gs-seg (when thread-temp (inst rdgsbase thread-temp))
-  #+allocator-metrics
-  (let ((use-size-temp (not (typep size '(or (signed-byte 32) tn))))
-        (tally (gen-label))
-        (inexact (gen-label)))
-    (cond ((tn-p type) ; from ALLOCATE-VECTOR-ON-HEAP
-           ;; Constant huge size + unknown type can't occur.
-           (aver (not use-size-temp))
-           (inst cmp :byte type simple-vector-widetag)
-           (inst set :ne temp)
-           (inst and :dword temp 1)
-           (inst add :qword
-                 (ea thread-segment-reg
-                     (ash thread-tot-bytes-alloc-boxed-slot word-shift)
-                     thread-tn temp 8)
-                 size))
-          (t
-           (inst add :qword
-                 (thread-slot-ea (if (alloc-unboxed-p type)
-                                     thread-tot-bytes-alloc-unboxed-slot
-                                     thread-tot-bytes-alloc-boxed-slot))
-                 (cond (use-size-temp (inst mov temp size) temp)
-                       (t size)))))
-    (cond ((tn-p size)
-           (inst cmp size (* histogram-small-bins 16))
-           (inst jmp :g inexact)
-           (inst mov :dword temp size)
-           (inst shr :dword temp (1+ word-shift))
-           (inst dec :dword temp)
-           (inst jmp tally)
-           (emit-label inexact)
-           (inst bsr temp size)
-           ;; bsr returns 1 less than INTEGER-LENGTH
-           (inst add :dword temp (1+ non-small-bucket-offset))
-           (emit-label tally)
-           (inst inc :qword (ea thread-segment-reg
-                                (ash thread-obj-size-histo-slot word-shift)
-                                thread-tn temp 8)))
-          (t
-           (let* ((n-conses (/ size (* sb-vm:cons-size sb-vm:n-word-bytes)))
-                  (bucket (if (<= n-conses histogram-small-bins)
-                              (1- n-conses)
-                              (+ (integer-length size)
-                                 non-small-bucket-offset))))
-             (inst inc :qword
-                   (thread-slot-ea (+ thread-obj-size-histo-slot bucket)))))))
+  (when (member :allocation-size-histogram sb-xc:*features*)
+    (let ((use-size-temp (not (typep size '(or (signed-byte 32) tn)))))
+      ;; Sum up the sizes of boxed vs unboxed allocations.
+      (cond ((tn-p type) ; from ALLOCATE-VECTOR-ON-HEAP
+             ;; Constant huge size + unknown type can't occur.
+             (aver (not use-size-temp))
+             (inst cmp :byte type simple-vector-widetag)
+             (inst set :ne temp)
+             (inst and :dword temp 1)
+             (inst add :qword
+                   (ea thread-segment-reg
+                       (ash thread-tot-bytes-alloc-boxed-slot word-shift)
+                       thread-tn temp 8)
+                   size))
+            (t
+             (inst add :qword
+                   (thread-slot-ea (if (alloc-unboxed-p type)
+                                       thread-tot-bytes-alloc-unboxed-slot
+                                       thread-tot-bytes-alloc-boxed-slot))
+                   (cond (use-size-temp (inst mov temp size) temp)
+                         (t size)))))
+      (cond ((tn-p size)
+             (assemble ()
+               ;; optimistically assume it's a small object, so just divide
+               ;; the size by the size of a cons to get a (1-based) index.
+               (inst mov :dword temp size)
+               (inst shr :dword temp (1+ word-shift))
+               ;; now see if the computed index is in range
+               (inst cmp size (* n-histogram-bins-small 16))
+               (inst jmp :le OK)
+               ;; oversized. Compute the log2 of the size
+               (inst bsr :dword temp size)
+               ;; array of counts ... | array of sizes ...
+               (inst add :qword (ea (ash (+ thread-allocator-histogram-slot
+                                            1
+                                            (- first-large-histogram-bin-log2size)
+                                            n-histogram-bins-small
+                                            n-histogram-bins-large)
+                                         word-shift)
+                                    thread-tn temp 8)
+                     size)
+               ;; not sure why this is "2" and not "1" in the fudge factor!!
+               ;; (but the assertions come out right)
+               (inst add :dword temp
+                     (+ (- first-large-histogram-bin-log2size) n-histogram-bins-small 2))
+               OK
+               (inst inc :qword (ea thread-segment-reg
+                                    (ash (1- thread-allocator-histogram-slot) word-shift)
+                                    thread-tn temp 8))))
+            ((<= size (* sb-vm:cons-size sb-vm:n-word-bytes n-histogram-bins-small))
+             (let ((index (1- (/ size (* sb-vm:cons-size sb-vm:n-word-bytes)))))
+               (inst inc :qword (thread-slot-ea (+ thread-allocator-histogram-slot index)))))
+            (t
+             (let ((index (- (integer-length size) first-large-histogram-bin-log2size)))
+               (inst add :qword (thread-slot-ea (+ thread-allocator-histogram-slot
+                                                   n-histogram-bins-small
+                                                   n-histogram-bins-large index))
+                     size)
+               (inst inc :qword (thread-slot-ea (+ thread-allocator-histogram-slot
+                                                   n-histogram-bins-small index))))))))
   (when (policy node (> sb-c::instrument-consing 1))
     (when (tn-p size)
       (aver (not (location= size temp))))
@@ -226,8 +230,11 @@
                                              thread-cons-tlab-slot
                                              thread-mixed-tlab-slot))))
                            (thread-slot-ea slot #+gs-seg thread-temp))
-                         #-sb-thread (ea (if (eql type +cons-primtype+)
-                                             cons-region mixed-region)))
+                         #-sb-thread
+                         (ea (+ static-space-start
+                                (if (eql type +cons-primtype+)
+                                    cons-region-offset
+                                    mixed-region-offset))))
            (end-addr (ea (sb-x86-64-asm::ea-segment free-pointer)
                          (+ n-word-bytes (ea-disp free-pointer))
                          (ea-base free-pointer))))
@@ -314,6 +321,13 @@
       (when init
         (funcall init)))))
 
+(defun list-ctor-push-elt (x scratch)
+  (inst push (if (sc-is x immediate)
+                 (let ((bits (encode-value-if-immediate x)))
+                   (or (plausible-signed-imm32-operand-p bits)
+                       (progn (inst mov scratch bits) scratch)))
+                 x)))
+
 ;;;; CONS, ACONS, LIST and LIST*
 (macrolet ((pop-arg (ref)
              `(prog1 (tn-ref-tn ,ref) (setf ,ref (tn-ref-across ,ref))))
@@ -348,33 +362,51 @@
                   (setf prev-constant immediate-value)))))
 
 (define-vop (cons)
-  (:args (car :scs (any-reg descriptor-reg constant immediate))
-         (cdr :scs (any-reg descriptor-reg constant immediate)))
+  (:args (car :scs (any-reg descriptor-reg constant immediate control-stack))
+         (cdr :scs (any-reg descriptor-reg constant immediate control-stack)))
   (:temporary (:sc unsigned-reg :to (:result 0) :target result) alloc)
-  (:temporary (:sc unsigned-reg :to (:result 0)) temp)
+  (:temporary (:sc unsigned-reg :to (:result 0)
+               :unused-if (node-stack-allocate-p (sb-c::vop-node vop)))
+              temp)
   (:results (result :scs (descriptor-reg)))
   #+gs-seg (:temporary (:sc unsigned-reg :offset 15) thread-tn)
+  (:vop-var vop)
   (:node-var node)
   (:generator 10
-    (let ((stack-allocate-p (node-stack-allocate-p node))
-          (nbytes (* cons-size n-word-bytes))
-          (prev-constant temp)) ;; a non-eq initial value
-      (unless stack-allocate-p
-        (instrument-alloc +cons-primtype+ nbytes node (list temp alloc) thread-tn))
-      (pseudo-atomic (:elide-if stack-allocate-p :thread-tn thread-tn)
-        (if stack-allocate-p
-            (stack-allocation nbytes 0 alloc)
-            (allocation +cons-primtype+ nbytes 0 alloc node temp thread-tn))
-        (store-slot car alloc cons-car-slot 0)
-        (store-slot cdr alloc cons-cdr-slot 0)
-        (if (location= alloc result)
-            (inst or :byte alloc list-pointer-lowtag)
-            (inst lea result (ea list-pointer-lowtag alloc)))))))
+    (cond
+      ((node-stack-allocate-p node)
+       (inst and rsp-tn (lognot lowtag-mask))
+       (cond ((and (sc-is car immediate) (sc-is cdr immediate)
+                   (typep (encode-value-if-immediate car) '(signed-byte 8))
+                   (typep (encode-value-if-immediate cdr) '(signed-byte 8)))
+              ;; (CONS 0 0) takes just 4 bytes to encode the PUSHes (for example)
+              (inst push (encode-value-if-immediate cdr))
+              (inst push (encode-value-if-immediate car)))
+             ((and (sc-is car immediate) (sc-is cdr immediate)
+                   (eql (encode-value-if-immediate car) (encode-value-if-immediate cdr)))
+              (inst mov alloc (encode-value-if-immediate cdr))
+              (inst push alloc)
+              (inst push alloc))
+             (t
+              (list-ctor-push-elt cdr alloc)
+              (list-ctor-push-elt car alloc)))
+       (inst lea result (ea list-pointer-lowtag rsp-tn)))
+      (t
+       (let ((nbytes (* cons-size n-word-bytes))
+             (prev-constant temp)) ;; a non-eq initial value
+         (instrument-alloc +cons-primtype+ nbytes node (list temp alloc) thread-tn)
+         (pseudo-atomic (:thread-tn thread-tn)
+           (allocation +cons-primtype+ nbytes 0 alloc node temp thread-tn)
+           (store-slot car alloc cons-car-slot 0)
+           (store-slot cdr alloc cons-cdr-slot 0)
+           (if (location= alloc result)
+               (inst or :byte alloc list-pointer-lowtag)
+               (inst lea result (ea list-pointer-lowtag alloc)))))))))
 
 (define-vop (acons)
-  (:args (key :scs (any-reg descriptor-reg constant immediate))
-         (val :scs (any-reg descriptor-reg constant immediate))
-         (tail :scs (any-reg descriptor-reg constant immediate)))
+  (:args (key :scs (any-reg descriptor-reg constant immediate control-stack))
+         (val :scs (any-reg descriptor-reg constant immediate control-stack))
+         (tail :scs (any-reg descriptor-reg constant immediate control-stack)))
   (:temporary (:sc unsigned-reg :to (:result 0)) alloc)
   (:temporary (:sc unsigned-reg :to (:result 0) :target result) temp)
   (:results (result :scs (descriptor-reg)))
@@ -404,32 +436,41 @@
 ;;; CONS-2 is similar to ACONS, except that instead of producing
 ;;;  ((X . Y) . Z) it produces (X Y . Z)
 (define-vop (cons-2)
-  (:args (car :scs (any-reg descriptor-reg constant immediate))
-         (cadr :scs (any-reg descriptor-reg constant immediate))
-         (cddr :scs (any-reg descriptor-reg constant immediate)))
+  (:args (car :scs (any-reg descriptor-reg constant immediate control-stack))
+         (cadr :scs (any-reg descriptor-reg constant immediate control-stack))
+         (cddr :scs (any-reg descriptor-reg constant immediate control-stack)))
   (:temporary (:sc unsigned-reg :to (:result 0) :target result) alloc)
-  (:temporary (:sc unsigned-reg :to (:result 0)) temp)
+  (:temporary (:sc unsigned-reg :to (:result 0)
+               :unused-if (node-stack-allocate-p (sb-c::vop-node vop)))
+              temp)
   (:results (result :scs (descriptor-reg)))
   #+gs-seg (:temporary (:sc unsigned-reg :offset 15) thread-tn)
+  (:vop-var vop)
   (:node-var node)
   (:generator 10
-    (let ((stack-allocate-p (node-stack-allocate-p node))
-          (nbytes (* cons-size 2 n-word-bytes))
-          (prev-constant temp))
-      (unless stack-allocate-p
-        (instrument-alloc +cons-primtype+ nbytes node (list temp alloc) thread-tn))
-      (pseudo-atomic (:elide-if stack-allocate-p :thread-tn thread-tn)
-        (if stack-allocate-p
-            (stack-allocation nbytes 0 alloc)
-            (allocation +cons-primtype+ nbytes 0 alloc node temp thread-tn))
-        (store-slot car alloc cons-car-slot 0)
-        (store-slot cadr alloc (+ 2 cons-car-slot) 0)
-        (store-slot cddr alloc (+ 2 cons-cdr-slot) 0)
-        (inst lea temp (ea (+ 16 list-pointer-lowtag) alloc))
-        (store-slot temp alloc cons-cdr-slot 0)
-        (if (location= alloc result)
-            (inst or :byte alloc list-pointer-lowtag)
-            (inst lea result (ea list-pointer-lowtag alloc)))))))
+    (cond
+      ((node-stack-allocate-p node)
+       (inst and rsp-tn (lognot lowtag-mask))
+       (list-ctor-push-elt cddr alloc)
+       (list-ctor-push-elt cadr alloc)
+       (inst lea alloc (ea list-pointer-lowtag rsp-tn))
+       (inst push alloc) ; cdr of the first cons
+       (list-ctor-push-elt car alloc)
+       (inst lea result (ea list-pointer-lowtag rsp-tn)))
+      (t
+       (let ((nbytes (* cons-size 2 n-word-bytes))
+             (prev-constant temp))
+         (instrument-alloc +cons-primtype+ nbytes node (list temp alloc) thread-tn)
+         (pseudo-atomic (:thread-tn thread-tn)
+           (allocation +cons-primtype+ nbytes 0 alloc node temp thread-tn)
+           (store-slot car alloc cons-car-slot 0)
+           (store-slot cadr alloc (+ 2 cons-car-slot) 0)
+           (store-slot cddr alloc (+ 2 cons-cdr-slot) 0)
+           (inst lea temp (ea (+ 16 list-pointer-lowtag) alloc))
+           (store-slot temp alloc cons-cdr-slot 0)
+           (if (location= alloc result)
+               (inst or :byte alloc list-pointer-lowtag)
+               (inst lea result (ea list-pointer-lowtag alloc)))))))))
 
 (define-vop (list)
   (:args (things :more t :scs (descriptor-reg any-reg constant immediate)))
@@ -880,21 +921,37 @@
 
 ;;; The compiler likes to be able to directly make value cells.
 (define-vop (make-value-cell)
-  (:args (value :scs (descriptor-reg any-reg) :to :result))
+  (:args (value :scs (descriptor-reg any-reg immediate constant) :to :result))
   (:results (result :scs (descriptor-reg) :from :eval))
   #+gs-seg (:temporary (:sc unsigned-reg :offset 15) thread-tn)
   (:info stack-allocate-p)
   (:node-var node)
   (:generator 10
-    (cond (stack-allocate-p
-           (stack-allocation (pad-data-block value-cell-size) other-pointer-lowtag result)
-           (let ((header (compute-object-header value-cell-size value-cell-widetag)))
-             (storew header result 0 other-pointer-lowtag)
-             (storew value result value-cell-value-slot other-pointer-lowtag)))
-          (t
-           (alloc-other value-cell-widetag value-cell-size result node nil thread-tn
-                        (lambda ()
-                          (storew value result value-cell-value-slot other-pointer-lowtag)))))))
+    (let ((data (if (sc-is value immediate)
+                    (let ((bits (encode-value-if-immediate value)))
+                      (if (integerp bits)
+                          (constantize bits)
+                          bits)) ; could be a fixup
+                    value)))
+      (cond (stack-allocate-p
+             ;; No regression test got here. Therefore I think there's no such thing as a
+             ;; dynamic-extent value cell. It makes sense that there isn't: DX closures
+             ;; would just reference their frame, wouldn't they?
+             (inst and rsp-tn (lognot lowtag-mask)) ; align
+             (inst push data)
+             (inst push (compute-object-header value-cell-size value-cell-widetag))
+             (inst lea result (ea other-pointer-lowtag rsp-tn)))
+            (t
+             (alloc-other value-cell-widetag value-cell-size result node nil thread-tn
+              (lambda ()
+                (if (sc-case value
+                     (immediate
+                      (unless (integerp data) (inst push data) t))
+                     (constant
+                      (inst push value) t)
+                     (t nil))
+                    (inst pop (object-slot-ea result value-cell-value-slot other-pointer-lowtag))
+                    (storew data result value-cell-value-slot other-pointer-lowtag)))))))))
 
 ;;;; automatic allocators for primitive objects
 
diff --git src/compiler/x86-64/arith.lisp src/compiler/x86-64/arith.lisp
index 0ececb89e..ed460d877 100644
--- src/compiler/x86-64/arith.lisp
+++ src/compiler/x86-64/arith.lisp
@@ -1188,11 +1188,281 @@
       (inst jmp :o error)
       (inst add r tmp))))
 
+(define-vop (overflow-negate-signed)
+  (:translate overflow-negate)
+  (:args (x :scs (signed-reg)))
+  (:arg-types signed-num)
+  (:info type)
+  (:results (r :scs (signed-reg)))
+  (:result-types signed-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::sub-overflow-error r)))
+      (move r x)
+      (inst neg r)
+      (inst jmp :o error))))
+
+(define-vop (overflow-negate-unsigned)
+  (:translate overflow-negate)
+  (:args (x :scs (unsigned-reg)))
+  (:arg-types unsigned-num)
+  (:info type)
+  (:results (r :scs (unsigned-reg)))
+  (:result-types unsigned-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::negate-overflow-error x)))
+      (inst test x x)
+      (inst jmp :nz error)
+      (unless (location= r x)
+        (zeroize r)))))
+
+(define-vop (overflow-negate-unsigned=>signed)
+  (:translate overflow-negate)
+  (:args (x :scs (unsigned-reg)))
+  (:arg-types unsigned-num)
+  (:temporary (:sc unsigned-reg) temp)
+  (:info type)
+  (:results (r :scs (signed-reg)))
+  (:result-types signed-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::negate-overflow-error x)))
+      (inst mov temp 9223372036854775808)
+      (inst cmp x temp)
+      (inst jmp :a error)
+      (move r x)
+      (inst neg r))))
+
+(define-vop (overflow-negate-signed=>unsigned)
+  (:translate overflow-negate)
+  (:args (x :scs (signed-reg)))
+  (:arg-types signed-num)
+  (:info type)
+  (:results (r :scs (unsigned-reg)))
+  (:result-types unsigned-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::negate-overflow-error x)))
+      (inst test x x)
+      (inst jmp :g error)
+      (inst mov r x)
+      (inst neg r))))
+
+(define-vop (overflow-ash-unsigned)
+  (:translate overflow-ash)
+  (:args (number :scs (unsigned-reg))
+         (amount :scs (unsigned-reg signed-reg immediate)))
+  (:arg-types unsigned-num untagged-num)
+  (:arg-refs nil amount-ref)
+  (:info type)
+  (:temporary (:sc signed-reg :offset rcx-offset) ecx)
+  (:temporary (:sc unsigned-reg) temp)
+  (:results (result :scs (unsigned-reg) :from :load))
+  (:result-types unsigned-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:variant-vars signed)
+  (:generator 3
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (amount-error amount)
+           (error (generate-error-code+
+                   (when (sc-is amount immediate)
+                     (setf amount (tn-value amount)
+                           amount-error
+                           (make-random-tn :kind :normal
+                                           :sc (sc-or-lose (if (typep amount 'word)
+                                                               'unsigned-reg
+                                                               'signed-reg))
+                                           :offset (tn-offset temp)))
+                     (lambda ()
+                       (inst mov temp amount)))
+                   vop 'sb-kernel::ash-overflow2-error number amount-error))
+           (amount-width (if (csubtypep (tn-ref-type amount-ref)
+                                        (specifier-type `(signed-byte 32)))
+                             :dword
+                             :qword))
+           (fits (csubtypep (tn-ref-type amount-ref)
+                            (specifier-type `(integer -63 63)))))
+      (when signed
+        (inst test number number)
+        (inst jmp :s error))
+      (cond ((numberp amount)
+             (cond ((< amount -63)
+                    (zeroize result))
+                   ((minusp amount)
+                    (move result number)
+                    (inst shr result amount))
+                   ((> amount 63)
+                    (inst test number number)
+                    (inst jmp :nz error)
+                    (move result number))
+                   ((zerop amount)
+                    (move result number))
+                   (t
+                    (move result number)
+                    (inst shl result amount)
+                    (cond ((= amount 1)
+                           (inst jmp :c error))
+                          (t
+                           (move temp number)
+                           (inst shr temp (- 64 amount))
+                           (inst jmp :nz error))))))
+            (t
+             (assemble ()
+               (move result number)
+               (move ecx amount amount-width)
+               (unless (csubtypep (tn-ref-type amount-ref)
+                                  (specifier-type 'unsigned-byte))
+                 (assemble ()
+                   (inst test amount-width ecx ecx)
+                   (inst jmp :ns POSITIVE)
+                   (inst neg amount-width ecx)
+                   (unless fits
+                     (inst cmp amount-width ecx 63)
+                     (inst jmp :be OKAY)
+                     (zeroize result))
+                   OKAY
+                   (inst shr result :cl)
+                   (inst jmp DONE)))
+               POSITIVE
+               (unless fits
+                 (inst test number number)
+                 (inst jmp :z done)
+                 (inst cmp amount-width ecx n-word-bits)
+                 (inst jmp :ge error))
+               (inst shl result :cl)
+               (inst neg :dword ecx)
+               (move temp number)
+               (inst shr temp :cl)
+               (inst jmp :nz error)))))
+    done))
+
+(define-vop (overflow-ash-signed=>unsigned overflow-ash-unsigned)
+  (:translate overflow-ash)
+  (:args (number :scs (signed-reg))
+         (amount :scs (unsigned-reg signed-reg immediate)))
+  (:arg-types signed-num untagged-num)
+  (:variant t)
+  (:variant-cost 4))
+
+(define-vop (overflow-ash-signed)
+  (:translate overflow-ash)
+  (:args (number :scs (signed-reg))
+         (amount :scs (unsigned-reg signed-reg immediate)))
+  (:arg-types signed-num untagged-num)
+  (:arg-refs nil amount-ref)
+  (:info type)
+  (:temporary (:sc signed-reg :offset rcx-offset) ecx)
+  (:temporary (:sc unsigned-reg) temp)
+  (:results (result :scs (signed-reg) :from :load))
+  (:result-types signed-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 3
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (amount-error amount)
+           (error (generate-error-code+
+                   (when (sc-is amount immediate)
+                     (setf amount (tn-value amount)
+                           amount-error
+                           (make-random-tn :kind :normal
+                                           :sc (sc-or-lose (if (typep amount 'word)
+                                                               'unsigned-reg
+                                                               'signed-reg))
+                                           :offset (tn-offset temp)))
+                     (lambda ()
+                       (inst mov temp amount)))
+                   vop 'sb-kernel::ash-overflow2-error number amount-error))
+           (amount-width (if (csubtypep (tn-ref-type amount-ref)
+                                        (specifier-type `(signed-byte 32)))
+                             :dword
+                             :qword))
+           (fits (csubtypep (tn-ref-type amount-ref)
+                            (specifier-type `(integer -63 63)))))
+      (cond ((numberp amount)
+             (cond ((minusp amount)
+                    (move result number)
+                    (inst sar result (min (- amount) 63)))
+                   ((> amount 63)
+                    (inst test number number)
+                    (inst jmp :nz error)
+                    (move result number))
+                   ((zerop amount)
+                    (move result number))
+                   ((= amount 63)
+                    (inst lea result (ea 1 number))
+                    (inst cmp result 2)
+                    (inst jmp :ae error)
+                    (move result number)
+                    (inst shl result 63))
+                   ((typep (ash 1 amount) '(signed-byte 32))
+                    (inst imul result number (ash 1 amount))
+                    (inst jmp :o error))
+                   (t
+                    (inst mov  result (ash 1 amount))
+                    (inst imul result number)
+                    (inst jmp :o error))))
+            (t
+             (assemble ()
+               (move result number)
+               (move ecx amount amount-width)
+               (unless (csubtypep (tn-ref-type amount-ref)
+                                  (specifier-type 'unsigned-byte))
+                 (assemble ()
+                   (inst test amount-width ecx ecx)
+                   (inst jmp :ns POSITIVE)
+                   (inst neg amount-width ecx)
+                   (unless fits
+                     (inst cmp amount-width ecx 63)
+                     (inst jmp :be OKAY)
+                     (inst or amount-width ecx 63))
+                   OKAY
+                   (inst sar result :cl)
+                   (inst jmp DONE)))
+               POSITIVE
+
+               (unless fits
+                 (inst test number number)
+                 (inst jmp :z done)
+                 (inst cmp amount-width ecx n-word-bits)
+                 (inst jmp :ge error))
+               (inst shl result :cl)
+               (move temp result)
+               (inst sar temp :cl)
+               (inst cmp temp number)
+               (inst jmp :ne error)))))
+    done))
+
+(define-vop (overflow-ash-fixnum overflow-ash-signed)
+  (:translate overflow-ash)
+  (:args (number :scs (any-reg))
+         (amount :scs (unsigned-reg immediate)))
+  (:arg-types tagged-num unsigned-num)
+  (:results (result :scs (any-reg) :from :load))
+  (:result-types tagged-num)
+  (:variant-cost 2))
+
 (define-vop (overflow+t)
   (:translate overflow+)
-  (:args (x :scs (descriptor-reg))
+  (:args (x :scs (any-reg descriptor-reg))
          (y :scs (any-reg)))
-  (:arg-types t tagged-num)
+  (:arg-types (:or t tagged-num) tagged-num)
+  (:arg-refs x-ref)
   (:info type)
   (:results (r :scs (any-reg) :from :load))
   (:result-types tagged-num)
@@ -1202,17 +1472,19 @@
     (let* ((*location-context* (unless (eq type 'fixnum)
                                  type))
            (error (generate-error-code vop 'sb-kernel::add-overflow2-error x y)))
-      (generate-fixnum-test x)
-      (inst jmp :nz error)
+      (unless (csubtypep (tn-ref-type x-ref) (specifier-type 'fixnum))
+        (generate-fixnum-test x)
+        (inst jmp :nz error))
       (move r x)
       (inst add r y)
       (inst jmp :o error))))
 
 (define-vop (overflow-t)
   (:translate overflow-)
-  (:args (x :scs (descriptor-reg))
+  (:args (x :scs (any-reg descriptor-reg))
          (y :scs (any-reg)))
-  (:arg-types t tagged-num)
+  (:arg-types (:or t tagged-num) tagged-num)
+  (:arg-refs x-ref)
   (:info type)
   (:results (r :scs (any-reg) :from :load))
   (:result-types tagged-num)
@@ -1222,17 +1494,41 @@
     (let* ((*location-context* (unless (eq type 'fixnum)
                                  type))
            (error (generate-error-code vop 'sb-kernel::sub-overflow2-error x y)))
-      (generate-fixnum-test x)
-      (inst jmp :nz error)
+      (unless (csubtypep (tn-ref-type x-ref) (specifier-type 'fixnum))
+        (generate-fixnum-test x)
+        (inst jmp :nz error))
+      (move r x)
+      (inst sub r y)
+      (inst jmp :o error))))
+
+(define-vop (overflow-t-y)
+  (:translate overflow-)
+  (:args (x :scs (any-reg))
+         (y :scs (any-reg descriptor-reg)))
+  (:arg-types tagged-num (:or t tagged-num))
+  (:arg-refs nil y-ref)
+  (:info type)
+  (:results (r :scs (any-reg) :from :load))
+  (:result-types tagged-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 2
+    (let* ((*location-context* (unless (eq type 'fixnum)
+                                 type))
+           (error (generate-error-code vop 'sb-kernel::sub-overflow2-error x y)))
+      (unless (csubtypep (tn-ref-type y-ref) (specifier-type 'fixnum))
+        (generate-fixnum-test y)
+        (inst jmp :nz error))
       (move r x)
       (inst sub r y)
       (inst jmp :o error))))
 
 (define-vop (overflow*t)
   (:translate overflow*)
-  (:args (x :scs (descriptor-reg))
+  (:args (x :scs (any-reg descriptor-reg))
          (y :scs (signed-reg)))
-  (:arg-types t tagged-num)
+  (:arg-types (:or t tagged-num) tagged-num)
+  (:arg-refs x-ref)
   (:info type)
   (:results (r :scs (any-reg) :from :load))
   (:result-types tagged-num)
@@ -1242,8 +1538,9 @@
     (let* ((*location-context* (unless (eq type 'fixnum)
                                  type))
            (error (generate-error-code vop 'sb-kernel::mul-overflow2-error x y)))
-      (generate-fixnum-test x)
-      (inst jmp :nz error)
+      (unless (csubtypep (tn-ref-type x-ref) (specifier-type 'fixnum))
+        (generate-fixnum-test x)
+        (inst jmp :nz error))
       (move r x)
       (inst imul r y)
       (inst jmp :o error))))
@@ -1416,6 +1713,58 @@
     (move quo eax)
     (move rem edx)))
 
+(defun power-of-two-p (x)
+  (and (typep x 'signed-word)
+       (let ((abs (abs x)))
+         (and (> abs 1)
+              (= (logcount abs) 1)))))
+
+(define-vop (truncate/signed-power-of-two fast-safe-arith-op)
+  (:translate truncate)
+  (:args (x :scs (signed-reg) :to :result))
+  (:arg-types signed-num (:constant (satisfies power-of-two-p)))
+  (:arg-refs nil y-ref)
+  (:info y)
+  (:temporary (:sc unsigned-reg) temp)
+  (:results (quo :scs (signed-reg) :from :eval)
+            (rem :scs (signed-reg) :from :eval))
+  (:optional-results rem)
+  (:result-types signed-num signed-num)
+  (:note "inline (signed-byte 64) arithmetic")
+  (:vop-var vop)
+  (:save-p :compute-only)
+  (:generator 10
+    (let* ((abs-y (abs y))
+           (shift (1- (integer-length abs-y))))
+      (cond ((= abs-y 2)
+             (inst mov quo x)
+             (inst shr quo 63)
+             (inst add quo x))
+            ((typep (1- abs-y) '(signed-byte 32))
+             (inst lea quo (ea (1- abs-y) x))
+             (inst test x x)
+             (inst cmov :ns quo x))
+            (t
+             (cond ((eq (tn-kind rem) :unused)
+                    (inst mov quo (1- abs-y)))
+                   (t
+                    (inst mov temp (- abs-y))
+                    (inst mov quo temp)
+                    (inst not quo)))
+             (inst add quo x)
+             (inst test x x)
+             (inst cmov :ns quo x)))
+      (unless (eq (tn-kind rem) :unused)
+        (cond ((typep (- abs-y) '(signed-byte 32))
+               (inst mov temp quo)
+               (inst and temp (- abs-y)))
+              (t
+               (inst and temp quo)))
+        (inst mov rem x)
+        (inst sub rem temp))
+      (inst sar quo shift)
+      (when (minusp y)
+        (inst neg quo)))))
 
 
 ;;;; Shifting
@@ -1568,7 +1917,7 @@
     (with-shift-operands
       (move ecx amount)
       (unless (csubtypep (tn-ref-type amount-ref)
-                         (specifier-type '(mod 63)))
+                         (specifier-type '(mod 64)))
         (inst cmp amount 63)
         (inst jmp :be OKAY)
         (zeroize result))
@@ -1592,7 +1941,7 @@
     (with-shift-operands
       (move ecx amount)
       (unless (csubtypep (tn-ref-type amount-ref)
-                         (specifier-type '(mod 63)))
+                         (specifier-type '(mod 64)))
         (inst cmp amount 63)
         (inst jmp :be OKAY)
         (zeroize result))
@@ -1659,36 +2008,41 @@
   (:variant-vars check-amount signed)
   (:note "inline ASH")
   (:generator 5
-    (move result number)
-    (move ecx amount)
-    (inst test ecx ecx)
-    (inst jmp :ns POSITIVE)
-    (inst neg ecx)
-    (unless (csubtypep (tn-ref-type amount-ref)
-                       (specifier-type `(integer -63 *)))
-      (inst cmp ecx 63)
-      (inst jmp :be OKAY)
-      (cond (signed
-             (inst or ecx 63))
-            (t
-             (zeroize result))))
-    OKAY
-    (if signed
-        (inst sar result :cl)
-        (inst shr result :cl))
-    (inst jmp DONE)
+    (let ((amount-width (if (csubtypep (tn-ref-type amount-ref)
+                                       (specifier-type `(signed-byte 32)))
+                            :dword
+                            :qword)))
+      (assemble ()
+        (move result number)
+        (move ecx amount amount-width)
+        (inst test amount-width ecx ecx)
+        (inst jmp :ns POSITIVE)
+        (inst neg amount-width ecx)
+        (unless (csubtypep (tn-ref-type amount-ref)
+                           (specifier-type `(integer -63 *)))
+          (inst cmp amount-width ecx 63)
+          (inst jmp :be OKAY)
+          (cond (signed
+                 (inst or amount-width ecx 63))
+                (t
+                 (zeroize result))))
+        OKAY
+        (if signed
+            (inst sar result :cl)
+            (inst shr result :cl))
+        (inst jmp DONE)
 
-    POSITIVE
-    (unless (or (not check-amount) ;; The result-type ensures us that this shift will not overflow.
-                (csubtypep (tn-ref-type amount-ref)
-                           (specifier-type `(integer * 63))))
-      (inst cmp ecx 63)
-      (inst jmp :be STILL-OKAY)
-      (zeroize result))
-    STILL-OKAY
-    (inst shl result :cl)
+        POSITIVE
+        (unless (or (not check-amount) ;; The result-type ensures us that this shift will not overflow.
+                    (csubtypep (tn-ref-type amount-ref)
+                               (specifier-type `(integer * 63))))
+          (inst cmp amount-width ecx 63)
+          (inst jmp :be STILL-OKAY)
+          (zeroize result))
+        STILL-OKAY
+        (inst shl result :cl)
 
-    DONE))
+        DONE))))
 
 (define-vop (fast-ash/signed=>signed
              fast-ash/unsigned=>unsigned)
@@ -2286,26 +2640,10 @@
 ;;; E1:       25FE0F0000       AND EAX, 4094
 ;;; E6:       4885C0           TEST RAX, RAX
 ;;; E9:       74C9             JEQ L2
-
-;;; %LOGBITP has the same argument order as ordinary LOGBITP which is * backwards *
-;;; relative to every other architecture.
-;;; I suspect the others have a predilection for placing codegen info args last.
-(defknown %logbitp ((mod 64) (or signed-word word)) boolean
-  (movable foldable flushable always-translatable))
-
-;;; only for constant folding within the compiler
-(defun %logbitp (index integer)
-  (declare (notinline logbitp))
-  ;; Normally an "intepreter stub" is implemented in terms of itself, not in terms
-  ;; of the public function. But this has to work in the cross-compiler too.
-  ;; A way to do that is define a version of %LOGBITP in cross-misc.
-  ;; Then brings a new problem: inconsistent argument order across the architectures.
-  (logbitp index integer))
-
 ;;; Normally we define a spectrum of vops to handle {unsigned,signed,any}-reg and
 ;;; constant/non-constant operands. That's often unnecessary. Certainly for this vop.
-(define-vop (%logbitp fast-safe-arith-op)
-  (:translate %logbitp)
+(define-vop (logbitp fast-safe-arith-op)
+  (:translate logbitp)
   (:conditional :c)
   (:args (bit :scs (signed-reg signed-stack unsigned-reg unsigned-stack
                     any-reg control-stack) :load-if nil)
@@ -2328,8 +2666,8 @@
                         temp))))
       (inst bt word bit))))
 
-(define-vop (%logbitp/c fast-safe-arith-op)
-  (:translate %logbitp)
+(define-vop (logbitp/c fast-safe-arith-op)
+  (:translate logbitp)
   (:conditional :c)
   (:info bit)
   (:args (int :scs (signed-reg signed-stack unsigned-reg unsigned-stack
@@ -2352,18 +2690,18 @@
                       ((extra-disp bit-shift) (floor bit 8)))
              (inst test :byte (ea (+ frame-disp extra-disp) rbp-tn) (ash 1 bit-shift)))
            (change-vop-flags vop '(:ne))
-           (return-from %logbitp/c))
+           (return-from logbitp/c))
           ((= bit 31)       ; test the sign bit of the 32-bit register
            (inst test :dword int int)
            (change-vop-flags vop '(:s))
-           (return-from %logbitp/c))
+           (return-from logbitp/c))
           ((< bit 32)
            (inst test (if (< bit 8) :byte :dword) int (ash 1 bit))
            (change-vop-flags vop '(:ne))
-           (return-from %logbitp/c)))
+           (return-from logbitp/c)))
     (inst bt (if (<= bit 31) :dword :qword) int bit)))
 
-(define-vop (%logbitp-memref fast-conditional)
+(define-vop (logbitp-memref fast-conditional)
   (:args (x :scs (descriptor-reg)))
   (:arg-types (:constant (mod 64)) *)
   (:info bit)
@@ -2377,7 +2715,7 @@
                ((extra-disp bit-shift) (floor bit 8)))
       (inst test :byte (ea (+ slot-disp extra-disp) x) (ash 1 bit-shift)))))
 
-(defoptimizer (sb-c::vop-optimize %logbitp/c) (vop)
+(defoptimizer (sb-c::vop-optimize logbitp/c) (vop)
   (unless (tn-ref-memory-access (vop-args vop))
     (let ((prev (sb-c::previous-vop-is
                  ;; TODO: missing data-vector-ref/simple-vector-c and SLOT
@@ -2404,7 +2742,7 @@
                             bit))
                        (new (sb-c::emit-and-insert-vop
                              (sb-c::vop-node vop) (vop-block vop)
-                             (template-or-lose '%logbitp-memref)
+                             (template-or-lose 'logbitp-memref)
                              arg-ref nil prev (list info))))
               (setf (tn-ref-memory-access arg-ref) `(:read . ,disp))
               (change-vop-flags vop '(:ne))
@@ -3056,23 +3394,6 @@
     (inst imul y)
     (move hi edx)))
 
-(define-vop (bignum-lognot lognot-mod64/unsigned=>unsigned)
-  (:translate sb-bignum:%lognot))
-
-(define-vop (fixnum-to-digit)
-  (:translate sb-bignum:%fixnum-to-digit)
-  (:policy :fast-safe)
-  (:args (fixnum :scs (any-reg control-stack) :target digit))
-  (:arg-types tagged-num)
-  (:results (digit :scs (unsigned-reg)
-                   :load-if (not (and (sc-is fixnum control-stack)
-                                      (sc-is digit unsigned-stack)
-                                      (location= fixnum digit)))))
-  (:result-types unsigned-num)
-  (:generator 1
-    (move digit fixnum)
-    (inst sar digit n-fixnum-tag-bits)))
-
 (define-vop (bignum-floor)
   (:translate sb-bignum:%bigfloor)
   (:policy :fast-safe)
diff --git src/compiler/x86-64/call.lisp src/compiler/x86-64/call.lisp
index c24cbb42c..b72eeea34 100644
--- src/compiler/x86-64/call.lisp
+++ src/compiler/x86-64/call.lisp
@@ -1293,7 +1293,11 @@
           (inst lea :dword rcx (ea nil count (ash 1 shift)))))
     ;; Setup for the CDR of the last cons (or the entire result) being NIL.
     (inst mov result nil-value)
-    (inst jrcxz DONE)
+    (cond ((not (member :allocation-size-histogram sb-xc:*features*))
+           (inst jrcxz DONE))
+          (t ; jumps too far for JRCXZ sometimes
+           (inst test rcx rcx)
+           (inst jmp :z done)))
     (unless (node-stack-allocate-p node)
       (instrument-alloc +cons-primtype+ rcx node (list value dst) thread-tn))
     (pseudo-atomic (:elide-if (node-stack-allocate-p node) :thread-tn thread-tn)
diff --git src/compiler/x86-64/insts.lisp src/compiler/x86-64/insts.lisp
index d569566d9..d7dcfd624 100644
--- src/compiler/x86-64/insts.lisp
+++ src/compiler/x86-64/insts.lisp
@@ -320,22 +320,24 @@
   :printer #'print-xmmreg/mem)
 
 (defconstant-eqx +conditions+
+  ;; The first element in each row is the one we disassemble as.
+  ;; Always prefer the one without a negation in it if there is a choice.
   '((:o . 0)
     (:no . 1)
     (:b . 2) (:nae . 2) (:c . 2)
-    (:nb . 3) (:ae . 3) (:nc . 3)
+    (:ae . 3) (:nb . 3) (:nc . 3)
     (:eq . 4) (:e . 4) (:z . 4)
     (:ne . 5) (:nz . 5)
     (:be . 6) (:na . 6)
-    (:nbe . 7) (:a . 7)
+    (:a . 7) (:nbe . 7)
     (:s . 8)
     (:ns . 9)
     (:p . 10) (:pe . 10)
-    (:np . 11) (:po . 11)
+    (:po . 11) (:np . 11)
     (:l . 12) (:nge . 12)
-    (:nl . 13) (:ge . 13)
+    (:ge . 13) (:nl . 13)
     (:le . 14) (:ng . 14)
-    (:nle . 15) (:g . 15))
+    (:g . 15) (:nle . 15))
   #'equal)
 (defconstant-eqx +condition-name-vec+
   (let ((vec (make-array 16 :initial-element nil)))
diff --git src/compiler/x86-64/memory.lisp src/compiler/x86-64/memory.lisp
index 7f54150fc..c0db180e0 100644
--- src/compiler/x86-64/memory.lisp
+++ src/compiler/x86-64/memory.lisp
@@ -36,7 +36,7 @@
 (defun emit-gengc-barrier (object cell-address scratch-reg &optional value-tn-ref value-tn)
   (when (sc-is object constant immediate)
     (aver (symbolp (tn-value object))))
-  (when (require-gc-store-barrier-p object value-tn-ref value-tn)
+  (when (require-gengc-barrier-p object value-tn-ref value-tn)
     (if cell-address ; for SIMPLE-VECTOR, the page holding the specific element index gets marked
         (inst lea scratch-reg cell-address)
         ;; OBJECT could be a symbol in immobile space
diff --git src/compiler/x86-64/type-vops.lisp src/compiler/x86-64/type-vops.lisp
index 4a0b98b73..ecebeadaa 100644
--- src/compiler/x86-64/type-vops.lisp
+++ src/compiler/x86-64/type-vops.lisp
@@ -366,7 +366,11 @@
 ;; the header of which must not overlap the static alloc regions
 #-sb-thread
 (aver (>= (- non-negative-fixnum-mask-constant-wired-address (* 2 n-word-bytes))
-          (+ (max boxed-region cons-region mixed-region) (* 3 n-word-bytes))))
+          (+ static-space-start
+             (max boxed-region-offset
+                  cons-region-offset
+                  mixed-region-offset)
+             (* 3 n-word-bytes))))
 
 ;;; An (unsigned-byte 64) can be represented with either a positive
 ;;; fixnum, a bignum with exactly one positive digit, or a bignum with
@@ -374,19 +378,26 @@
 (define-vop (unsigned-byte-64-p type-predicate)
   (:translate unsigned-byte-64-p)
   (:generator 10
-    (let ((not-target (gen-label))
-          (single-word (gen-label))
-          (fixnum-p (types-equal-or-intersect (tn-ref-type args) (specifier-type 'fixnum))))
+    (let* ((not-target (gen-label))
+           (single-word (gen-label))
+           (fixnum-p (types-equal-or-intersect (tn-ref-type args) (specifier-type 'fixnum)))
+           (not-signed-byte-64-p (not (types-equal-or-intersect (tn-ref-type args) (specifier-type 'signed-word))))
+           (unsigned-p (or not-signed-byte-64-p
+                           (not (types-equal-or-intersect (tn-ref-type args) (specifier-type '(integer * -1)))))))
       (multiple-value-bind (yep nope)
           (if not-p
               (values not-target target)
               (values target not-target))
         (when fixnum-p
-          ;; Is it a fixnum with the sign bit clear?
-          (inst test (ea non-negative-fixnum-mask-constant-wired-address) value)
-          (inst jmp :z yep))
+          (cond (unsigned-p
+                 (inst test :byte value fixnum-tag-mask)
+                 (inst jmp :z yep))
+                (t ;; Is it a fixnum with the sign bit clear?
+                 (inst test (ea non-negative-fixnum-mask-constant-wired-address) value)
+                 (inst jmp :z yep))))
         (cond ((fixnum-or-other-pointer-tn-ref-p args t)
-               (when fixnum-p
+               (when (and fixnum-p
+                          (not unsigned-p))
                  (inst test :byte value fixnum-tag-mask)
                  (inst jmp :z nope)))
               (t
@@ -395,9 +406,12 @@
                (inst jmp :ne nope)))
         ;; Get the header.
         (loadw temp value 0 other-pointer-lowtag)
-        ;; Is it one?
-        (inst cmp temp (bignum-header-for-length 1))
-        (inst jmp :e single-word)
+        (unless not-signed-byte-64-p
+          ;; Is it one?
+          (inst cmp temp (bignum-header-for-length 1))
+          (inst jmp :e (if unsigned-p
+                           yep
+                           single-word)))
         ;; If it's other than two, we can't be an (unsigned-byte 64)
         ;: Leave TEMP holding 0 in the affirmative case.
         (inst sub temp (bignum-header-for-length 2))
@@ -405,15 +419,19 @@
         ;; Compare the second digit to zero (in TEMP).
         (inst cmp (object-slot-ea value (1+ bignum-digits-offset) other-pointer-lowtag)
               temp)
-        (inst jmp :z yep) ; All zeros, its an (unsigned-byte 64).
-        (inst jmp nope)
+        (cond (unsigned-p
+               (inst jmp (if not-p :nz :z) target))
+              (t
+               (inst jmp :z yep) ; All zeros, its an (unsigned-byte 64).
+               (inst jmp nope)))
 
-        (emit-label single-word)
-        ;; Get the single digit.
-        (loadw temp value bignum-digits-offset other-pointer-lowtag)
-        ;; positive implies (unsigned-byte 64).
-        (inst test temp temp)
-        (inst jmp (if not-p :s :ns) target)
+        (unless unsigned-p
+          (emit-label single-word)
+          ;; Get the single digit.
+          (loadw temp value bignum-digits-offset other-pointer-lowtag)
+          ;; positive implies (unsigned-byte 64).
+          (inst test temp temp)
+          (inst jmp (if not-p :s :ns) target))
 
         (emit-label not-target)))))
 
@@ -932,15 +950,14 @@
 (define-vop (load-other-pointer-widetag)
   (:args (value :scs (any-reg descriptor-reg)))
   (:arg-refs args)
-  (:info not-other-pointer-label null-label)
+  (:info not-other-pointer-label null-label zero-extend)
   (:results (r :scs (unsigned-reg)))
   (:result-types unsigned-num)
   (:generator 1
-    ;; FIXME: can we pass T as the 2nd arg to OTHER-POINTER-TN-REF-P here?
-    ;; I'm confused as to the intent of NULL-LABEL.
-    ;; Must branching occur if nil, or _may_ branching occur?
-    (cond ((other-pointer-tn-ref-p args)
-           (inst mov :byte r (ea (- other-pointer-lowtag) value)))
+    (cond ((other-pointer-tn-ref-p args (not null-label))
+           (if zero-extend
+               (inst movzx '(:byte :dword) r (ea (- other-pointer-lowtag) value))
+               (inst mov :byte r (ea (- other-pointer-lowtag) value))))
           (t
            (when null-label
              (inst cmp value nil-value)
@@ -948,7 +965,9 @@
            (%lea-for-lowtag-test r value other-pointer-lowtag :qword)
            (inst test :byte r lowtag-mask)
            (inst jmp :nz not-other-pointer-label)
-           (inst mov :byte r (ea r))))))
+           (if zero-extend
+               (inst movzx '(:byte :dword) r (ea r))
+               (inst mov :byte r (ea r)))))))
 
 (define-vop (test-widetag)
   (:args (value :scs (unsigned-reg) :target temp))
diff --git src/compiler/x86-64/vm.lisp src/compiler/x86-64/vm.lisp
index debdf1446..fe6b82231 100644
--- src/compiler/x86-64/vm.lisp
+++ src/compiler/x86-64/vm.lisp
@@ -532,7 +532,7 @@
                  bits)))
           (structure-object
            (if (eq val sb-lockless:+tail+)
-               (progn (aver tag) sb-vm::lockfree-list-tail-value)
+               (progn (aver tag) (+ static-space-start lockfree-list-tail-value-offset))
                (bug "immediate structure-object ~S" val)))))
       tn))
 
@@ -610,16 +610,22 @@
        (if (or
             (valid-funtype '((mod 64) word) '*)
             (valid-funtype '((mod 64) signed-word) '*))
-           (values :transform '(lambda (index integer) (%logbitp index integer)))
+           (values :direct nil)
            (values :default nil)))
+      (truncate
+       (destructuring-bind (n &optional d) (sb-c::basic-combination-args node)
+         (if (and d
+                  (constant-lvar-p d)
+                  (power-of-two-p (lvar-value d))
+                  (and (csubtypep (sb-c::lvar-type n) (specifier-type 'signed-word))
+                       (not (csubtypep (sb-c::lvar-type n) (specifier-type 'word)))))
+             (values :direct nil)
+             (values :default nil))))
       (t
        (values :default nil)))))
 
 (defvar *register-names* +qword-register-names+)
 
-(defmacro unbound-marker-bits ()
-  (logior (+ sb-vm:static-space-start #x100) unbound-marker-widetag))
-
 ;;; See WRITE-FUNINSTANCE-PROLOGUE in x86-64-vm.
 ;;; There are 4 bytes available in the imm32 operand of a dummy MOV instruction.
 ;;; (It's a valid instruction on the theory that illegal opcodes might cause
@@ -635,3 +641,7 @@
     ;; By design they are also (i.e. must be) nonvolatile aross C call.
     (aver (not (logbitp 12 locs)))
     #-gs-seg (aver (not (logbitp 13 locs)))))
+
+#+sb-xc-host
+(setq *backend-cross-foldable-predicates*
+      '(power-of-two-p))
diff --git src/compiler/x86/alloc.lisp src/compiler/x86/alloc.lisp
index 54b417855..f70e4a4b6 100644
--- src/compiler/x86/alloc.lisp
+++ src/compiler/x86/alloc.lisp
@@ -81,7 +81,7 @@
                               scratch-tn)
                     :disp
                     #+sb-thread (* n-word-bytes thread-mixed-tlab-slot)
-                    #-sb-thread mixed-region))
+                    #-sb-thread (+ static-space-start mixed-region-offset)))
          (end-addr
             ;; thread->mixed_tlab.end_addr
            (make-ea :dword
@@ -89,7 +89,7 @@
                               scratch-tn)
                     :disp
                     #+sb-thread (* n-word-bytes (1+ thread-mixed-tlab-slot))
-                    #-sb-thread (+ mixed-region n-word-bytes))))
+                    #-sb-thread (+ static-space-start mixed-region-offset n-word-bytes))))
     (unless (and (tn-p size) (location= alloc-tn size))
       (inst mov alloc-tn size))
     #+(and sb-thread win32)
diff --git src/compiler/x86/arith.lisp src/compiler/x86/arith.lisp
index 0844ac5ed..dc06d3586 100644
--- src/compiler/x86/arith.lisp
+++ src/compiler/x86/arith.lisp
@@ -1774,23 +1774,6 @@ constant shift greater than word length")))
     (move hi edx)
     (inst and hi (lognot fixnum-tag-mask))))
 
-(define-vop (bignum-lognot lognot-mod32/word=>unsigned)
-  (:translate sb-bignum:%lognot))
-
-(define-vop (fixnum-to-digit)
-  (:translate sb-bignum:%fixnum-to-digit)
-  (:policy :fast-safe)
-  (:args (fixnum :scs (any-reg control-stack) :target digit))
-  (:arg-types tagged-num)
-  (:results (digit :scs (unsigned-reg)
-                   :load-if (not (and (sc-is fixnum control-stack)
-                                      (sc-is digit unsigned-stack)
-                                      (location= fixnum digit)))))
-  (:result-types unsigned-num)
-  (:generator 1
-    (move digit fixnum)
-    (inst sar digit n-fixnum-tag-bits)))
-
 (define-vop (bignum-floor)
   (:translate sb-bignum:%bigfloor)
   (:policy :fast-safe)
diff --git src/compiler/x86/pred.lisp src/compiler/x86/pred.lisp
index 0b4de8740..34ec843ec 100644
--- src/compiler/x86/pred.lisp
+++ src/compiler/x86/pred.lisp
@@ -135,7 +135,7 @@
                        (inst mov sc-reg (char-code val)))))
                    (structure-object
                     (aver (eq val sb-lockless:+tail+))
-                    sb-vm::lockfree-list-tail-value)))))
+                    (+ static-space-start lockfree-list-tail-value-offset))))))
         (aver (null (rest flags)))
         (if (sc-is else immediate)
             (load-immediate res else)
diff --git src/compiler/x86/vm.lisp src/compiler/x86/vm.lisp
index 1e59f5a7a..b7af70f3d 100644
--- src/compiler/x86/vm.lisp
+++ src/compiler/x86/vm.lisp
@@ -383,7 +383,7 @@
                              character-widetag))
           (structure-object
            (if (eq val sb-lockless:+tail+)
-               sb-vm::lockfree-list-tail-value
+               (+ static-space-start lockfree-list-tail-value-offset)
                (bug "immediate structure-object ~S" val)))))
       tn))
 
diff --git src/runtime/arch.h src/runtime/arch.h
index 26f7f2269..ea1dc0a2e 100644
--- src/runtime/arch.h
+++ src/runtime/arch.h
@@ -13,7 +13,7 @@
 #define __ARCH_H__
 
 #include "os.h"
-#include "signal.h"
+#include <signal.h>
 #include "thread.h"
 
 /* Do anything we need to do when starting up the runtime environment
@@ -26,9 +26,9 @@ extern void asm_routine_poke(const char*, int, char);
 /* FIXME: It would be good to document these too! */
 extern void arch_skip_instruction(os_context_t*);
 extern void arch_handle_allocation_trap(os_context_t*);
-extern boolean arch_pseudo_atomic_atomic(os_context_t*);
-extern void arch_set_pseudo_atomic_interrupted(os_context_t*);
-extern void arch_clear_pseudo_atomic_interrupted(os_context_t*);
+extern boolean arch_pseudo_atomic_atomic(struct thread *thread);
+extern void arch_set_pseudo_atomic_interrupted(struct thread *thread);
+extern void arch_clear_pseudo_atomic_interrupted(struct thread *thread);
 extern os_vm_address_t arch_get_bad_addr(int, siginfo_t*, os_context_t*);
 extern unsigned char *arch_internal_error_arguments(os_context_t*);
 extern unsigned int arch_install_breakpoint(void *pc);
diff --git src/runtime/arm-arch.c src/runtime/arm-arch.c
index f8c7b5a7f..9a13f4a12 100644
--- src/runtime/arm-arch.c
+++ src/runtime/arm-arch.c
@@ -17,7 +17,7 @@
 #include "validate.h"
 #include "os.h"
 #include "lispregs.h"
-#include "signal.h"
+#include <signal.h>
 #include "alloc.h"
 #include "interrupt.h"
 #include "interr.h"
@@ -41,33 +41,17 @@ unsigned char *arch_internal_error_arguments(os_context_t *context)
     return (unsigned char *)(OS_CONTEXT_PC(context) + 5);
 }
 
-boolean arch_pseudo_atomic_atomic(os_context_t *context)
-{
-    /* FIXME: this foreign_function_call_active test is dubious at
-     * best. If a foreign call is made in a pseudo atomic section
-     * (?) or more likely a pseudo atomic section is in a foreign
-     * call then an interrupt is executed immediately. Maybe it
-     * has to do with C code not maintaining pseudo atomic
-     * properly. MG - 2005-08-10
-     *
-     * The foreign_function_call_active used to live at each call-site
-     * to arch_pseudo_atomic_atomic, but this seems clearer.
-     * --NS 2007-05-15 */
-#ifdef LISP_FEATURE_GENCGC
+boolean arch_pseudo_atomic_atomic(struct thread *thread) {
     return SymbolValue(PSEUDO_ATOMIC_ATOMIC, 0) != NIL;
-#else
-    return (!foreign_function_call_active)
-        && (NIL != SymbolValue(PSEUDO_ATOMIC_ATOMIC,0));
-#endif
 }
 
-void arch_set_pseudo_atomic_interrupted(os_context_t *context)
+void arch_set_pseudo_atomic_interrupted(struct thread *thread)
 {
     extern void do_pending_interrupt();
     SetSymbolValue(PSEUDO_ATOMIC_INTERRUPTED, (lispobj)do_pending_interrupt, 0);
 }
 
-void arch_clear_pseudo_atomic_interrupted(os_context_t *context)
+void arch_clear_pseudo_atomic_interrupted(struct thread *thread)
 {
     SetSymbolValue(PSEUDO_ATOMIC_INTERRUPTED, 0, 0);
 }
diff --git src/runtime/arm-bsd-os.c src/runtime/arm-bsd-os.c
index 2c630b5b8..55cc188e8 100644
--- src/runtime/arm-bsd-os.c
+++ src/runtime/arm-bsd-os.c
@@ -18,7 +18,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/arm-linux-os.c src/runtime/arm-linux-os.c
index 3c814ae7b..1aeae9141 100644
--- src/runtime/arm-linux-os.c
+++ src/runtime/arm-linux-os.c
@@ -18,7 +18,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/arm64-arch.c src/runtime/arm64-arch.c
index 0e7e30716..6f5f3401a 100644
--- src/runtime/arm64-arch.c
+++ src/runtime/arm64-arch.c
@@ -17,7 +17,7 @@
 #include "validate.h"
 #include "os.h"
 #include "lispregs.h"
-#include "signal.h"
+#include <signal.h>
 #include "alloc.h"
 #include "interrupt.h"
 #include "interr.h"
@@ -50,34 +50,16 @@ unsigned char *arch_internal_error_arguments(os_context_t *context)
     return (unsigned char *)OS_CONTEXT_PC(context);
 }
 
-boolean arch_pseudo_atomic_atomic(os_context_t *context)
-{
-    /* FIXME: this foreign_function_call_active test is dubious at
-     * best. If a foreign call is made in a pseudo atomic section
-     * (?) or more likely a pseudo atomic section is in a foreign
-     * call then an interrupt is executed immediately. Maybe it
-     * has to do with C code not maintaining pseudo atomic
-     * properly. MG - 2005-08-10
-     *
-     * The foreign_function_call_active used to live at each call-site
-     * to arch_pseudo_atomic_atomic, but this seems clearer.
-     * --NS 2007-05-15 */
-#ifdef LISP_FEATURE_GENCGC
-    return get_pseudo_atomic_atomic(get_sb_vm_thread());
-#else
-    return (!foreign_function_call_active)
-        && (NIL != SymbolValue(PSEUDO_ATOMIC_ATOMIC,0));
-#endif
+boolean arch_pseudo_atomic_atomic(struct thread *thread) {
+    return get_pseudo_atomic_atomic(thread);
 }
 
-void arch_set_pseudo_atomic_interrupted(os_context_t *context)
-{
-    set_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_set_pseudo_atomic_interrupted(struct thread *thread) {
+    set_pseudo_atomic_interrupted(thread);
 }
 
-void arch_clear_pseudo_atomic_interrupted(os_context_t *context)
-{
-    clear_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_clear_pseudo_atomic_interrupted(struct thread *thread) {
+    clear_pseudo_atomic_interrupted(thread);
 }
 
 unsigned int arch_install_breakpoint(void *pc)
diff --git src/runtime/arm64-assem.S src/runtime/arm64-assem.S
index 863e341a5..cd980acbf 100644
--- src/runtime/arm64-assem.S
+++ src/runtime/arm64-assem.S
@@ -123,7 +123,12 @@ GNAME(call_into_lisp):
         stp     d14,d15, [sp,#144]
 
 	// Start by finding NIL.
+#ifdef LISP_FEATURE_RELOCATABLE_STATIC_SPACE
+        ldr     reg_NULL, STATIC_SPACE_START
+        add     reg_NULL, reg_NULL, #NIL_VALUE_OFFSET
+#else
 	ldr	reg_NULL, =NIL
+#endif
 
 	// Set up NARGS.
 	lsl	reg_NARGS, x2, #N_FIXNUM_TAG_BITS
diff --git src/runtime/arm64-bsd-os.c src/runtime/arm64-bsd-os.c
index 92ccfbec5..607ba2a26 100644
--- src/runtime/arm64-bsd-os.c
+++ src/runtime/arm64-bsd-os.c
@@ -18,7 +18,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/arm64-linux-os.c src/runtime/arm64-linux-os.c
index 3629cd52e..b69b86c20 100644
--- src/runtime/arm64-linux-os.c
+++ src/runtime/arm64-linux-os.c
@@ -18,7 +18,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/bsd-os.c src/runtime/bsd-os.c
index 8a8df0a29..ecae63dd6 100644
--- src/runtime/bsd-os.c
+++ src/runtime/bsd-os.c
@@ -26,7 +26,6 @@
 #include <assert.h>
 #include <errno.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/coreparse.c src/runtime/coreparse.c
index 7d14568a9..ea50151f5 100644
--- src/runtime/coreparse.c
+++ src/runtime/coreparse.c
@@ -219,12 +219,11 @@ static void inflate_core_bytes(int fd, os_vm_offset_t offset,
 }
 #endif
 
-#define MAX_SPACE_RELOCATION_RANGES 4
 struct heap_adjust {
     struct range {
         lispobj start, end;
         sword_t delta;
-    } range[MAX_SPACE_RELOCATION_RANGES];
+    } range[MAX_CORE_SPACE_ID+1];
     int n_ranges;
     int n_relocs_abs; // absolute
     int n_relocs_rel; // relative
@@ -271,7 +270,6 @@ set_adjustment(struct heap_adjust* adj,
     sword_t delta = len ? actual_addr - desired_addr : 0;
     if (!delta) return;
     int j = adj->n_ranges;
-    gc_assert(j < MAX_SPACE_RELOCATION_RANGES);
     adj->range[j].start = (lispobj)desired_addr;
     adj->range[j].end   = (lispobj)desired_addr + len;
     adj->range[j].delta = delta;
@@ -599,6 +597,12 @@ static void relocate_heap(struct heap_adjust* adj)
                         (char*)adj->range[i].start + adj->range[i].delta,
                         (char*)adj->range[i].end + adj->range[i].delta);
     }
+#ifdef LISP_FEATURE_RELOCATABLE_STATIC_SPACE
+    relocate_space(READ_ONLY_SPACE_START, read_only_space_free_pointer, adj);
+    // Relocate the CAR slot of nil-as-a-list, which needs to point to
+    // itself.
+    adjust_pointers((void*)(NIL - LIST_POINTER_LOWTAG), 1, adj);
+#endif
     relocate_space(NIL_SYMBOL_SLOTS_START, (lispobj*)NIL_SYMBOL_SLOTS_END, adj);
     relocate_space(STATIC_SPACE_OBJECTS_START, static_space_free_pointer, adj);
 #ifdef LISP_FEATURE_IMMOBILE_SPACE
@@ -799,9 +803,12 @@ process_directory(int count, struct ndir_entry *entry,
             lose("unknown space ID %ld addr %p", id, (void*)addr);
 
 #ifdef LISP_FEATURE_DARWIN_JIT
-        int enforce_address = (id == STATIC_CORE_SPACE_ID) || (id == READ_ONLY_CORE_SPACE_ID);
+        int enforce_address = (id == READ_ONLY_CORE_SPACE_ID);
 #else
-        int enforce_address = id == STATIC_CORE_SPACE_ID;
+        int enforce_address = 0;
+#endif
+#ifndef LISP_FEATURE_RELOCATABLE_STATIC_SPACE
+        enforce_address |= (id == STATIC_CORE_SPACE_ID);
 #endif
 
         // We'd like to enforce proper alignment of 'addr' but there's
@@ -820,22 +827,38 @@ process_directory(int count, struct ndir_entry *entry,
                  (unsigned long)dynamic_space_size >> 10);
         }
 #ifndef LISP_FEATURE_DARWIN_JIT
+#ifdef LISP_FEATURE_RELOCATABLE_STATIC_SPACE
+        if (id == READ_ONLY_CORE_SPACE_ID || id == STATIC_CORE_SPACE_ID) {
+#else
         if (id == READ_ONLY_CORE_SPACE_ID) {
-            if (len) // There is no "nominal" size of readonly space, so give it a size
+#endif
+            if (len) // There is no "nominal" size of static or
+                     // readonly space, so give them a size
                 spaces[id].desired_size = len;
-            else // Assign some address, so free_pointer does enclose [0 .. addr+0]
+            else { // Assign some address, so free_pointer does enclose [0 .. addr+0]
+                if (id == STATIC_CORE_SPACE_ID)
+                    lose("Static space size is 0?");
                 READ_ONLY_SPACE_START = READ_ONLY_SPACE_END = addr;
+            }
         }
 #endif
         if (len != 0) {
             spaces[id].len = len;
-            // Try to map at address requested by the core file.
             size_t request = spaces[id].desired_size;
             int sub_2gb_flag = (request & 1);
             request &= ~(size_t)1;
+            // Try to map at address requested by the core file unless ASLR.
+#ifdef LISP_FEATURE_ASLR
+            addr = 0;
+#endif
             addr = (uword_t)reserve_space(id, sub_2gb_flag ? MOVABLE_LOW : MOVABLE,
                                           (os_vm_address_t)addr, request);
             switch (id) {
+            case STATIC_CORE_SPACE_ID:
+#ifdef LISP_FEATURE_RELOCATABLE_STATIC_SPACE
+                STATIC_SPACE_START = addr;
+                STATIC_SPACE_END = addr + len;
+#endif
 #ifndef LISP_FEATURE_DARWIN_JIT
             case READ_ONLY_CORE_SPACE_ID:
                 READ_ONLY_SPACE_START = addr;
@@ -845,8 +868,10 @@ process_directory(int count, struct ndir_entry *entry,
 #ifdef LISP_FEATURE_IMMOBILE_SPACE
             case IMMOBILE_FIXEDOBJ_CORE_SPACE_ID:
             case IMMOBILE_TEXT_CORE_SPACE_ID:
+#ifdef LISP_FEATURE_X86_64
                 if (addr + request > 0x80000000)
                     lose("Won't map immobile space above 2GB");
+#endif
                 if (id == IMMOBILE_FIXEDOBJ_CORE_SPACE_ID)
                     FIXEDOBJ_SPACE_START = addr;
                 else
@@ -921,6 +946,11 @@ process_directory(int count, struct ndir_entry *entry,
     set_adjustment(adj, DYNAMIC_SPACE_START, // actual
                    spaces[DYNAMIC_CORE_SPACE_ID].base, // expected
                    spaces[DYNAMIC_CORE_SPACE_ID].len);
+#ifdef LISP_FEATURE_RELOCATABLE_STATIC_SPACE
+    set_adjustment(adj, STATIC_SPACE_START, // actual
+                   spaces[STATIC_CORE_SPACE_ID].base, // expected
+                   spaces[STATIC_CORE_SPACE_ID].len);
+#endif
 #ifdef LISP_FEATURE_IMMOBILE_SPACE
     if (lisp_code_in_elf() && TEXT_SPACE_START != spaces[IMMOBILE_TEXT_CORE_SPACE_ID].base) {
         lose("code-in-elf + PIE not supported");
diff --git src/runtime/fullcgc.c src/runtime/fullcgc.c
index f3620f6bd..79ce0bc9d 100644
--- src/runtime/fullcgc.c
+++ src/runtime/fullcgc.c
@@ -28,8 +28,6 @@
 #include <stdio.h>
 #ifndef LISP_FEATURE_WIN32
 #define HAVE_GETRUSAGE 1
-#endif
-#if HAVE_GETRUSAGE
 #include <sys/resource.h> // for getrusage()
 #endif
 
@@ -394,7 +392,7 @@ void prepare_for_full_mark_phase()
 
 void execute_full_mark_phase()
 {
-#if HAVE_GETRUSAGE
+#ifdef HAVE_GETRUSAGE
     struct rusage before, after;
     getrusage(RUSAGE_SELF, &before);
 #endif
@@ -423,7 +421,7 @@ void execute_full_mark_phase()
               scav_queue.head_block->count));
     stray_pointer_source_obj = 0;
 
-#if HAVE_GETRUSAGE
+#ifdef HAVE_GETRUSAGE
     getrusage(RUSAGE_SELF, &after);
 #define timediff(b,a,field) \
     (double)((a.field.tv_sec-b.field.tv_sec)*1000000 + \
diff --git src/runtime/gencgc.c src/runtime/gencgc.c
index 970dad658..91a0d569f 100644
--- src/runtime/gencgc.c
+++ src/runtime/gencgc.c
@@ -3627,11 +3627,8 @@ static void __attribute__((unused)) maybe_pin_code(lispobj addr) {
     page_index_t page = find_page_index((char*)addr);
 
     if (page < 0) {
-        // FIXME: Is this actually necessary? The intention is to keep
-        // the on-stack code live, not to pin it, as it's already
-        // immobile.
         if (immobile_space_p(addr))
-            immobile_space_preserve_pointer((void*)component_ptr_from_pc((char*)addr));
+            immobile_space_preserve_pointer((void*)addr);
         return;
     }
     if (immune_set_memberp(page)) return;
@@ -4440,9 +4437,9 @@ extern int finalizer_thread_runflag;
 # define THREAD_ALLOC_REGION(threadvar,slot) &threadvar-> slot ##_tlab
 #else
 # define THREAD_ALLOC_REGION(threadvar,slot) main_thread_ ##slot ##_region
-#define main_thread_mixed_region (struct alloc_region*)STATIC_SPACE_START
-#define main_thread_cons_region (1+main_thread_mixed_region)
-#define main_thread_boxed_region (2+main_thread_mixed_region)
+#define main_thread_mixed_region (struct alloc_region*)(STATIC_SPACE_START + MIXED_REGION_OFFSET)
+#define main_thread_cons_region (struct alloc_region*)(STATIC_SPACE_START + CONS_REGION_OFFSET)
+#define main_thread_boxed_region (struct alloc_region*)(STATIC_SPACE_START + BOXED_REGION_OFFSET)
 #endif
 
 /* GC all generations newer than last_gen, raising the objects in each
@@ -5090,7 +5087,7 @@ lispobj AMD64_SYSV_ABI alloc_code_object(unsigned total_words, unsigned boxed)
     sword_t nbytes = total_words * N_WORD_BYTES;
     /* Allocations of code are all serialized. We might also acquire
      * free_pages_lock depending on availability of space in the region */
-    int result = mutex_acquire(&code_allocator_lock);
+    __attribute__((unused)) int result = mutex_acquire(&code_allocator_lock);
     gc_assert(result);
     struct code *code =
         (void*)lisp_alloc(nbytes >= LARGE_OBJECT_SIZE, code_region, nbytes, PAGE_TYPE_CODE, th);
@@ -5134,7 +5131,7 @@ lispobj AMD64_SYSV_ABI alloc_code_object(unsigned total_words, unsigned boxed)
 NO_SANITIZE_MEMORY lispobj AMD64_SYSV_ABI alloc_funinstance(sword_t nbytes)
 {
     struct thread *th = get_sb_vm_thread();
-    int result = mutex_acquire(&code_allocator_lock);
+    __attribute__((unused)) int result = mutex_acquire(&code_allocator_lock);
     gc_assert(result);
     void* mem = lisp_alloc(0, code_region, nbytes, PAGE_TYPE_CODE, th);
     result = mutex_release(&code_allocator_lock);
@@ -5528,7 +5525,11 @@ gc_and_save(char *filename, boolean prepend_runtime, boolean purify,
             boolean save_runtime_options, boolean compressed,
             int compression_level, int application_type)
 {
-#if defined LISP_FEATURE_SPARC && defined LISP_FEATURE_LINUX
+    // FIXME: Instead of disabling purify for static space relocation,
+    // we should make r/o space read-only after fixing up pointers to
+    // static space instead.
+#if ((defined LISP_FEATURE_SPARC && defined LISP_FEATURE_LINUX) || \
+     (defined LISP_FEATURE_RELOCATABLE_STATIC_SPACE))
     /* OS says it'll give you the memory where you want, then it says
      * it won't map over it from the core file.  That's news to me.
      * Fragment of output from 'strace -e mmap2 src/runtime/sbcl --core output/sbcl.core':
diff --git src/runtime/globals.h src/runtime/globals.h
index 86497344b..d307f5e11 100644
--- src/runtime/globals.h
+++ src/runtime/globals.h
@@ -45,6 +45,10 @@ extern int foreign_function_call_active;
 extern os_vm_size_t dynamic_space_size;
 extern os_vm_size_t thread_control_stack_size;
 
+#ifdef LISP_FEATURE_RELOCATABLE_STATIC_SPACE
+extern uword_t STATIC_SPACE_START, STATIC_SPACE_END;
+#endif
+
 #ifndef LISP_FEATURE_DARWIN_JIT
 extern uword_t READ_ONLY_SPACE_START, READ_ONLY_SPACE_END;
 #endif
@@ -72,13 +76,6 @@ extern lispobj alloc_profile_data; // Lisp SIMPLE-VECTOR
 
 extern lispobj arena_chain;
 
-#ifdef LISP_FEATURE_WIN32
-#define ENVIRON _environ
-#else
-#define ENVIRON environ
-#endif
-extern char **ENVIRON;
-
 #if !defined(LISP_FEATURE_SB_THREAD)
 extern lispobj *current_control_stack_pointer;
 #endif
diff --git src/runtime/interr.c src/runtime/interr.c
index 03d41eda4..413813fc9 100644
--- src/runtime/interr.c
+++ src/runtime/interr.c
@@ -19,7 +19,7 @@
 
 #include "sbcl.h"
 #include "arch.h"
-#include "signal.h"
+#include <signal.h>
 
 #include "runtime.h"
 #include "interr.h"
diff --git src/runtime/interrupt.c src/runtime/interrupt.c
index af66f5839..d4b21f8af 100644
--- src/runtime/interrupt.c
+++ src/runtime/interrupt.c
@@ -688,10 +688,10 @@ they are not safe to interrupt at all, this is a pretty severe occurrence.\n");
 inline static void
 check_interrupts_enabled_or_lose(os_context_t *context)
 {
-    __attribute__((unused)) struct thread *thread = get_sb_vm_thread();
+    struct thread *thread = get_sb_vm_thread();
     if (read_TLS(INTERRUPTS_ENABLED,thread) == NIL)
         lose("interrupts not enabled");
-    if (arch_pseudo_atomic_atomic(context))
+    if (arch_pseudo_atomic_atomic(thread))
         lose ("in pseudo atomic section");
 }
 
@@ -935,7 +935,7 @@ build_fake_control_stack_frames(struct thread __attribute__((unused)) *th,
 void fake_foreign_function_call_noassert(os_context_t *context)
 {
     int context_index;
-    struct thread *thread=get_sb_vm_thread();
+    struct thread *thread = get_sb_vm_thread();
 
 #ifdef reg_BSP
     set_binding_stack_pointer(thread,
@@ -990,7 +990,7 @@ void fake_foreign_function_call(os_context_t *context)
 void
 undo_fake_foreign_function_call(os_context_t __attribute__((unused)) *context)
 {
-    struct thread *thread=get_sb_vm_thread();
+    struct thread *thread = get_sb_vm_thread();
     /* Block all blockable signals. */
     block_blockable_signals(0);
 
@@ -1088,7 +1088,7 @@ interrupt_handle_pending(os_context_t *context)
     struct thread *thread = get_sb_vm_thread();
     struct interrupt_data *data = &thread_interrupt_data(thread);
 
-    if (arch_pseudo_atomic_atomic(context)) {
+    if (arch_pseudo_atomic_atomic(thread)) {
         lose("Handling pending interrupt in pseudo atomic.");
     }
 
@@ -1138,7 +1138,7 @@ interrupt_handle_pending(os_context_t *context)
         if (read_TLS(STOP_FOR_GC_PENDING,thread) != NIL) {
             /* STOP_FOR_GC_PENDING and GC_PENDING are cleared by
              * the signal handler if it actually stops us. */
-            arch_clear_pseudo_atomic_interrupted(context);
+            arch_clear_pseudo_atomic_interrupted(thread);
             sig_stop_for_gc_handler(SIG_STOP_FOR_GC,NULL,context);
         } else
 #endif
@@ -1159,7 +1159,7 @@ interrupt_handle_pending(os_context_t *context)
                 bind_variable(INTERRUPTS_ENABLED, NIL, thread);
             }
 
-            arch_clear_pseudo_atomic_interrupted(context);
+            arch_clear_pseudo_atomic_interrupted(thread);
 
             /* GC_PENDING is cleared in SUB-GC, or if another thread
              * is doing a gc already we will get a SIG_STOP_FOR_GC and
@@ -1215,7 +1215,7 @@ interrupt_handle_pending(os_context_t *context)
          * INTERRUPT_PENDING and pseudo atomic interrupted. It's safe
          * because we checked above that there is no GC pending. */
         write_TLS(INTERRUPT_PENDING, NIL, thread);
-        arch_clear_pseudo_atomic_interrupted(context);
+        arch_clear_pseudo_atomic_interrupted(thread);
         /* Restore the sigmask in the context. */
         sigcopyset(os_context_sigmask_addr(context), &data->pending_mask);
         run_deferred_handler(data, context);
@@ -1395,10 +1395,10 @@ can_handle_now(void *handler, struct interrupt_data *data,
     /* a slightly confusing test. arch_pseudo_atomic_atomic() doesn't
      * actually use its argument for anything on x86, so this branch
      * may succeed even when context is null (gencgc alloc()) */
-    else if (arch_pseudo_atomic_atomic(context)) {
+    else if (arch_pseudo_atomic_atomic(thread)) {
         event2("can_handle_now(%p,%d): deferred (PA)", handler, signal);
         store_signal_data_for_later(data,handler,signal,info,context);
-        arch_set_pseudo_atomic_interrupted(context);
+        arch_set_pseudo_atomic_interrupted(thread);
         answer = 0;
     }
 
@@ -1432,7 +1432,7 @@ sig_stop_for_gc_handler(int __attribute__((unused)) signal,
                         siginfo_t __attribute__((unused)) *info,
                         os_context_t *context)
 {
-    struct thread *thread=get_sb_vm_thread();
+    struct thread *thread = get_sb_vm_thread();
     boolean was_in_lisp;
 
     /* Test for GC_INHIBIT _first_, else we'd trap on every single
@@ -1441,10 +1441,10 @@ sig_stop_for_gc_handler(int __attribute__((unused)) signal,
         event0("stop_for_gc deferred for *GC-INHIBIT*");
         write_TLS(STOP_FOR_GC_PENDING, LISP_T, thread);
         return;
-    } else if (arch_pseudo_atomic_atomic(context)) {
+    } else if (arch_pseudo_atomic_atomic(thread)) {
         event0("stop_for_gc deferred for PA");
         write_TLS(STOP_FOR_GC_PENDING, LISP_T, thread);
-        arch_set_pseudo_atomic_interrupted(context);
+        arch_set_pseudo_atomic_interrupted(thread);
         maybe_save_gc_mask_and_block_deferrables(context);
         return;
     }
@@ -1710,7 +1710,7 @@ arrange_return_to_c_function(os_context_t *context,
     *os_context_register_addr(context,reg_RSI) = 0;        /* arg. array */
     *os_context_register_addr(context,reg_RDX) = 0;        /* no. args */
 #else
-    struct thread *th=get_sb_vm_thread();
+    struct thread *th = get_sb_vm_thread();
     build_fake_control_stack_frames(th,context);
 #endif
 
@@ -1799,7 +1799,7 @@ void reset_thread_control_stack_guard_page(struct thread *th)
 boolean
 handle_guard_page_triggered(os_context_t *context,os_vm_address_t addr)
 {
-    struct thread *th=get_sb_vm_thread();
+    struct thread *th = get_sb_vm_thread();
 
 #ifndef LISP_FEATURE_WIN32
     if(addr >= CONTROL_STACK_HARD_GUARD_PAGE(th) &&
@@ -1819,7 +1819,7 @@ handle_guard_page_triggered(os_context_t *context,os_vm_address_t addr)
             lose("Control stack exhausted with gc_active_p, fault: %p, PC: %p",
                  addr, (void*)os_context_pc(context));
         }
-        if (arch_pseudo_atomic_atomic(context)) {
+        if (arch_pseudo_atomic_atomic(th)) {
             fake_foreign_function_call(context);
             lose("Control stack exhausted while pseudo-atomic, fault: %p, PC: %p",
                  addr, (void*)os_context_pc(context));
diff --git src/runtime/linux-os.c src/runtime/linux-os.c
index 08bfaf8d5..ab4572a46 100644
--- src/runtime/linux-os.c
+++ src/runtime/linux-os.c
@@ -24,7 +24,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
@@ -32,7 +31,6 @@
 #include "interr.h"
 #include "lispregs.h"
 #include "runtime.h"
-#include "genesis/cons.h"
 #include "genesis/static-symbols.h"
 #include "genesis/fdefn.h"
 
@@ -225,23 +223,9 @@ futex_wait(int *lock_word, int oldval, long sec, unsigned long usec)
     struct mutex* m = (void*)((char*)lock_word - offsetof(struct mutex,state));
     char *name = m->name != NIL ? (char*)VECTOR(m->name)->data : "(unnamed)";
 #endif
-    if (sec<0) { // unbounded wait
+  if (sec<0) {
       lisp_mutex_event1("start futex wait", name);
-      // a mutex is profiled if its %NAME is a cons. %NAME is 1 word past the lock_word
-      lispobj name = ((uword_t*)lock_word)[1];
-      if (listp(name) && name != NIL && fixnump(CONS(name)->cdr)) {
-            struct timespec start_time, end_time;
-            clock_gettime(CLOCK_MONOTONIC, &start_time);
-            t = sys_futex(lock_word, futex_wait_op(), oldval, 0);
-            clock_gettime(CLOCK_MONOTONIC, &end_time);
-            // if my calculation is correct, this won't overflow for 146 years
-            // (most-positive-fixnum / nanoseconds-per-year)
-            long delta = (end_time.tv_nsec - start_time.tv_nsec)
-                         + (end_time.tv_sec - start_time.tv_sec) * 1000000000;
-            __sync_fetch_and_add(&CONS(name)->cdr, make_fixnum(delta));
-      } else {
-            t = sys_futex(lock_word, futex_wait_op(), oldval, 0);
-      }
+      t = sys_futex(lock_word, futex_wait_op(), oldval, 0);
   }
   else {
       timeout.tv_sec = sec;
@@ -291,6 +275,7 @@ void os_init()
 # define ALLOW_PERSONALITY_CHANGE 0
 #endif
 
+extern char **environ;
 int os_preinit(char *argv[], char *envp[])
 {
 #ifdef LISP_FEATURE_RISCV
@@ -362,6 +347,7 @@ int os_preinit(char *argv[], char *envp[])
             char runtime[PATH_MAX+1];
             int i = readlink("/proc/self/exe", runtime, PATH_MAX);
             if (i != -1) {
+                // Why is this needed? env surely was initialized from environ wasn't it?
                 environ = envp;
                 setenv("SBCL_IS_RESTARTING", "T", 1);
                 runtime[i] = '\0';
diff --git src/runtime/mips-arch.c src/runtime/mips-arch.c
index 34fbb1c9e..eee4cb26e 100644
--- src/runtime/mips-arch.c
+++ src/runtime/mips-arch.c
@@ -14,7 +14,7 @@
 #include "validate.h"
 #include "os.h"
 #include "lispregs.h"
-#include "signal.h"
+#include <signal.h>
 #include "pseudo-atomic.h"
 #include "interrupt.h"
 #include "interr.h"
@@ -249,16 +249,16 @@ arch_internal_error_arguments(os_context_t *context)
         return (unsigned char *)((unsigned)OS_CONTEXT_PC(context) + INSN_LEN);
 }
 
-boolean arch_pseudo_atomic_atomic(__attribute((unused)) os_context_t *context) {
-    return get_pseudo_atomic_atomic(get_sb_vm_thread());
+boolean arch_pseudo_atomic_atomic(struct thread *thread) {
+    return get_pseudo_atomic_atomic(thread);
 }
 
-void arch_set_pseudo_atomic_interrupted(__attribute__((unused)) os_context_t *context) {
-    set_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_set_pseudo_atomic_interrupted(struct thread *thread) {
+    set_pseudo_atomic_interrupted(thread);
 }
 
-void arch_clear_pseudo_atomic_interrupted(__attribute__((unused)) os_context_t *context) {
-    clear_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_clear_pseudo_atomic_interrupted(struct thread *thread) {
+    clear_pseudo_atomic_interrupted(thread);
 }
 
 unsigned int
@@ -450,7 +450,7 @@ sigtrap_handler(int signal, siginfo_t *info, os_context_t *context)
     case 0x36: // #b110110 = TNE
         switch (code) {
         case 0: // FIXME: why is this not trap_PendingInterrupt ?
-          arch_clear_pseudo_atomic_interrupted(context);
+          arch_clear_pseudo_atomic_interrupted(get_sb_vm_thread());
           OS_CONTEXT_PC(context) += 4;
           return interrupt_handle_pending(context);
         case trap_InvalidArgCount:
diff --git src/runtime/monitor.c src/runtime/monitor.c
index a768fe51e..28fa9aa70 100644
--- src/runtime/monitor.c
+++ src/runtime/monitor.c
@@ -489,7 +489,7 @@ pte_cmd(char **ptr)
 static int
 regs_cmd(char __attribute__((unused)) **ptr)
 {
-    struct thread __attribute__((unused)) *thread=get_sb_vm_thread();
+    struct thread __attribute__((unused)) *thread = get_sb_vm_thread();
 
     printf("CSP\t=\t%p   ", access_control_stack_pointer(thread));
 #if !defined(LISP_FEATURE_X86) && !defined(LISP_FEATURE_X86_64)
@@ -649,7 +649,7 @@ static int
 print_context_cmd(char **ptr)
 {
     int free_ici;
-    struct thread *thread=get_sb_vm_thread();
+    struct thread *thread = get_sb_vm_thread();
 
     free_ici = fixnum_value(read_TLS(FREE_INTERRUPT_CONTEXT_INDEX,thread));
 
diff --git src/runtime/parse.c src/runtime/parse.c
index 88e3dbb0d..812062d9a 100644
--- src/runtime/parse.c
+++ src/runtime/parse.c
@@ -263,7 +263,7 @@ static int parse_regnum(char *s)
 
 int parse_lispobj(char **ptr, lispobj *output)
 {
-    struct thread *thread=get_sb_vm_thread();
+    struct thread *thread = get_sb_vm_thread();
     char *token = parse_token(ptr);
     uword_t pointer;
     lispobj result;
diff --git src/runtime/ppc-arch.c src/runtime/ppc-arch.c
index 757997f09..9cb7c4369 100644
--- src/runtime/ppc-arch.c
+++ src/runtime/ppc-arch.c
@@ -18,7 +18,7 @@
 #include "os.h"
 #include "interrupt.h"
 #include "lispregs.h"
-#include "signal.h"
+#include <signal.h>
 #include "interrupt.h"
 #include "interr.h"
 #include "breakpoint.h"
@@ -88,22 +88,16 @@ arch_internal_error_arguments(os_context_t *context)
 }
 
 
-boolean
-arch_pseudo_atomic_atomic(os_context_t *context)
-{
-    return get_pseudo_atomic_atomic(get_sb_vm_thread());
+boolean arch_pseudo_atomic_atomic(struct thread *thread) {
+    return get_pseudo_atomic_atomic(thread);
 }
 
-void
-arch_set_pseudo_atomic_interrupted(os_context_t *context)
-{
-    set_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_set_pseudo_atomic_interrupted(struct thread *thread) {
+    set_pseudo_atomic_interrupted(thread);
 }
 
-void
-arch_clear_pseudo_atomic_interrupted(os_context_t *context)
-{
-    clear_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_clear_pseudo_atomic_interrupted(struct thread *thread) {
+    clear_pseudo_atomic_interrupted(thread);
 }
 
 unsigned int
@@ -516,7 +510,7 @@ sigtrap_handler(int signal, siginfo_t *siginfo, os_context_t *context)
             if (handle_allocation_trap(context)) return;
         }
         if (code == 0x7C2002A6) { // pending interrupt
-            arch_clear_pseudo_atomic_interrupted(context);
+            arch_clear_pseudo_atomic_interrupted(get_sb_vm_thread());
             arch_skip_instruction(context);
             interrupt_handle_pending(context);
             return;
@@ -533,7 +527,7 @@ sigtrap_handler(int signal, siginfo_t *siginfo, os_context_t *context)
     if (code == ((3 << 26) | (0x18 << 21) | (reg_NL3 << 16))|| // TWI NE,$NL3,0
         /* trap instruction from do_pending_interrupt */
         code == 0x7fe00008) { // TW T,0,0
-        arch_clear_pseudo_atomic_interrupted(context);
+        arch_clear_pseudo_atomic_interrupted(get_sb_vm_thread());
         arch_skip_instruction(context);
         /* interrupt or GC was requested in PA; now we're done with the
            PA section we may as well get around to it */
diff --git src/runtime/ppc-linux-os.c src/runtime/ppc-linux-os.c
index 7a9efada9..b0c5388da 100644
--- src/runtime/ppc-linux-os.c
+++ src/runtime/ppc-linux-os.c
@@ -19,7 +19,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/riscv-arch.c src/runtime/riscv-arch.c
index 6c1994829..72c55dc03 100644
--- src/runtime/riscv-arch.c
+++ src/runtime/riscv-arch.c
@@ -17,7 +17,7 @@
 #include "validate.h"
 #include "os.h"
 #include "lispregs.h"
-#include "signal.h"
+#include <signal.h>
 #include "alloc.h"
 #include "interrupt.h"
 #include "interr.h"
@@ -42,34 +42,16 @@ unsigned char *arch_internal_error_arguments(os_context_t *context)
     return (unsigned char*)(OS_CONTEXT_PC(context) + 5);
 }
 
-boolean arch_pseudo_atomic_atomic(os_context_t *context)
-{
-    /* FIXME: this foreign_function_call_active test is dubious at
-     * best. If a foreign call is made in a pseudo atomic section
-     * (?) or more likely a pseudo atomic section is in a foreign
-     * call then an interrupt is executed immediately. Maybe it
-     * has to do with C code not maintaining pseudo atomic
-     * properly. MG - 2005-08-10
-     *
-     * The foreign_function_call_active used to live at each call-site
-     * to arch_pseudo_atomic_atomic, but this seems clearer.
-     * --NS 2007-05-15 */
-#ifdef LISP_FEATURE_GENCGC
-    return get_pseudo_atomic_atomic(get_sb_vm_thread());
-#else
-    return (!foreign_function_call_active)
-        && (NIL != SymbolValue(PSEUDO_ATOMIC_ATOMIC,0));
-#endif
+boolean arch_pseudo_atomic_atomic(struct thread *thread) {
+    return get_pseudo_atomic_atomic(thread);
 }
 
-void arch_set_pseudo_atomic_interrupted(os_context_t *context)
-{
-    set_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_set_pseudo_atomic_interrupted(struct thread *thread) {
+    set_pseudo_atomic_interrupted(thread);
 }
 
-void arch_clear_pseudo_atomic_interrupted(os_context_t *context)
-{
-    clear_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_clear_pseudo_atomic_interrupted(struct thread *thread) {
+    clear_pseudo_atomic_interrupted(thread);
 }
 
 unsigned int arch_install_breakpoint(void *pc)
@@ -159,7 +141,7 @@ arch_install_interrupt_handlers(void)
  * Linkage entry size is 8 or 20, because we need 2 instructions for the 32-bit case and we need 3 instructions and an 8 byte address in the 64-bit case.
  */
 
-#define LINKAGE_TEMP_REG reg_NL3
+#define LINKAGE_TEMP_REG reg_LIP // Lisp needs to save before entry.
 
 void arch_write_linkage_table_entry(int index, void *target_addr, int datap)
 {
diff --git src/runtime/riscv-linux-os.c src/runtime/riscv-linux-os.c
index 3c625ee72..7591d7265 100644
--- src/runtime/riscv-linux-os.c
+++ src/runtime/riscv-linux-os.c
@@ -19,7 +19,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/runtime.c src/runtime/runtime.c
index 8c6619d9f..c020164cd 100644
--- src/runtime/runtime.c
+++ src/runtime/runtime.c
@@ -43,7 +43,7 @@
 #include <time.h>
 
 #ifndef LISP_FEATURE_WIN32
-#include "signal.h"
+#include <signal.h>
 #endif
 
 #include "runtime.h"
@@ -323,7 +323,7 @@ parse_size_arg(char *arg, char *arg_name)
 
 char *core_string;
 
-static void print_environment(int argc, char *argv[])
+static void print_environment(int argc, char *argv[], char *envp[])
 {
     int n = 0;
     printf("; Commandline arguments:\n");
@@ -333,8 +333,8 @@ static void print_environment(int argc, char *argv[])
     }
     n = 0;
     printf(";\n; Environment:\n");
-    while (ENVIRON[n]) {
-        printf(";  %2d: \"%s\"\n", n, ENVIRON[n]);
+    while (envp[n]) {
+        printf(";  %2d: \"%s\"\n", n, envp[n]);
         ++n;
     }
 }
@@ -427,7 +427,7 @@ static int is_memsize_arg(char *argv[], int argi, int argc, int *merge_core_page
 
 static struct cmdline_options
 parse_argv(struct memsize_options memsize_options,
-           int argc, char *argv[], char *core)
+           int argc, char *argv[], char *envp[], char *core)
 {
 #ifdef LISP_FEATURE_WIN32
     wchar_t
@@ -596,7 +596,7 @@ parse_argv(struct memsize_options memsize_options,
         }
     }
     if (debug_environment_p) {
-        print_environment(argc, argv);
+        print_environment(argc, argv, envp);
     }
 
     struct cmdline_options o;
@@ -662,7 +662,7 @@ initialize_lisp(int argc, char *argv[], char *envp[])
         }
     }
 
-    struct cmdline_options options = parse_argv(memsize_options, argc, argv, core);
+    struct cmdline_options options = parse_argv(memsize_options, argc, argv, envp, core);
 
     /* Align down to multiple of page_table page size, and to the appropriate
      * stack alignment. */
diff --git src/runtime/sparc-arch.c src/runtime/sparc-arch.c
index f5fad5ded..1ae52bf23 100644
--- src/runtime/sparc-arch.c
+++ src/runtime/sparc-arch.c
@@ -17,7 +17,7 @@
 #include "validate.h"
 #include "os.h"
 #include "lispregs.h"
-#include "signal.h"
+#include <signal.h>
 #include "alloc.h"
 #include "interrupt.h"
 #include "interr.h"
@@ -45,19 +45,16 @@ unsigned char *arch_internal_error_arguments(os_context_t *context)
     return (unsigned char *)(OS_CONTEXT_PC(context) + 4);
 }
 
-boolean arch_pseudo_atomic_atomic(os_context_t *context)
-{
-    return get_pseudo_atomic_atomic(get_sb_vm_thread());
+boolean arch_pseudo_atomic_atomic(struct thread *thread) {
+    return get_pseudo_atomic_atomic(thread);
 }
 
-void arch_set_pseudo_atomic_interrupted(os_context_t *context)
-{
-    set_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_set_pseudo_atomic_interrupted(struct thread *thread) {
+    set_pseudo_atomic_interrupted(thread);
 }
 
-void arch_clear_pseudo_atomic_interrupted(os_context_t *context)
-{
-    clear_pseudo_atomic_interrupted(get_sb_vm_thread());
+void arch_clear_pseudo_atomic_interrupted(struct thread *thread) {
+    clear_pseudo_atomic_interrupted(thread);
 }
 
 unsigned int arch_install_breakpoint(void *pc)
@@ -254,7 +251,7 @@ static void sigill_handler(int signal, siginfo_t *siginfo,
     else if (siginfo->si_code == ILL_ILLTRP) {
         if (pseudo_atomic_trap_p(context)) {
             /* A trap instruction from a pseudo-atomic. */
-            arch_clear_pseudo_atomic_interrupted(context);
+            arch_clear_pseudo_atomic_interrupted(get_sb_vm_thread());
             arch_skip_instruction(context);
             interrupt_handle_pending(context);
         }
diff --git src/runtime/sparc-bsd-os.c src/runtime/sparc-bsd-os.c
index ca4159e9e..f4c812d22 100644
--- src/runtime/sparc-bsd-os.c
+++ src/runtime/sparc-bsd-os.c
@@ -18,7 +18,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/sparc-linux-os.c src/runtime/sparc-linux-os.c
index 069fecbd4..464b648d1 100644
--- src/runtime/sparc-linux-os.c
+++ src/runtime/sparc-linux-os.c
@@ -18,7 +18,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/sparc-sunos-os.c src/runtime/sparc-sunos-os.c
index d621afc2f..a847e80b2 100644
--- src/runtime/sparc-sunos-os.c
+++ src/runtime/sparc-sunos-os.c
@@ -18,7 +18,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/thread.c src/runtime/thread.c
index d0f9f2dd6..bfc0c3f41 100644
--- src/runtime/thread.c
+++ src/runtime/thread.c
@@ -429,8 +429,6 @@ init_new_thread(struct thread *th,
                 init_thread_data __attribute__((unused)) *scribble,
                 int guardp)
 {
-    int lock_ret;
-
     ASSIGN_CURRENT_THREAD(th);
     if(arch_os_thread_init(th)==0) {
         /* FIXME: handle error */
@@ -457,7 +455,7 @@ init_new_thread(struct thread *th,
 #ifdef LISP_FEATURE_SB_SAFEPOINT
     csp_around_foreign_call(th) = (lispobj)scribble;
 #endif
-    lock_ret = mutex_acquire(&all_threads_lock);
+    __attribute__((unused)) int lock_ret = mutex_acquire(&all_threads_lock);
     gc_assert(lock_ret);
     link_thread(th);
     ignore_value(mutex_release(&all_threads_lock));
@@ -477,8 +475,6 @@ static void
 unregister_thread(struct thread *th,
                   init_thread_data __attribute__((unused)) *scribble)
 {
-    int lock_ret;
-
     block_blockable_signals(0);
     gc_close_thread_regions(th, LOCK_PAGE_TABLE|CONSUME_REMAINDER);
 #ifdef LISP_FEATURE_SB_SAFEPOINT
@@ -492,7 +488,7 @@ unregister_thread(struct thread *th,
      * thread, but since we are either exiting lisp code as a lisp
      * thread that is dying, or exiting lisp code to return to
      * former status as a C thread, it won't wait long. */
-    lock_ret = mutex_acquire(&all_threads_lock);
+    __attribute__((unused)) int lock_ret = mutex_acquire(&all_threads_lock);
     gc_assert(lock_ret);
     unlink_thread(th);
     lock_ret = mutex_release(&all_threads_lock);
@@ -652,8 +648,7 @@ static struct thread* recyclebin_threads;
 static struct thread* get_recyclebin_item()
 {
     struct thread* result = 0;
-    int rc;
-    rc = mutex_acquire(&recyclebin_lock);
+    __attribute__((unused)) int rc = mutex_acquire(&recyclebin_lock);
     gc_assert(rc);
     if (recyclebin_threads) {
         result = recyclebin_threads;
@@ -664,8 +659,7 @@ static struct thread* get_recyclebin_item()
 }
 static void put_recyclebin_item(struct thread* th)
 {
-    int rc;
-    rc = mutex_acquire(&recyclebin_lock);
+    __attribute__((unused)) int rc = mutex_acquire(&recyclebin_lock);
     gc_assert(rc);
     th->next = recyclebin_threads;
     recyclebin_threads = th;
@@ -1231,7 +1225,7 @@ void gc_start_the_world()
     }
 #endif
     struct thread *th, *me = get_sb_vm_thread();
-    int lock_ret;
+    __attribute__((unused)) int lock_ret;
     /* if a resumed thread creates a new thread before we're done with
      * this loop, the new thread will be suspended waiting to acquire
      * the all_threads lock */
diff --git src/runtime/thread.h src/runtime/thread.h
index 3fbb7d4ef..5d8e45d00 100644
--- src/runtime/thread.h
+++ src/runtime/thread.h
@@ -28,8 +28,9 @@ struct thread_state_word {
 #endif
 };
 
-// (DEFCONSTANT +N-SMALL-BUCKETS+ 32)
-typedef lispobj size_histogram[32+N_WORD_BITS];
+#define N_HISTOGRAM_BINS_LARGE 32
+#define N_HISTOGRAM_BINS_SMALL 32
+typedef lispobj size_histogram[2*N_HISTOGRAM_BINS_LARGE+N_HISTOGRAM_BINS_SMALL];
 
 #include "genesis/thread.h"
 #include "genesis/thread-instance.h"
diff --git src/runtime/traceroot.c src/runtime/traceroot.c
index 7980e0b1a..837790efc 100644
--- src/runtime/traceroot.c
+++ src/runtime/traceroot.c
@@ -26,7 +26,7 @@
 #ifndef LISP_FEATURE_WIN32
 #define HAVE_GETRUSAGE 1
 #endif
-#if HAVE_GETRUSAGE
+#ifdef HAVE_GETRUSAGE
 #include <sys/resource.h> // for getrusage()
 #endif
 
@@ -926,14 +926,14 @@ static void* compute_heap_inverse(boolean keep_leaves,
     if (heap_trace_verbose) {
         fprintf(stderr, "Scratchpad: %lu bytes\n", (long unsigned)scratchpad_size);
     }
-#if HAVE_GETRUSAGE
+#ifdef HAVE_GETRUSAGE
     struct rusage before, after;
     getrusage(RUSAGE_SELF, &before);
 #endif
     ss.record_ptrs = 1;
     scan_spaces(&ss);
     *scratchpad = ss.scratchpad;
-#if HAVE_GETRUSAGE
+#ifdef HAVE_GETRUSAGE
     getrusage(RUSAGE_SELF, &after);
     // We're done building the necessary structure. Show some memory stats.
     if (heap_trace_verbose) {
diff --git src/runtime/validate.c src/runtime/validate.c
index a7502849b..90be4c922 100644
--- src/runtime/validate.c
+++ src/runtime/validate.c
@@ -32,6 +32,9 @@ uword_t DYNAMIC_SPACE_START;
 #ifndef LISP_FEATURE_DARWIN_JIT
 uword_t READ_ONLY_SPACE_START, READ_ONLY_SPACE_END;
 #endif
+#ifdef LISP_FEATURE_RELOCATABLE_STATIC_SPACE
+uword_t STATIC_SPACE_START, STATIC_SPACE_END;
+#endif
 
 uword_t asm_routines_start, asm_routines_end;
 
diff --git src/runtime/validate.h src/runtime/validate.h
index 4f41bdde6..aaeb88ecf 100644
--- src/runtime/validate.h
+++ src/runtime/validate.h
@@ -28,6 +28,9 @@
 /* constants derived from the fundamental constants in passed by GENESIS */
 #define READ_ONLY_SPACE_SIZE (READ_ONLY_SPACE_END - READ_ONLY_SPACE_START)
 #define STATIC_SPACE_SIZE (STATIC_SPACE_END - STATIC_SPACE_START)
+#define NIL_SYMBOL_SLOTS_START (STATIC_SPACE_START + NIL_SYMBOL_SLOTS_OFFSET)
+#define NIL_SYMBOL_SLOTS_END (STATIC_SPACE_START + NIL_SYMBOL_SLOTS_END_OFFSET)
+#define STATIC_SPACE_OBJECTS_START (STATIC_SPACE_START + STATIC_SPACE_OBJECTS_OFFSET)
 
 #ifdef LISP_FEATURE_DARWIN_JIT
 #define STATIC_CODE_SPACE_SIZE (STATIC_CODE_SPACE_END - STATIC_CODE_SPACE_START)
diff --git src/runtime/win32-os.c src/runtime/win32-os.c
index 1bea4e957..000fbfb6e 100644
--- src/runtime/win32-os.c
+++ src/runtime/win32-os.c
@@ -323,10 +323,10 @@ uint32_t os_get_build_time_shared_libraries(uint32_t excl_maximum,
                                        void** opt_store_handles,
                                        const char *opt_store_names[])
 {
-    void* base = opt_root ? opt_root : (void*)runtime_module_handle;
+    char* base = opt_root ? opt_root : (void*)runtime_module_handle;
     /* base defaults to 0x400000 with GCC/mingw32. If you dereference
      * that location, you'll see 'MZ' bytes */
-    void* base_magic_location =
+    char* base_magic_location =
         base + ((IMAGE_DOS_HEADER*)base)->e_lfanew;
 
     /* dos header provided the offset from `base' to
@@ -570,7 +570,7 @@ static void resolve_optional_imports()
 
 #undef RESOLVE
 
-intptr_t win32_get_module_handle_by_address(os_vm_address_t addr)
+intptr_t win32_get_module_handle_by_address(void* addr)
 {
     HMODULE result = 0;
     /* So apparently we could use VirtualQuery instead of
@@ -752,7 +752,7 @@ win32_reset_stack_overflow_guard_page() {
      * unwinding from a stack overflow condition without retriggering the guard
      * page. See test (:EXHAUST :WRITE-TO-STACK-ON-UNWIND). */
 #define WIN32_STACK_GUARD_SLACK (2*win32_stack_guarantee + win32_page_size)
-    void *stack_guard_start = CONTROL_STACK_GUARD_PAGE(self);
+    char *stack_guard_start = CONTROL_STACK_GUARD_PAGE(self);
     fprintf(stderr, "INFO: Reprotecting control stack guard (0x%p+0x%x)\n",
             stack_guard_start, WIN32_STACK_GUARD_SLACK);
     fflush(stderr);
diff --git src/runtime/win32-os.h src/runtime/win32-os.h
index de10498cf..f561f11d9 100644
--- src/runtime/win32-os.h
+++ src/runtime/win32-os.h
@@ -31,7 +31,14 @@
 
 #include "pthreads_win32.h"
 
+#ifdef LISP_FEATURE_64_BIT
+/* LPVOID can't be legally used in pointer arithmetic.
+ * (so all the arithmetic in 'validate.h' is technically illegal).
+ * But I can't test 32-bit so let it stay as was */
+typedef char* os_vm_address_t;
+#else
 typedef LPVOID os_vm_address_t;
+#endif
 typedef uword_t os_vm_size_t;
 typedef intptr_t os_vm_offset_t;
 typedef int os_vm_prot_t;
diff --git src/runtime/x86-64-arch.c src/runtime/x86-64-arch.c
index 48827a9a2..5108da241 100644
--- src/runtime/x86-64-arch.c
+++ src/runtime/x86-64-arch.c
@@ -20,7 +20,7 @@
 #include "os.h"
 #include "arch.h"
 #include "lispregs.h"
-#include "signal.h"
+#include <signal.h>
 #include "alloc.h"
 #include "interrupt.h"
 #include "interr.h"
@@ -247,23 +247,15 @@ arch_internal_error_arguments(os_context_t *context)
     return 1 + (unsigned char *)OS_CONTEXT_PC(context);
 }
 
-boolean
-arch_pseudo_atomic_atomic(os_context_t __attribute__((unused)) *context)
-{
-    return get_pseudo_atomic_atomic(get_sb_vm_thread());
+boolean arch_pseudo_atomic_atomic(struct thread *thread) {
+    return get_pseudo_atomic_atomic(thread);
 }
 
-void
-arch_set_pseudo_atomic_interrupted(os_context_t __attribute__((unused)) *context)
-{
-    struct thread *thread = get_sb_vm_thread();
+void arch_set_pseudo_atomic_interrupted(struct thread *thread) {
     set_pseudo_atomic_interrupted(thread);
 }
 
-void
-arch_clear_pseudo_atomic_interrupted(os_context_t __attribute__((unused)) *context)
-{
-    struct thread *thread = get_sb_vm_thread();
+void arch_clear_pseudo_atomic_interrupted(struct thread *thread) {
     clear_pseudo_atomic_interrupted(thread);
 }
 
diff --git src/runtime/x86-64-linux-os.c src/runtime/x86-64-linux-os.c
index 7bbbf976f..ae8229260 100644
--- src/runtime/x86-64-linux-os.c
+++ src/runtime/x86-64-linux-os.c
@@ -26,7 +26,6 @@
 
 #include <sys/ucontext.h>
 
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/x86-64-sunos-os.c src/runtime/x86-64-sunos-os.c
index 1eb464d64..dbe2f0b8e 100644
--- src/runtime/x86-64-sunos-os.c
+++ src/runtime/x86-64-sunos-os.c
@@ -2,7 +2,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/x86-arch.c src/runtime/x86-arch.c
index 8969326d4..c6dfcc33d 100644
--- src/runtime/x86-arch.c
+++ src/runtime/x86-arch.c
@@ -137,23 +137,15 @@ arch_internal_error_arguments(os_context_t *context)
     return 1 + (unsigned char *)(OS_CONTEXT_PC(context));
 }
 
-boolean
-arch_pseudo_atomic_atomic(os_context_t *context)
-{
-    return get_pseudo_atomic_atomic(get_sb_vm_thread());
+boolean arch_pseudo_atomic_atomic(struct thread *thread) {
+    return get_pseudo_atomic_atomic(thread);
 }
 
-void
-arch_set_pseudo_atomic_interrupted(os_context_t *context)
-{
-    struct thread *thread = get_sb_vm_thread();
+void arch_set_pseudo_atomic_interrupted(struct thread *thread) {
     set_pseudo_atomic_interrupted(thread);
 }
 
-void
-arch_clear_pseudo_atomic_interrupted(os_context_t *context)
-{
-    struct thread *thread = get_sb_vm_thread();
+void arch_clear_pseudo_atomic_interrupted(struct thread *thread) {
     clear_pseudo_atomic_interrupted(thread);
 }
 
diff --git src/runtime/x86-linux-os.c src/runtime/x86-linux-os.c
index 429d9c8fc..d6e047c3d 100644
--- src/runtime/x86-linux-os.c
+++ src/runtime/x86-linux-os.c
@@ -23,7 +23,6 @@
 #include <errno.h>
 
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git src/runtime/x86-sunos-os.c src/runtime/x86-sunos-os.c
index 1c6562f02..3fc06161e 100644
--- src/runtime/x86-sunos-os.c
+++ src/runtime/x86-sunos-os.c
@@ -2,7 +2,6 @@
 #include <sys/param.h>
 #include <sys/file.h>
 #include "sbcl.h"
-#include "./signal.h"
 #include "os.h"
 #include "arch.h"
 #include "globals.h"
diff --git tests/alloc-histo.impure.lisp tests/alloc-histo.impure.lisp
new file mode 100644
index 000000000..4010de3b4
--- /dev/null
+++ tests/alloc-histo.impure.lisp
@@ -0,0 +1,110 @@
+
+#-(and x86-64 system-tlabs) (invoke-restart 'run-tests::skip-file)
+
+(defvar *print-histogram* nil)
+(defun check-histogram (bin-index count kind)
+  (let* ((h (sb-thread:allocator-histogram))
+         (bins (first h))
+         (ok t))
+    (dotimes (i (length bins))
+      (setq ok (and ok
+                    (if (= i bin-index)
+                        (= (aref bins bin-index) count)
+                        (zerop (aref bins i))))))
+    (when (or (not ok) *print-histogram*)
+      (sb-thread:print-allocator-histogram h))
+    (unless ok
+      (error "Unexpected histogram: expected bin ~D = ~D"
+             bin-index count))
+    ;; this isn't using the large-object-size vector so we can't assert
+    ;; about boxed/unboxed for bin >= 32
+    (when (<= bin-index 31)
+      (let ((nbytes (* count (* (1+ bin-index) sb-vm:cons-size sb-vm:n-word-bytes))))
+        (ecase kind
+          (:unboxed (assert (= (third h) nbytes)))
+          (:boxed (assert (= (fourth h) nbytes))))))
+    h))
+(compile 'check-histogram)
+
+(defun compile-with-histogram (lexpr)
+  (let ((*features* (cons :allocation-size-histogram *features*)))
+    (compile nil lexpr)))
+
+(defvar *arena* (sb-vm:new-arena (* 512 1024 1024))) ; 512 MiB
+
+(defun %assert-histogram (lambda bin-index count kind)
+  (sb-thread:reset-allocator-histogram)
+  (sb-vm:with-arena (*arena*)
+    (funcall lambda))
+  (sb-vm:rewind-arena *arena*)
+  (check-histogram bin-index count kind))
+(compile '%assert-histogram)
+
+(defmacro assert-histogram (form bin-index count kind)
+  `(%assert-histogram (compile-with-histogram '(lambda () ,form)) ,bin-index ,count ,kind))
+
+(test-util:with-test (:name :1-cons)
+  (assert-histogram (cons 1 2) 0 1 :boxed))
+
+(test-util:with-test (:name :2-cons)
+  ;; this counts _allocations_ of a given size, not objects of a given size.
+  ;; The latter whould say that it was 2 cons-sized objects, but in fact
+  ;; it is counted as 1 4-word object.
+  (assert-histogram (list 1 2) 1 1 :boxed))
+
+(test-util:with-test (:name :bit-vector)
+  (assert-histogram (make-array 128 :element-type 'bit)
+                    1 1 :unboxed))
+
+(setf (symbol-function 'instrumented-make-array-n)
+      (compile-with-histogram '(lambda (n) (make-array (the integer n)))))
+
+;; make boxed arrays from 1 to 32 conses in length
+(test-util:with-test (:name :boxed-array-small)
+  (loop for array-len from 0 to 62 by 2
+        for bin-index from 0
+        do (let* ((constructor `(make-array ,array-len))
+                  (function (compile-with-histogram `(lambda () ,constructor))))
+             (assert (= (primitive-object-size (funcall function))
+                        (* (+ array-len sb-vm:vector-data-offset)
+                           sb-vm:n-word-bytes)))
+             (let ((expected-histogram (%assert-histogram function bin-index 1 :boxed)))
+               (sb-thread:reset-allocator-histogram)
+               (opaque-identity (funcall 'instrumented-make-array-n array-len))
+               (let ((histogram (sb-thread:allocator-histogram)))
+                 (assert (equalp histogram expected-histogram)))))))
+
+(test-util:with-test (:name :boxed-array-large-bins)
+  ;; an array of 64 words exceeds the largest small bin
+  (let ((array-len 64))
+    (dotimes (trial 300)
+      (let* ((constructor `(make-array ,array-len))
+             (function (compile-with-histogram `(lambda () ,constructor)))
+             (nbytes (primitive-object-size (funcall function)))
+             (bin-index
+              (+ 32 ; skip over the small bins
+                 (integer-length nbytes)
+                 -10))) ; first large bin is for 2^10.  Subtract the bias
+        (assert (= nbytes
+                   (* (+ array-len sb-vm:vector-data-offset)
+                      sb-vm:n-word-bytes)))
+        (let ((expected-histogram (%assert-histogram function bin-index 1 :boxed)))
+          (sb-thread:reset-allocator-histogram)
+          (opaque-identity (funcall 'instrumented-make-array-n array-len))
+          (let ((histogram (sb-thread:allocator-histogram)))
+            ;; (sb-thread:print-allocator-histogram histogram)
+            (assert (equalp histogram expected-histogram)))))
+      (incf array-len 2))))
+
+(defun make-monster ()
+  (let* ((desired-size (* 1024 1024 1024)) ; 1 GiB
+         (desired-nwords (/ desired-size sb-vm:n-word-bytes))
+         (nelem (- desired-nwords 2)))
+    (funcall 'instrumented-make-array-n nelem)))
+
+;(setq *print-histogram* t)
+(test-util:with-test (:name :monster)
+  (assert-histogram (make-monster)
+                    ;; I just printed the histogram and looked at it, and wired in
+                    ;; the expected bin. I dont really feel like computing it in the test.
+                    53 1 :boxed))
diff --git tests/arith-combinations.pure.lisp tests/arith-combinations.pure.lisp
index b70756096..8fc2880e0 100644
--- tests/arith-combinations.pure.lisp
+++ tests/arith-combinations.pure.lisp
@@ -11,7 +11,7 @@
 
 (enable-test-parallelism)
 
-(defun test-ops (ops types arguments &optional (result-types types))
+(defun test-ops (ops types arguments &key (result-types types) (b-arguments arguments))
   (flet ((normalize-type (type)
            (sb-kernel:type-specifier (sb-kernel:specifier-type type))))
     (let ((types (mapcar #'normalize-type types))
@@ -29,7 +29,7 @@
                               (loop for a in arguments
                                     when (typep a a-type)
                                     do
-                                    (loop for b in arguments
+                                    (loop for b in b-arguments
                                           for result = (funcall op a b)
                                           when (typep b b-type)
                                           do
@@ -103,6 +103,31 @@
                   (floor most-positive-fixnum 2)
                   (floor most-negative-fixnum 2))))
 
+(with-test (:name :overflow-ash)
+  (test-ops '(ash)
+            `(t fixnum
+                (signed-byte ,sb-vm:n-word-bits)
+                (unsigned-byte ,sb-vm:n-word-bits)
+                (integer ,(- 1 sb-vm:n-word-bits)
+                         ,(1- sb-vm:n-word-bits))
+                (integer 0
+                         ,(1- sb-vm:n-word-bits))
+                (and fixnum unsigned-byte))
+            (list* most-positive-fixnum
+                   (1- most-positive-fixnum)
+                   (1+ most-positive-fixnum)
+                   (1- (expt 2 sb-vm:n-word-bits))
+                   #1=(list 0 1 3 4 -1 -3 -4
+                            most-negative-fixnum
+                            (1+ most-negative-fixnum)
+                            (1- most-negative-fixnum)
+                            (- (expt 2 (1- sb-vm:n-word-bits)))
+                            (- 1 (expt 2 (1- sb-vm:n-word-bits)))
+                            (- -1 (expt 2 (1- sb-vm:n-word-bits)))))
+            :b-arguments (list* sb-vm:n-word-bits (- sb-vm:n-word-bits)
+                                (- 1 sb-vm:n-word-bits) (1- sb-vm:n-word-bits)
+                                300 -300 #1#)))
+
 (with-test (:name :fixnum-integer-cmp)
   (test-ops '(> <)
             `(t fixnum
@@ -128,7 +153,7 @@
                   (1+ most-negative-fixnum)
                   (floor most-positive-fixnum 2)
                   (floor most-negative-fixnum 2))
-            '(t)))
+            :result-types '(t)))
 
 (with-test (:name :integer-ratio-float-compare)
   (test-ops '(> <)
@@ -155,4 +180,4 @@
                   (1+ most-negative-fixnum)
                   (floor most-positive-fixnum 2)
                   (floor most-negative-fixnum 2))
-            '(t)))
+            :result-types '(t)))
diff --git tests/arith.pure.lisp tests/arith.pure.lisp
index b6f740ecf..ada1b81bb 100644
--- tests/arith.pure.lisp
+++ tests/arith.pure.lisp
@@ -1150,3 +1150,24 @@
    `(lambda (u s)
       (the (unsigned-byte 64) (+ (the (or null (unsigned-byte 64)) u) (the fixnum s))))
    ((1 2) 3)))
+
+(with-test (:name :rem-derive-type)
+  (flet ((test (form type)
+           (assert
+            (type-specifiers-equal
+             (caddr
+              (sb-kernel:%simple-fun-type
+               (checked-compile
+                `(lambda (a b)
+                   ,form))))
+             `(values ,type &optional)))))
+    (test `(rem (the fixnum a) (the integer b))
+          'fixnum)
+    (test `(rem (the fixnum a) (the (integer 0 20) b))
+          '(integer -19 19))
+    (test `(rem (the (unsigned-byte 32) a) (the (integer 0 20) b))
+          '(integer 0 19))
+    (test `(rem (the (signed-byte 32) a) (the (unsigned-byte 32) b))
+          '(signed-byte 32))
+    (test `(rem (the (signed-byte 8) a) (the (unsigned-byte 7) b))
+          '(integer -126 126))))
diff --git tests/array.pure.lisp tests/array.pure.lisp
index cb3ba9008..a8e7e01a6 100644
--- tests/array.pure.lisp
+++ tests/array.pure.lisp
@@ -722,3 +722,10 @@
                                                        x))
                                              (length x)))))
                  `(values (integer 11 12) &optional))))
+
+(with-test (:name :aref-dimension-checking)
+  (checked-compile-and-assert
+      (:optimize :safe)
+      `(lambda (x)
+         (aref x 0))
+    ((#2A((1 2) (3 4))) (condition 'type-error))))
diff --git tests/compiler-2.pure.lisp tests/compiler-2.pure.lisp
index 19474e640..f4de341d9 100644
--- tests/compiler-2.pure.lisp
+++ tests/compiler-2.pure.lisp
@@ -3396,7 +3396,8 @@
                               -913097464
                               5)))
            39)))))
-    '(values (or (integer -21 -20) bit) (integer -38 0) &optional)))
+    '(values (or (integer -21 -21) (integer 0 0)) (integer -38 0)
+      &optional)))
   (assert
    (type-specifiers-equal
     (caddr
diff --git tests/compiler-ir.pure.lisp tests/compiler-ir.pure.lisp
index 9ec1247d6..4940ad905 100644
--- tests/compiler-ir.pure.lisp
+++ tests/compiler-ir.pure.lisp
@@ -410,7 +410,7 @@
   (let* ((types '(sb-vm:word sb-vm:signed-word))
          (the-types `(fixnum (unsigned-byte 16) (signed-byte 16) ,@types)))
     (loop
-      for op in '(+ - *)
+      for op in '(+ - * negate)
       do
       (loop
         for a-type in types
@@ -419,10 +419,14 @@
           for b-type in types
           do
           (loop for the-type in the-types
-                for lambda = `(lambda (a b)
-                                (declare (,a-type a)
-                                         (,b-type b))
-                                (the ,the-type (,op a b)))
+                for lambda = (if (eq op 'negate)
+                                 `(lambda (a)
+                                    (declare (,a-type a))
+                                    (the ,the-type (- a)))
+                                 `(lambda (a b)
+                                    (declare (,a-type a)
+                                             (,b-type b))
+                                    (the ,the-type (,op a b))))
                 do (unless (find-if (lambda (x)
                                       (eql (search "OVERFLOW" (string x)) 0))
                                     (ir2-vops lambda))
diff --git tests/dynamic-extent.pure.lisp tests/dynamic-extent.pure.lisp
index 7f85dda25..b3abb1161 100644
--- tests/dynamic-extent.pure.lisp
+++ tests/dynamic-extent.pure.lisp
@@ -173,7 +173,7 @@
 
 (defun-with-dx dx-value-cell (x)
   ;; Not implemented everywhere, yet.
-  #+(or x86 x86-64 mips)
+  #+(or arm64 x86 x86-64 mips)
   (let ((cell x))
     (declare (sb-int:truly-dynamic-extent cell))
     (flet ((f ()
@@ -874,7 +874,7 @@
     (assert (every (lambda (x) (eql x 0)) a))))
 
 (with-test (:name (:dx-bug-misc :bdowning-2005-iv-16))
-  #+(or mips x86 x86-64)
+  #+(or arm64 mips x86 x86-64)
   (assert-no-consing (bdowning-2005-iv-16))
   (bdowning-2005-iv-16))
 
@@ -929,7 +929,7 @@
       (multiple-value-bind (y pos2) (read-from-string res nil nil :start pos)
         (assert (equalp f2 y))
         (assert (equalp f3 (read-from-string res nil nil :start pos2))))))
-  #+(or mips x86 x86-64)
+  #+(or arm64 mips x86 x86-64)
   (assert-no-consing (assert (eql n (funcall fun nil))))
   (assert (eql n (funcall fun nil))))
 
diff --git tests/run-tests.lisp tests/run-tests.lisp
index 22f2f2814..e49b6bf34 100644
--- tests/run-tests.lisp
+++ tests/run-tests.lisp
@@ -503,33 +503,6 @@
                             sb-kernel::%compiler-defclass))
             (sb-int:unencapsulate symbol 'defblah-guard)))))
     (makunbound '*allowed-inputs*)
-    ;; MUTEX-P could crash on a layoutless instance (tests may make such things).
-    ;; Normally a layoutless instance can never be see because user code can not
-    ;; publish an object until leaving its constructor, and a structure constructor
-    ;; wouldn't return before storing a layout. But MAP-ALLOCATED-OBJECTS finds it.
-    #+nil
-    (let* ((mutexes
-            (remove-if (lambda (x)
-                         (or (eq x sb-impl::*active-processes-lock*)
-                             (eq x sb-impl::*finalizer-lock*)
-                             #+nil (eq x sb-vm::*allocator-mutex*)))
-                       (sb-vm:list-allocated-objects :all :test #'sb-thread::mutex-p)))
-           (contended (remove-if
-                       (lambda (x)
-                         (or (atom (sb-thread::mutex-%name x))
-                             (zerop (cdr (sb-thread::mutex-%name x)))
-                             ;; finalizer thread is started and stopped often for tests.
-                             ;; No only is it annoying to see it in here, to be correct
-                             ;; we'd need to sum the times of all same-named mutexes.
-                             (string= (sb-thread:mutex-name x) "finalizer")))
-                       mutexes)))
-      (when contended
-        (format t "~&Most-contended mutexes:~%")
-        (dolist (x (sort contended #'> :key (lambda (x) (cdr (sb-thread::mutex-%name x)))))
-          (format t "~12d ~s ~S~%"
-                  (cdr (sb-thread::mutex-%name x))
-                  x
-                  (sb-kernel:generation-of x)))))
     ;; after all the files are done
     (append-failures)))
 
diff --git tests/session.impure.lisp tests/session.impure.lisp
index 76f8c4b5e..c5b604931 100644
--- tests/session.impure.lisp
+++ tests/session.impure.lisp
@@ -114,7 +114,7 @@
 
 ;;; On termination, interactive (including foreground) threads remove
 ;;; themselves from the list of interactive threads in their
-;;; session. However, this did not previously include broadcasting the
+;;; session. However, this did not previously include notifying the
 ;;; interactive threads waitqueue, resulting in GET-FOREGROUND hanging
 ;;; after termination of the previous foreground thread.
 (with-test (:name (sb-thread::get-foreground :hang :missing-broadcast))
@@ -134,3 +134,14 @@
     (sb-thread:join-thread thread)
     (sb-thread:release-foreground thread)
     (get-foreground-quietly)))
+
+(with-test (:name :new-session)
+  (let ((old-session sb-thread::*session*))
+    (sb-thread:with-new-session ()
+      (let ((new-session sb-thread::*session*))
+        (assert (not (eq old-session new-session)))
+        ;; this thread should not be in session-threads of the old session
+        (assert (not (member sb-thread:*current-thread*
+                             (sb-thread::session-threads old-session))))
+        (assert (member sb-thread:*current-thread*
+                        (sb-thread::session-threads new-session)))))))
diff --git tests/string.pure.lisp tests/string.pure.lisp
index 9530be32e..e42bc7d17 100644
--- tests/string.pure.lisp
+++ tests/string.pure.lisp
@@ -355,3 +355,22 @@ claim that any particular result from these edge cases constitutes a bug.
     (assert (if (sb-kernel:dynamic-space-obj-p str)
                 (eq res str)
                 (not (eq res str))))))
+
+(with-test (:name :string-case-type)
+  (macrolet
+      ((check (fun expected)
+         `(assert
+           (type-specifiers-equal
+            (second
+             (third
+              (sb-kernel:%simple-fun-type
+               (checked-compile '(lambda (x)
+                                  (declare (ignorable x))
+                                  ,fun)))))
+            ',expected))))
+    (check (string-upcase nil)
+           (simple-base-string 3))
+    (check (string-upcase (the symbol x))
+           simple-string)
+    (check (string-upcase (the character x))
+           (simple-string 1))))
diff --git tests/x86-64-codegen.impure.lisp tests/x86-64-codegen.impure.lisp
index 496eceb92..bbeb6c245 100644
--- tests/x86-64-codegen.impure.lisp
+++ tests/x86-64-codegen.impure.lisp
@@ -1224,7 +1224,7 @@
              (let ((neg (- val))) (make-point neg))))))
     (assert (equal vops-with-barrier '("SET-SLOT")))))
 
-(with-test (:name :system-tlabs)
+(with-test (:name :system-tlabs :skipped-on (not :sb-thread))
   (when (find-symbol "SYS-ALLOC-TRAMP" "SB-VM")
     (assert (loop for line in (disassembly-lines 'sb-impl:test-make-packed-info)
                   thereis (search "SYS-ALLOC-TRAMP" line)))
